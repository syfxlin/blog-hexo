[{"title":"浅谈并发：CAS & AQS","date":"2021-02-13T15:21:44.000Z","url":"/talking-about-concurrent-cas-and-aqs.html","tags":["Java","并发","浅谈"],"categories":["折腾记录"],"content":"前言这篇文章躺在草稿里 6 个月了，最近才发现 2333，于是翻出来补全了下。 CASCAS（Compare-and-Swap 比较和替换）故名思意就是先比较然后替换的操作方式，是原子操作中的一种，同时也是无锁操作中的一种。在 Java 中广泛使用，常见的如 AQS 的更新状态、CopyOnWriteArrayList。 通常情况下，我们操作某个共享资源，为了防止其他进程的干扰，我们通常会给这个共享资源加上一把锁，然而加锁，释放锁，竞争锁，线程的阻塞和唤醒是非常耗能的操作。而 CAS 采用的是记录内存位置和原始值，当记录的原始值与当前内存位置的值（当前值）相同的时候，就将新值更新到内存。如果不同说明在这过程中有其他线程干扰，执行失败策略。由于是无锁的操作，所以便没有了加锁和释放锁间一系列的额外开销，所以非常快。 流程在进行 CAS 操作前需要三个操作参数： 内存位置V（它的值是我们想要去更新的） 预期原值A（上一次从内存中读取的值） 新值B（应该写入的新值） 操作过程： 先从 V 中取值，与 A 比较，如果相等则将 V 中的值更新成 B，如果不相等，说明 V 上的值被修改过了，也就是其他线程干扰了，这时候就不更新，进入失败的操作流程，比如重试，报错等。 缺点当然如果 CAS 真的这么好用的话 Java 中早就放弃锁了。CAS 虽然很高效的解决原子操作，但是 CAS 仍然存在三大问题，同时也有使用场景的限制。 ABA 问题原因：由于 CAS 是通过比较来判断是否进行更新操作，如果一个值从 A 变成 B，然后又被改成 A，在 CAS 检查时会认为值是没变的，实际上是变化了。 解决方法：为每次操作都加上版本号，如果版本号有变，即使值没变也说明是有变化的。 循环时间长开销大原因：如果自旋长时间不成功，则会给 CPU 带来很大的执行开销。 解决方法：利用 pause 指令提升自旋性能。 只能保证一个值的原子操作原因：如果有多个值需要同时操作，那么用 CAS 就无法简单解决了。 解决方案：可以对值进行合并，比如封装成一个对象等等。 使用场景限制从 CAS 流程中我们可以看到，为了记录原始值，我们需要复制一份值，而这复制过程消耗的性能在少量的情况下并不明显，相比于锁更优。然而如果大量的执行 CAS 操作，或者操作的内容是比较庞大的，那么这些性能损耗就不能忽视了，较为极端的情况下甚至比锁还要差上很多。 AQSAQS（AbstractQueuedSynchronizer 抽象排队同步器），是一个用来构建锁和同步器的框架，使用 AQS 能方便的构建出不同使用场景的同步器，常见的如 ReentrantLock、CountDownLatch。AQS 采用模板方法模式，实现大量通用方法，子类通过继承方式实现其抽象方法来管理同步状态。 流程当某个线程从 AQS 获取共享资源的时候，如果被请求的共享资源空闲，那么就将该线程设置为工作线程，然后锁定共享资源。如果被请求的共享资源被占用，那么就将线程加入 CLH 队列中，同时阻塞线程，进行排队等待。 CLH 队列CLH 队列是一个虚拟的 FIFO 的双向队列。头节点是一个获取同步状态成功的节点。线程通过 AQS 获取锁失败，就会将线程封装成一个 Node 节点，插入队列尾。当有线程释放锁时，后唤醒头节点的 next 节点（第二个节点）尝试占用锁。 同步状态在 AQS 中有一个 state 字段用于表示同步状态，使用了 volatile 关键字修饰，实现类可以通过 CAS 方式来更新同步状态。 资源共享模式AQS 有两种资源共享模式： 独占（Exclusive）：即同一时间内只有一个线程能够获取共享资源。常见的实现如 ReentrantLock。 共享（Share）：即一个共享资源可被多个线程同时使用。常见的实现如 CountDownLatch。 AQS 为这两种资源共享模式提供了两组不同的方法，如独占式的 acquire、release，共享式的 acquireShared、releaseShared。按场景重写不同模式的方法即可实现不同的资源共享模式。当然也可以同时使用，比如 ReentrantReadWriteLock 就实现了独占和共享两种模式。 阻塞与唤醒当有线程获取到共享资源了，其他线程获取时需要阻塞，当线程释放共享资源后，AQS 会负责唤醒在排队的线程。 AQS 通过 LockSupport 是用来创建锁和其他同步类的线程阻塞工具类，可以让线程在任意位置阻塞。每个使用 LockSupport 的线程都会与一个许可关联，如果该许可可用，则调用 park() 方法将会立即返回（加锁），否则会阻塞。如果许可尚不可用，则可以调用 unpark 使其可用（释放锁）。类似于 Object 类的 wait 和 notify。 结语ReentrantLock 相关的东西就暂时不再这篇文章写了，打算放到下一篇。"},{"title":"浅谈并发：ThreadLocal","date":"2021-02-12T10:09:04.000Z","url":"/talking-about-concurrency-threadlocal.html","tags":["Java","并发","浅谈"],"categories":["折腾记录"],"content":"前言日常水文章.jpg ThreadLocalThreadLocal 是关于创建线程局部变量的类，类似于沙箱，当前线程存储的变量只能被当前线程访问，不同线程间的变量是隔离开的。 ThreadLocal 其实只是一个委托类，实际存储的数据是存在线程中的 ThreadLocalMap 里，由于线程是互相隔离的，所以 Thread 里的数据也就原生隔离了。所以获取 ThreadLocal 的值其实经过了以下几个步骤： 首先获取当前线程。 利用当前线程作为句柄获取一个来自该实例中的 ThreadLocalMap 的对象。 如果上述 ThreadLocalMap 对象不为空，则从 ThreadLocalMap 中取得以当前 ThreadLocal 对象为 key 的值。 如果ThreadLocalMap 对象为空，或者取得的值为 null，则通过 initialValue 方法取得初始值，将初始值设置到 ThreadLocalMap 或者创建这个 ThreadLocalMap 对象并设置值。 源码如下： getMap 方法其实就是获取了 t.threadLocals 这个属性，所以 ThreadLocal 里的值被对应的线程持有，存放于堆中。（当然这并不是绝对的，因为还有栈上分配、标量替换等优化）。 InheritableThreadLocal除了 ThreadLocal 外，Java 中还提供了一个 InheritableThreadLocal。 InheritableThreadLocal 是 ThreadLocal 的扩展版本，当父线程创建子线程的时候，父线程的 ThreadLocalMap 就会被复制到子线程中。这样就能做到线程间传递变量。 不过需要注意的是，发生传递的情况只有在子线程是父线程创建的，然而我们一般不会直接创建线程，而是通过线程池的方式来使用，这也导致了无法形成层级关系，此时父子线程间的上下文传递就没有用了。当然这也有解决方案，比较流行的如阿里的 TTL。 ThreadLocalMapThreadLocalMap 虽有 Map 的后缀但是它并不继承自 Map 接口，所以内部的方法并没有同 Map 一样有非常多的方法。同时实现也不同于 HashMap，内部并没有使用 数组+链表（红黑树）的方式进行存储，而是只简单的 数组 来存储的。对于 hash 冲突的解决方式是采用开放寻址法。 ThreadLocalMap 的 key 是弱引用，value 是强引用的存储结构。 内存泄漏原因首先说明一点，ThreadLocal 本身设计并不存在内存泄漏的问题，之所以会发生内存泄漏，实际上是因为错误的使用导致的。 由于 ThreadLocalMap 中的 key 是弱引用的，当 key 被 GC 清理后，ThreadLocalMap 中就只剩下了 value，而这个 value 是强引用的，会一直在线程中存在，此时即使 ThreadLocalMap 的使用者不再引用这些对象，这些对象也无法被垃圾回收，因为还有一条引用链引用这这个 value： 如果没有调用 remove 方法清除不再需要使用的值，那么这个值就会一直存在直到 Thread 对象被销毁。然而我们一般情况下都是使用线程池，所以线程的生命周期非常长，不 remove 最终可能会导致 OOM。 解决方案对于过期的值清除有以下三种方式： 显示清除：这是推荐的方式，通过调用 remove 方法就可以将下面那条引用断开，这样 value 就不再拥有强引用了，GC 也就能回收这个对象了。 隐式清除：隐式清除分为两个步骤： 清除 key：由于 Key 是弱引用的，其指向的 ThreadLocal 实例可被 GC 回收，回收后从 k-v 变成 null-v。 清除 value：当我们调用 get、set 等方法的时候，会自动寻找 key 为 null 的元素并删除（expungeStaleEntry）。 自动清除：由于 ThreadLocalMap 是随着 Thread 存在的，当 Thread 被回收的时候，ThreadLocalMap 就会被一起回收。这在使用线程池的情况下基本无法使用。 为了避免发生保持在 null-v 这种内存泄漏的情况，我们可以使用显示清除这种较为简单也是最推荐的方式。 或者也可以将 ThreadLocal 设置为 static 这种情况，这样就保证了 key 不会被 GC 自动回收，当我们再次使用的时候就会覆盖之前的值，之前的值也就不存在强引用了。但是这种方式同样也要注意一点，由于我们一般会使用线程池来执行任务，那么 ThreadLocalMap 也会被保留下来，其中的值不会被清除，当我们再次使用 ThreadLocal 的时候，如果未先 remove 掉旧值那么就有可能造成值残留的问题。 结语总算写完文章了，差不多写了快 2 小时吧，虽然不是什么复杂的知识，但是耗时确实挺多的。 另外吐槽下这个坑爹的 WordPress，越更新越难用，现在这个 Gutenberg 编辑器越来越卡，打算换平台了，但是又不舍得这个主题（换平台移植主题太花时间了，今年估计是没法）。"},{"title":"浅谈并发：三大特性","date":"2021-02-09T15:03:19.000Z","url":"/talking-about-concurrency-three-characteristics.html","tags":["Java","并发","浅谈"],"categories":["折腾记录"],"content":"前言好久没写并发相关的文章了，之所以一直没写是因为我也是半桶水水平，一直写不出来，最近使用了 Obsidian 来记笔记（之前一直没笔记习惯，学了就忘了，所以打算用一款好的软件尝试下），积累了一些笔记，便打算通过写文章加深下，顺便看看这种 卡片式笔记法 对整理思路的是否有帮助。 可见性可见性 指的是一个主内存的线程如果进行了修改，可以及时被其他线程观察到。 可见性问题产生的原因缓存导致了可见性问题，在 Java 中所有变量都储存在主内存中，- 每个线程都有自己独立的工作内存（缓存、寄存器等），里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝），线程对共享变量所有的操作都必须在自己的工作内存中进行，不能直接从主内存中读写，不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行。 样例 问题产生以上代码在运行前，各线程会先将 stop 值复制到自己的工作内存中，当线程 1 进入 loop 的循环的时候该线程会一直从自己的工作内存读取值，并不会再从主内存读取值。这样就造成了一个问题，如果 stop 方法不是线程 1 调用的，那么线程 1 读取到的值则会一直为 false 造成死循环的发生。 解决方案 volatile synchronized 对于可见性问题，我们可以为 stop 变量加上 volatile 关键字，这样线程 1 每次都会到主内存读取 stop 值，其他线程更新时也会立即更新到主内存，这样就可以及时停止死循环。 volatile 通过加入内存屏障和禁止重排序优化来实现。对 volatile 变量写操作时，会在写操作后加入一条 store 屏障指令，将本地内存中的共享变量值刷新到主内存。对 volatile 变量读操作时，会在读操作前加入一条 load 屏障指令，从主内存中读取共享变量。 除了 volatile 关键字，我们还可以使用 synchronized 加锁。这是因为线程解锁前，必须把共享变量的最新值刷新到主内存。线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取最新的值。 完整样例：可见性 &amp; 原子性问题及解决 有序性有序性指的是程序按照代码的先后顺序执行。 有序性问题产生的原因指令重排导致了有序性问题，Java 内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 样例 问题产生未进行指令重排的情况下，instance = new Singleton() 的执行顺序如下： 分配一块内存 M 在内存 M 上初始化 Singleton 对象 然后 M 的地址赋值给 instance 变量 然而编译器有可能进行以下的指令重排，重排后的顺序如下： 分配一块内存 M 将 M 的地址赋值给 instance 变量 然后在内存 M 上初始化 Singleton 对象 当指令重排后，线程 1 instance = new Singleton() 执行完 2 步骤后，此时进行线程切换，线程 2 getInstance() 当走到 if (instance == null) 的时候，由于 instance 变量已经被赋值了，那么就获取成功，返回，但是此时 Singleton 对象并未初始化，如果这时候使用该对象，那么就会导致抛出 NPE 异常。 解决方案 volatile synchronized 将 instance 变量加上 volatile 关键字禁用指令重排即可。 原子性原子性指提供互斥访问，同一时刻只能有一个线程对数据进行操作。简单来说就是序列化的执行。 问题原因线程切换导致原子性问题，Java 并发程序都是基于多线程的，操作系统为了充分利用 CPU 的资源，将 CPU 分成若干个时间片，在多线程环境下，线程会被操作系统调度进行任务切换。 样例 问题产生以上的代码除了 1 是原子操作，其他均不是原子操作。 其实语句 2 在执行的时候，包含三个指令操作： 将 count 的值加载到 CPU 的寄存器 进行 +1 操作 将计算结果写入到 count 内存中 对于上面的三条指令来说，如果线程 1 在 1 执行完后做线程切换，线程 1 和线程 2 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。 解决方案 Atomic CAS synchronized Lock 对原子性不安全的地方进行加锁操作、使用原子操作类、CAS 等方法即可解决原子性的问题。如样例的代码经过如下改动即可实现线程安全： 当然对于这种累加的操作我们最好还是使用对应的原子类，如 int 对应 AtomicInteger。 完整样例：可见性 &amp; 原子性问题及解决 结语到此这篇文章就结束了，虽说我们了解了这些问题产生的原因和解决方案，但是在实际的编码过程中，并发问题往往都很隐蔽，不容易发现和修正。除了隐蔽外，并发编程也存在着心智负担，我们通常很难决定是要使用那种同步方式来防止线程不安全的情况发生，比如我在写框架的时候就经常遇到是要暴力加锁还是用 CAS 或者并发容器，是要弱一致性还是要强一致性。 如果您发现了文章的错误欢迎留言纠正。"},{"title":"浅谈组合注解 & 注解别名","date":"2021-01-15T08:26:56.000Z","url":"/talking-about-merged-annotation.html","tags":["框架","Java","Spring"],"categories":["折腾记录"],"content":"前言这篇文章很早就躺在了草稿里了，一直没有写 2333，最近在考试，因为都是一些相对简单的考试，同时又暂停的项目的开发，所以最近相对较闲，便打算把这个坑填一下。 什么是组合注解和注解别名？如果你看过 Spring 的注解的源码，那么这两个概念一定不会陌生。 注解别名 指的注解的属性拥有别名的功能，让多个属性值表达同一个意思，如 Spring 的 @Bean 注解： 从代码中看到 value 属性和 name 属性是相同的，设置 value 和 name 任意一个值都代表了设置了 Bean 的名称。这就是注解别名。 组合注解 简单来说就是 Spring 自行实现的将多个注解组合到一个注解上的功能。如 Spring 里的 @RestController 注解： 从代码中看到，@RestController 注解上标记了 @Controller 和 @ResponseBody 注解，这样 @RestController 就组合了 @Controller 和 @ResponseBody 的功能。 除了 组合注解 和 注解别名，Spring 还提供了类似于类继承的 注解继承 功能，比如 @RestController 的 value 属性上标记了 @AliasFor(annotation = Controller.class)，此时若设置了 @RestContoller 的 value 属性，则代表设置了 @Contoller 的 value 属性。 Spring 是如何实现的？首先我们先随便写一个 Demo： 启动调试会话，一路步入就可以看到以下的代码段： 可以看到，Spring 在创建 MergedAnnotation 前会先获取 AnnotationTypeMappings，该对象保存了 MergedAnnotation.from 传入的注解及其所有父注解（非 JDK 注解）的 AnnotationTypeMapping 信息，AnnotationTypeMapping 里保存了根注解（Spring 保存的方式是自下向上的，所以这个的根注解是 from 传入的注解），源注解（下一级注解，如 RequestMapping 的源注解是 GetMapping），别名索引数组，别名指向的方法等信息。然后获取当前传入注解的 AnnotationTypeMapping 组成 MergedAnnotation。 不过有了 MergedAnnotation 那么如何把 MergedAnnotation 变成 Java 的注解呢？如果直接返回通过反射获取的注解，那么别名和子注解的值传上来的值就无法被更改，所以为了获得 Java 的注解，Spring 会重新创建该注解的注解代理类。 如果你看过 Java 注解的源码，Java 注解其实是通过 JDK 代理实现的，通过 JDK 代理从 AnnotationInvocationHandler 里的 memberValues Map 获取注解值。Spring 就是使用类似的方式通过 MergedAnnotation.synthesize 方法调用了 SynthesizedMergedAnnotationInvocationHandler.createProxy 动态创建了 Java 注解，而 SynthesizedMergedAnnotationInvocationHandler 包装了 MergedAnnotation 和 AttributeMethods。 到此 Spring 处理组合注解的原理的关键部分就差不多讲完了，至于获取值部分就不说明了，只是简单的取到属性对应的方法，然后利用反射获取值。 实现既然知道了原理，那么就可以自行实现一个组合注解 &amp; 注解别名了。 方式在进行编码前我们要先确定我们组合注解的实现方式。Spring 的实现方式较为复杂，所以我们不采用 Spring 的实现方法，而是直接对 Java 注解里的 memberValues Map 动手，通过修改这个 Map 的值，我们就可以修改注解的属性值。不过需要注意，Java 注解是单例的，所以我们不能直接修改从反射获取的注解里的 memberValues，而是要克隆一份，另外使用 JDK 动态代理创建注解对象。 代码首先我们先准备 @AliasFor 别名注解： 为了方便实现重复注解我添加了一个 @RepeatItem 注解： 然后就是注解工具类的一些基础方法： 为了创建注解代理类，我们还需要一个 InvocationHandler 用于代理属性方法，我懒得写了就直接把 JDK 里的 AnnotationInvocationHandler 拷贝了出来（JDK 里的是私有的不方便使用），由于代码太长了，这里就不贴了，可以到 Github 上查看。 然后就是相应的代理工具方法： 然后就是最关键的合并注解值的方法了： 梳理下流程会更方便阅读： 首先我们要明确一点，注解的处理顺序是先子注解，然后父注解。 获取原始 memberValues 的 Map 创建克隆的空 memberValues 循环遍历原始 memberValues，取出每一项的值 通过属性名称从注解 Class 查找 Method，然后取得 @AliasFor 的注解 如果子注解有传上来覆盖的值，那么就使用这个值（overwriteMap 里存放） 否则看下有没有设置 @AliasFor 注解及 value 值（别名）如果设置了，则判断是否是默认值（Method 可以获取方法默认值，也就是属性默认值），如果不是默认值，那么这个值就是被设置过的，此时就不应该覆盖它。 如果设置了 @AliasFor 注解同时不是默认值，那么就获取别名的值（注意这个别名的值也有可能是子注解传上来的，所以需要判断下 overwriteMap 里有没有设置） 最后将获得的最终的值存入克隆的 memberValues 中 然后处理要传到父注解的值，如果设置了 @AliasFor 的 annotation 值，那么就将这个值设置到对应的 overwriteMap 里，这样父注解在处理的时候就可以获取到这个值了 有了处理注解值的方法，那么就可以写遍历注解的方法了： 照样写个流程吧： 因为传入的是可被标注的元素，所以就取出这个元素所标注的所有注解，遍历 如果是 JDK 注解就直接跳过，因为这些注解对我们的程序无用，而且会导致无限递归 接着就是使用 AnnotatedElement 的 getAnnotationsByType 方法获取标注在元素上的所有指定注解类型的值。之所以要这么做是因为 Java 支持重复注解，通过 getAnnotations 的方法只能取得一个同类型的注解 取得注解后就调用 mergeAnnotationValue 方法合并注解值，同时把要传到父注解的值存入 overwriteMap 中 除了 Java 标准的重复注解，我们还常用带 s 的注解包裹来做到重复注解，如 @MapperScans 和 @MapperScan 此时就需要特殊处理，这里使用的方法是在带 s 的注解里添加一个 @RepeatItem 注解，然后该注解存储单个注解的类型，这样就能把带 s 注解里的单个注解存到它对应类型的注解里。 处理完当前注解后就接着处理父注解（递归处理） 遍历完所有的注解后，就取得了可标注元素的所有注解处理过的 memberValues，此时就可以将 memberValues 转成注解了。 此时就有了标注在可标注元素上所有的注解了，有了这些就可以封装成组合注解了： 首先是 MergedAnnotation 的接口： 然后就是实现类： 到这里我们自己的组合注解就实现完成了，让我们来使用下吧： 结语组合注解简单化注解配置，用很少的注解来标注特定含义的多个元注解，同时提供了很好的扩展性，可以根据实际需要灵活的自定义注解。经过组合注解的重构后，我们就不再需要写很多注解处理器，避免了重复，同时也不易出错。"},{"title":"[青空之蓝-2020]-迷茫","date":"2020-12-31T13:00:00.000Z","url":"/my-2020-year-end-summary.html","tags":["年度总结","博客记录"],"categories":["站长杂谈"],"content":"前言转眼间又到了年底，又是写年度总结的时候。本来打算 25 号前就把年终总结写完，然而一直咕咕咕。 2020 年发生了许多的事，算是我在大学里转折的一年，写了不少文章，编了不少项目，学了不少知识。但也带来了一些问题，不知道后续该如何向何方前行。 往事上半年的事在 聊聊现状-[2020-09] 已经写的挺清楚了，这里就下下半年的吧。 下半年疫情已经缓下去了，所以学校就开学了，我也因此失去了摸鱼和自学的时间了，天天赶着上课，做着课下的作业。 下学期我们开了 JavaEE、Python、大数据、数据通信与计算机网络和一些非专业课。非专业课就不吐槽了，尽是浪费时间消费精力的课。至于 JavaEE、Python 学的都是基础，对我来说完全无用。大数据由于我不打算走这行也算没用。不出意外的这学期最有用的课只有数据通信。整个学期延续了之前的作风：上课顾着做自己的事。 这学期算是比较繁忙的一个学期。9 月跟着上一届的学长学姐们报了软考（软件设计师），所以差不多准备了半个多月，刷了 1k 多题。10 月份参加了蓝桥和海西服务创新大赛，原本以为蓝桥应该得不了奖（毕竟差不多 8 个月没刷题了）却没想到蓝桥这么水，直接一路到了国赛（决赛）二等，直接把第二课堂的专业分刷满了。后来海西服务创新大赛也得了三等奖（三等没奖金呜呜呜）。瞬间就不想去软考了 2333，不过钱都交了最后还是去了，和一个同班的以及几个学长学姐去了福州参加软考，第一次在外面过夜没怎么睡下去，考了一天，晚上 10 点才回到学校，累死了。前几天软考成绩出了，不出意外应该是过了，算是没白跑一趟 hhhh。 这学期大部分的时间都在为第二课堂学分奔波，花了半个多月做满了 50 个义工，听了 5 个讲座，还缺 5 个只能下学期想办法了。浪费了好多的时间。 不过虽然在这些事情上面花了很多时间，我还是想办法凑出了一些时间维护现有的项目以及开发新的项目。从 Github 上应该也可以看出来，这学期主要是在更新 XK-Java 框架，框架在这几个月的更新陆续更新了组合注解、新的容器、配置源、SpEL 支持、异步 定时任务、新的请求流程和处理器、更完整的路由支持、条件注解、集成测试等一系列功能，变得更 “现代” 了，从玩具变成了可用的状态。除了框架，还重写了 XK-Editor，只不过还在开发，暂未开源，编辑方式类似于 Typora，同时也提供分栏的编辑方式。 往事到这里就没啥好说的了，其他技术部分就留到技术板块了。 站点由于站点在 8 月份左右更换了 Google Analysis，所以前半年的数据都没有了，这里就不放数据了。不过按近几个月的数据来看跟去年相比也差不多。 今年一共写了 29 篇文章（去掉时间日志的），相比去年应该是多的，主要是在家学习，闲着没事就会把学到的东西总结一下发一篇。而开学了就没怎么写了，主要是太忙了，还有写项目等等。不过时间日志还是会经常更新的，只是时间日志里的更像笔记，质量不如博客文章，有一些部分也直接复制粘贴 2333。 博客在 10 月份更换到了 Docker 部署，主要是容器越来越多了，全部换成 Docker 管理起来也方便一点。 友人今年新增了 3 个友链，当然除了友链之外也认识了不少大佬。虽然有的只是点头之交，有的是无话不谈。我还是真心感谢各位一直对我的帮助。 我不太擅长线下社交，所以大三了，院里还是没几个认识的人。也不是那种会主动聚集一些人的 leader 特质，都是通过朋友们的帮助才认识了一些人。更不擅长主动打开话题，所以曾经的朋友有些已经不再联系了。但不管怎样，感谢大家对我的陪伴。 技术技术方面能谈的就多了 2333。 2020 主要折腾的是 Java 后端，在 2020 年陆陆续续的学习了 Spring，Java 并发，设计模式，Aop，IoC，线程安全，线程池等技术。不过学的都不深，大多都停留在表层。 2020 因为一时兴起，写了个框架，就一发不可收拾，虽然挺浪费时间的，不过从开发过程的收益却是庞大的。之前学 Spring 一直没法理解的 IoC、Aop 之类的东西，在开发的过程中很快就明白并掌握了。相比于阅读文章或书籍，亲自动手实现和开发能更深入的理解其中的原理，同时开发过程中也能获得成就感，为自己的作品而高兴。 之前我学任何东西都会写点笔记，后来因为一些原因就没再写笔记了。随着学到的东西越来越多，不记录很容易就把学到的技术又还回去了，于是就创建了 时间日志 来记录一些零碎的知识或技术，一些相对熟悉的技术则会整理成一篇文章写到博客里。同时也开始了为期 100 天的 #100DaysOfCode 虽然都是写玩具代码，不过总比没有好，折腾点有趣的东西。 除了 Java 后端外，前端其实也稍微学了点，比如 TypeScript，Vue3 等等，不过已经打算走后端了就没有像后端这么深入的学习了。 摸鱼除了折腾外，摸鱼还是必不可少的。博主我有强烈的 3D 眩晕所以平常都不玩 3D 游戏，基本不是看番就是音游。不过还是体验了一下塞尔达传说荒野之息（买不起 NS，只能卑微的用模拟器玩）。2020 因为新番少，所以多半都是回顾以前的旧番比如 Fate UBW 等，也看了一些动画电影，如 朝花夕誓 于离别之朝束起约定之花，心灵想要大声呼，乐园追放 等。因为要为毕业不失业做准备，所以娱乐摸鱼就变少了，呜呜呜。 项目今年开坑项目挺多的，这里就不列举了，请移步 Github 查看吧。 未来不知不觉已经到了大三，也快到了找实习的时间了，不过我校估计不让我们大三就出去实习，大三还开了一堆乱七八糟的课程，本来就没有充足的时间来准备了，又因为这些东西浪费时间。大数据，人工智能，Web，安卓，真当我们是全能的天才。大三上果不其然，效率暴降，只学了 Java 技术栈相关的东西，架构、系统、网络方面的知识统统没学 2333，只能向后推一推了，先应付下期末考。 寒假的时候打算学点这些计科的基础（别问专业为啥没教，问就是没开 or 教了等于没教），然后准备下下学期的暑假实习招聘。回顾了自己学到的技术，可以说是很少了能拿得出手的就只有那个 Java 框架了。是个末流学校垫底水平的废物，不出名，没人脉，没家底，还没钱，又天天摸鱼，到时候可能挺困难的。没办法，只能走一步看一步了。 结语不知不觉也写了 2.5k 字了，陆陆续续的写了 10 天了，修改了好几次，差不多该发布了，溜了溜了。 2021 望一切顺利，祝各位新年快乐。"},{"title":"Java 系列文章","date":"2020-12-21T11:20:05.000Z","url":"/java-series-articles.html","tags":["系列","Java"],"categories":["折腾记录"],"content":"前言Java 相关的文章由于篇幅较短，所以就写在了 Time-log 中了，目前 Java 系列已经差不多写完了，于是就在博客里整理一下。 文章 Java - Exception 和 Error Java - String、StringBuffer 和 StringBuilder Java - 原始数据类型、包装数据类型 Java - 反射、动态代理 Java - 引用 Java - 集合 Java - Map Java - 接口、抽象类 Java - IO、NIO Java - 类加载器 Java - 内存区域 Java - 垃圾回收 Java - 线程状态和 ThreadLocal Java - 阻塞队列 Java - 线程池 Java - CAS、AQS Java - synchronized &amp; volatile Java - 并发容器 Java - 并发工具 结语本系列文章原本是写在思维导图里的，所以内容相对精简，建议配合其他书籍或文章阅读。"},{"title":"HTTP 系列文章","date":"2020-12-09T12:55:50.000Z","url":"/http-series-articles.html","tags":["HTTP","系列"],"categories":["折腾记录"],"content":"前言HTTP 相关的文章由于篇幅较短，所以就写在了 Time-log 中了，目前 HTTP 系列已经差不多写完了，于是就在博客里整理一下，毕竟也没人会去看 Time-log 吧。 文章 HTTP - TCP/IP HTTP - 域名 HTTP - 握手和挥手 HTTP - 报文 HTTP - 请求方法和 URL 格式 HTTP - 响应状态码、数据类型、编码 HTTP - 数据压缩、分段传输、范围请求 HTTP - 连接管理、重定向与跳转 HTTP - Cookie、Session HTTP - 缓存控制 结语本系列文章原本是写在思维导图里的，所以内容相对精简，建议配合其他书籍或文章阅读。"},{"title":"浅谈 EatWhatYouKill","date":"2020-11-19T14:54:28.000Z","url":"/talk-about-eatwhatyoukill.html","tags":["Java","并发"],"categories":["折腾记录"],"content":"前言既然说了 Tomcat 的线程池，那么这次就说说 Jetty 的任务执行策略吧。其实是 XK-Server（类似于 Tomcat 的 Java Web 容器和 HTTP 服务器）结合了二者的一些小特性，代码一两周前就写好了，这次就来水下文章。 什么是 EatWhatYouKill？对于常规的 IO 操作，我们通常使用以下有几种处理方式： ProduceConsume：将 IO 的生产和消费统一由一个线程来完成，不断循环生产和消费的过程。很明显，这种模式有个很严重的问题，后面的 IO 事件要等待前面的 IO 事件完成，这样的效率明显很差，越后面的 IO 事件需要等待的事件就越长。 ProduceExecuteConsume：采用一个线程作为生产者，负责收集 IO 数据流，然后将数据推送至队列中，让线程池中的另一线程来处理数据。这样消费的过程就不会影响生产，但是由于使用到了不同的线程，需要额外消耗线程切换的性能，同时当使用另外一个线程的时候有很大概率是调度到 CPU 的另外一个核心，这样就无法再利用到寄存器中的热缓存，需要再次缓存这些数据。 ExecuteProduceConsume：这种模式比较特殊，该模式和 ProduceConsume 类似，都是生产消费都在一个线程里完成，这样就可以充分的利用热缓存。但与其不同的是，该模式可能会新建一个新线程以继续生产和执行任务，线程不应该生产自己不想消费的任务，而应该把生产和消费职责都转移到另一个进程中执行。虽然这个可以很好的利用热缓存，但是同时也带来一个问题：一旦 IO 的消费时间过长，就会导致大量的阻塞。 看完上面的执行模式，你应该对 IO 的生产和消费调度有了一些理解，那么 EatWhatYouKill 又是什么呢？ EatWhatYouKill 是 Jetty 对 ExecuteProduceConsume 模式的改进，在线程池空闲的时候则采用 ExecuteProduceConsume 模式。如果线程池处于繁忙的情况下就切换成 ProduceExecuteConsume 模式。这么做的原因是当线程池处于繁忙的情况下，如果还是用 EPC 模式，那么就没有空闲的线程来接受连接（生产），这样会导致连接器（Connector）拒绝新的请求。这时候 Jetty 做了一个优化，一旦发现线程池处于繁忙的状态，Jetty 就不会在轮询线程里消费任务，而是采用 PEC 模式，将消费任务放到线程池中，由线程池进行调度。这样轮询线程就有办法继续接受新连接，等到线程池不繁忙了，Jetty 就会再次切回 EPC 模式，充分利用热缓存。 实现完整的代码可以到 Github 查看。 了解了原理，那么就进入分析的阶段了，本文中的代码参考了 Jetty，对 Jetty 的 EWYK 进行简化，同时适配可扩展线程池。 首先我们需要知道，每个任务其实就是一个 Runnable，但直接调用 Runnable 的 run 方法的时候就相当于直接在本线程中执行，对应 EPC 模式。将 Runnable 放到线程池中执行则相当于在另外一个线程执行，对应 PEC 模式。 这样我们就可以定义以下两个方法，用于对应两种模式的执行方式： 既然有了执行的方式（消费），那么就需要有提供任务的方式（生产），此时我们可以定义一个接口来描述任务提供者： 这样我们就有了生产和消费了，接下来就是执行策略了。 首先先定义下状态和模式： 然后就是实际的执行方法： 结语写的挺简单的，这些代码写了有一段时间了，流程忘得差不多了，所以代码就没说明的很详细。溜了溜了😂。"},{"title":"浅谈可扩展线程池","date":"2020-11-17T12:59:18.000Z","url":"/talk-about-scalable-thread-pool.html","tags":["Java","并发"],"categories":["折腾记录"],"content":"前言最近在写类似于 Tomcat 的 Java Web 容器和 HTTP 服务器，碰到了一些有趣的东西，便打算水水文章，顺便还能加深理解 😎。 线程池线程池（Thread Pool）是一种基于池化思想管理线程的工具，通过线程池，我们可以做到线程复用，避免频繁创建和销毁线程带来的不必要的开销，同时也避免了线程过多导致操作系统调度困难的问题。 在 JDK 中有两种典型的线程池： FixedPool：固定线程数量，当线程池处理不来的时候将待处理的任务放入无限长任务队列中。 CachedPool：不限线程数量，当线程池处理不来的时候新建临时线程，闲时销毁不活动的线程，任务队列为空。 在《阿里巴巴 Java 开发手册》中有提到我们应该禁止使用这两种线程池，而应该手动 new ThreadPoolExecutor 创建线程池。这是因为当任务很多并且处理不来的时候 FixedPool 会因为任务被积压到任务队列中，撑爆内存，引起 OOM。而 CachedPool 会不断的创建线程来执行任务，这同样会导致撑爆内存，引起OOM，同时过多的线程切换也会引起严重的性能损失。 大多数情况下，我们需要的是闲时保留一定的线程（核心线程），忙时创建线程。直到达到设定的最大线程数时停止创建。来不及处理的任务放到定长的任务队列中，当任务队列满的时候触发拒绝策略。在线程池闲下来的时候销毁线程，将线程池中的线程数量回收到核心线程数。 然而，JDK 中线程池的工作模式并不是这样的，JDK 中线程池闲时的时候保留一定线程，当核心线程处理不来的时候将任务放到任务队列中，任务队列满的时候才会创建临时线程，此时如果还是处理不来，则触发拒绝策略。这种工作模式也导致了在队列较长的情况下，线程池没有机会创建新的线程，限制了线程池的吞吐性能。 可扩展线程池为了解决以上的问题，Tomcat 中对 JDK 中的线程池进行了扩展，通过自定义任务队列和增加任务计数器来达到在忙时优先创建临时线程处理任务的作用。 思路在线程池中增加一个 submittedTaskCount 的任务计数器，记录实际提交到线程池中任务的个数，同时自定义 TaskQueue 任务队列，重写 offer 方法。 当submittedTaskCount 的值小于当前线程池中启动的线程数量时，则将任务直接插入到任务队列中（相当于直接执行该任务）。 若大于或等于，则检查当前线程池是否已经到达了最大线程数，如果还未到最大线程数，则返回 false，制造任务队列已满的假象。 此时将任务重新插入线程池，线程池就会创建新的线程来执行任务。 若已经达到最大线程数，则将任务放入任务队列，等待执行。 若任务队列已经满了，重新插入任务队列的时候依旧会失败，此时就触发拒绝策略。 实现具体代码请到 Github 查看 过程注释里都写了，这里就不多介绍了。另外，文中的代码并不是完整的，主要是不想文章又臭又长，一堆代码，所以不要直接复制粘贴就运行哦。 结语最近总算闲下来了，所以最近偶尔会更新下文章，因为现在在写类似 Tomcat 的服务器，所以最近的文章应该都会是偏向这方面的，不废话了，溜了溜了 😂。"},{"title":"聊聊写框架","date":"2020-11-10T13:17:05.000Z","url":"/talk-about-writing-framework.html","tags":["框架","Java","杂谈"],"categories":["站长杂谈"],"content":"前言不知不觉应该已经折腾了 8 个月的框架了，感觉已经无法在从写框架中获取有趣的知识了。于是就打算写一篇文章，算是对经验的总结。后续可能会开一个从零实现 Java 框架的文章 🤣，使劲挖坑不填坑。 学的越多，了解的越深入，就越感觉自己懂的部分原来是那么小。 初心说起当初写框架的原因其实挺简单的，无非是想写一个轻量的博客系统代替现在使用的 WordPress，然后因为不想只停留在业务层，于是打算自己写个框架，然后在这个框架上写个博客系统，来以此达到学习和熟悉对应语言的目的。后来框架写着写着就逐渐忘掉了博客系统 🤣。 吐槽框架，那是最有用的技术，那是最没用的技术。曾经我也因会使用某个框架为荣，因此迷失了学习的目的，同时也浪费了大量的时间。 框架，是构建在底层上的抽象层，不同的框架有不同的抽象逻辑。一旦学习过的框架凉了，那么在框架上花的时间就浪费了。当然我并不是吐槽不能学习框架，而是不应局限于学习框架的应用。当然也不能因为要学习框架的运作原理而去啃源码。通过文档去理解抽象模型才是更好的做法，也就是学习框架使用的思想等“软”技术。正如 Stop Learning Frameworks 这篇文章所说： 编程语言是不同的，但是设计是类似的。 框架是不同的，但是设计模式是类似的。 开发者是不同的，但是如何和这些人打交道是不变的。 设计 注：以下的内容均基于 XK-Java，XK-PHP 已暂时不管了 2333。 罗马不是一天建成的，写框架也一样，我们不可能一上手就设计出相对完整的框架系统，所以我们应从小的模块开始实现，如 IoC 容器，路由等，然后扩展其他模块。XK-Java 也是不断经过重构、改进才有了现在相对完善的框架。 XK-Java 早期采用的是采用写死流程的方式来启动，通过一个个 Provider 来对内置的服务进行注册和实例化，这样极其不方便，而且对扩展并不友好。并且随着注解数量的增加，为每个注解都写一个注解处理器并不是优雅的解决方案。于是参考了 Spring 的方式，通过实现组合注解，来完成注解的复用。于是你便可以看到现在 XK-Java 的注解已经累积到了 80 个，而我并不需要为这 80 个注解都编写注解处理器（逃。同时也因为组合注解，后续组件和服务解耦变得容易实现。具体前往 README 这里就不详细说明了，不然文章就会变得又臭又长。 XK-Java 当前的框架启动流程吧，请求流程就留到后续系列文章吧： 结语写这篇文章写了一个月，因为 10 月和 11 月的一堆事情，所以没写完。今天闲的慌总算写完了，写的乱糟糟的 2333。"},{"title":"聊聊现状-[2020-09]","date":"2020-09-20T13:00:19.000Z","url":"/talk-about-the-status-quo-2020-09.html","tags":["杂谈","现状"],"categories":["站长杂谈"],"content":"前言写这篇杂谈的动机是 ⑨BIE 写的 近况。去年了差不多这个时候也写了一篇 一年来的经验总结 于是也打算今年也写一篇，算是对大二的一次小整理吧。 往事不知不觉又在大学混了一年，现在已经是一个大三狗了，随着不断的到处划水，视野开阔了，不过同时也深感自己的垃圾以及无力。 大二上因为开了数据结构与算法的课，以及对前端的兴趣，所以整个大二上主要都在研究数据结构与算法和前端，相关的往事基本上都在 2019 的年度总结 里写了，这里就不再讲了。除了写项目，整个大二上基本也没学到太多的东西，从我写的文章估计也看出来了，大二上算是划着水混过去的。 大二下因为疫情，整个学期都是在家里过的，除了大物实验课没法上延到了这学期上，其他课都是网络教学。也正是因为网络教学，给了我在学校中无法比拟的自学时间。上课了 =&gt; 进入会议 =&gt; 静音 => 切后台，然后我就有了自学的时间，所以大二下算是一个转折点，在大二下我折腾了很多的东西，虽然也并不是什么高级的东西。 因为打算不用框架写博客，但又想方便的写代码，于是自学了框架的运行原理等等的知识。耗时 1 个月写了一个 XK-PHP，原本打算写的是一个可扩展的博客系统，后来随着框架的不断完善就断了写博客系统的想法，转而不断优化和增加框架的功能。虽然框架写得并不好，而且有很多问题，不过在这之中学到的知识却是庞大的。像什么 IoC、Aop、Proxy、Annotation、Middleware、Route、生成器等等都是在那时候学会的，而这学会也不止局限于原理，而是实现。 同时也学习了设计模式，原本打算是学设计模式，然后将设计模式应用到框架中的，实际在写代码的时候都是怎么方便怎么优雅就怎么写，完全不会去关心是否应该在这里使用某个设计模式。 磨磨蹭蹭到了 5 月，因为 PHP 的一些局限性，比如没有多线程，原生注解，类代理等等，以及喜欢折腾的精神，于是就打算将 XK-PHP 框架移植到 Java 平台上。于是 XK-Java 就这样写出来了，在 PHP 框架的逻辑上结合 Java 的特性与优势。在初期写的过程中，我并没有考虑到线程安全的问题被狠狠的坑了一把，也正是这些问题，我因此学习了在 PHP 里学不到的知识（线程，并发等）。同时也到 Spring 里学了一些知识，比如注解处理器，DispatchServlet 等等，虽然只是非常不完善的简化版实现，不过也算是学到了原理。其他的信息可以去看 XK-Java 的 README，这里就不再写了，不然就又是上万字的废文了（溜。 吐槽总之大二下对我来说算是一个非常重要的转折点，同时也把学习的方向切到了后端，虽然现在还在肝前端的代码，不过主要学习的东西已经是后端的了。另外也深刻的感受到了下图的回答是多么的精辟： 很多知识课上不会讲，老师也不一定比学生会，班上的大佬的知识底蕴说不定比讲台上的老师还深厚（特指我们这种 2.5 本学校）。上课对我们这些自学的学生来说就是绊脚石。不止在上课的时候耽误，下课的时候也能烦死人（作业，活动什么的），还要应付考试。 开学了，课时排满，眼睛还出了一些问题，感觉这学期是学不到什么东西了，哎，正如我在 推特 发的 “有点羡慕一些学校可以大三去实习。现在在学校里上课，课时还满上，然后课程质量普遍不好（2.5 本的课程质量也就那样了）学不到什么知识，又影响自学的效率。看来咸鱼还是翻不了身啊（指我）。”。另外这学期还要为了那 sb 的第二课堂学分奔波，参加比赛，考证，做义工等等。更没有时间了，所以对我学习帮助不大的项目会一直停更下去了，比如 Origami 主题、XK-Blog 等等，我先在这里给等更新的 Origami 的用户们说声 “抱歉” 吧，这些项目最近是不会更新了。 未来大三上打算深入的研究下 Java 技术栈和一些架构、系统、网络方面的知识。不过因为很多杂七杂八的事估计会影响效率，所以也不一定能学完，哭哭。 同时也打算重写下 XK-Editor 和 XK-Note，另外把 XK-Java 改进下。项目的部分暂时就这些吧。。。 另外也要准备以后的实习了，毕竟笨鸟还是要先飞，不然等到时候肯定是被高校的大佬们吊打的。 结语越学越感觉自己和大佬们的差距，希望能加油吧，总之就这样了。"},{"title":"浅谈并发：锁","date":"2020-08-26T12:44:00.000Z","url":"/talking-about-concurrent-locks.html","tags":["Java","并发","浅谈"],"categories":["折腾记录"],"content":"前言接着写浅谈系列。 这次要聊的是锁，锁在并发编程中扮演着非常重要的角色，Java 中提供了多种类型的锁，不同类型的锁在不同的场景中都有不同的性能表现。 锁的类别锁可以按照特性进行分类，分类后我们就可以较为直观的区分不同的锁和区别不同锁的不同特性。 锁的对比分类了锁后，我们就可以对其进行对比分析了。 悲观锁 &amp; 乐观锁对于一个数据的并发操作，悲观锁总是认为自己在使用数据的时候别的线程会来修改数据，所以为了防止被修改，在获取数据的时候会对该数据进行加锁操作，确保只有取得锁的线程能对此数据进行操作。 与之相反，乐观锁总是认为自己在使用数据的时候别的线程不会来修改数据，所以也就不需要加锁，通常是使用 CAS 操作，在更新的时候通过比较判断数据是否被修改，如果没有被修改，则更新成功，如果被修改则进行报错或重试。 悲观锁更适合写多读少的场景，读取操作并不会改变数据，所以如果用在读取多的场景下则会造成严重的性能浪费。 乐观锁则更适合写少读多的场景，由于乐观锁一般是采用 CAS（比较并替换）的实现方式，每次写入操作的时候都要复制一份原始数据，而这操作是非常耗能的，用在写入少的场景下就不如使用悲观锁了。而读取的时候并不会加锁，这也就意味着可以并行的读取，所以在读取的方面上有非常好的性能。 非自旋锁 &amp; 自旋锁自旋指的是在获取数据失败后是采用进行循环重试而不是休眠线程等待锁的释放。 通常情况下，锁住某个资源的时间都是很短的，如果为了这点时间挂起线程恢复线程，则有可能得不偿失。在这种场景下，我们可以进行循环尝试，一旦锁释放了，那么就可以立即对数据进行操作，而不需要再等待线程的唤醒。 不过自旋也是有缺点的，由于是循环尝试，所以虽然避免了线程的切换，但需要占用处理器时间，所以一般都是进行一定范围的尝试，超出了范围后切换成阻塞。 公平锁 &amp; 非公平锁公平锁是指线程获取锁的先后顺序是按照申请锁时的先后顺序排序的。 非公平锁下的线程会先尝试一下获取锁，如果刚好锁被释放了，那么这个线程就可以直接获取锁，而无需进行排队。当第一次获取的时候无法获取到的时候才会进入排队的状态。 公平锁下不会出现线程饿死（无限等待）的情况，但是缺点也很明显，每个线程都需要阻塞等待，而阻塞和唤醒的开销并不小。 非公平锁由于可以插队，如果刚好可以获取到锁的话就不需要阻塞和唤醒了，减少了部分的开销，整体的并发性能较好。但是由于可以插队，那么就有可能会出现部分线程长时间处于等待的状态，或者是饿死的情况。 可重入锁 &amp; 不可重入锁可重入锁和不可重入锁的区别在于一个线程是否可以再次获取该锁。不可重入锁容易发生死锁的问题。 Java 中的 ReentrantLock 和 synchronized 都是可重入锁，NonReentrantLock 是不可重入锁。 共享锁 &amp; 排他锁故名思意，共享锁就是当一个线程获取该锁的时候，另外一个线程也可以获取这个锁。 排他锁则相反，当一个线程获取该锁的时候，另外一个线程不可获取该锁。 共享锁一般用于读取操作，而排他锁一般用于写入操作。在 Java 中 ReentrantReadWriteLock 就是读写分离的锁，里面有 ReadLock 和 WriteLock 两把锁。读锁采用的是共享锁，再并发的时候可保证高效的并发，写锁采用排他锁，确保写操作的互斥。 无锁 &amp; 偏向锁 &amp; 轻量级锁 &amp; 重量级锁这四个锁指的是锁的状态，是 synchronized 的 4 种锁状态。 无锁就是对数据进行锁定操作，所有的线程都可以修改数据，一般是使用 CAS 等操作来保证线程安全。无锁由于不需要对线程进行休眠和唤醒，在一些场景下的性能是很好的。 偏向锁指的是一段代码一直被某个线程获取，那么这个线程就会自动获取锁。当再次操作的时候就看看偏向锁是否指向该线程，如果是，则不需要加锁操作了。 轻量级锁可以认为就是自旋锁，当锁处于轻量级锁的状态时，线程尝试获取锁失败的时候不会进入阻塞状态，而是会循环尝试。 重量级锁就是非自旋锁，当获取锁失败的时候，线程会进入阻塞的状态。 从无锁到重量级锁，其对应的额外消耗是逐渐递增的。 锁的升级 &amp; 降级所谓的升级和降级其实是 JVM 对 synchronized 的优化策略，在合适的场景使用合适的锁，而不是直接使用重量级锁。 无锁 &lt;=> 偏向锁当线程访问同步数据的时候就会将锁升级成偏向锁。 当 JVM 处于全局安全点（在这个时间点上没有正在执行的字节码）的时候会将偏向锁撤销，恢复成无锁的状态。 偏向锁 => 轻量级锁当锁处于偏向锁的情况下，没有持有偏向锁的线程尝试获取锁时，偏向锁就会被撤销，同时锁升级成轻量级锁。 轻量级锁无法降级。 轻量级锁 => 重量级锁当自旋超过一定指定的范围，或者是一个线程持有锁，一个线程在自旋，这时又有第三个线程尝试获取锁时，锁就会升级成重量级锁。 重量级锁无法降级。 结语又是一篇水文 ?，本文主要是简单概述下锁的一些类别和升降级流程，所以有很多细节的地方并未说明，比如 Java 的对象头，所以，如果要更加深入的了解的话还是要另外阅读一些高质量的文章或书籍。文章不写这些主要是我不太精通，写出来的效果不好 ?。"},{"title":"浅谈并发：基础","date":"2020-08-16T13:17:00.000Z","url":"/talking-about-concurrency-basics.html","tags":["Java","并发","浅谈"],"categories":["折腾记录"],"content":"前言并发编程是 Java 中重要的一部分，一直以来我对这方面的知识都只是理解，而且没有系统性，所以便打算借助写文章来整理和强化一下，所以最近浅谈系列的文章不出意外应该都是 Java 并发编程的方面了 ?。PHP 框架系列也咕了好久，看看后续有没有时间写吧 2333。 什么是并发？并发是一种能并行运行多个程序或并行运行一个程序中多个部分的能力。通过充分利用多线程的特性，改善程序的性能。 优点 &amp; 缺点优点： 并发编程可以充分利用 CPU 资源，在多核心的情况下并行的运行程序，通常情况下并发程序花费的时间会比单线程程序更少。 利用并发编程我们可以很好的对业务进行拆分，并将其分配到不同的线程上。 在涉及 IO 操作的情况下并发通常会比同步有更好的性能。 缺点： 上手难度较高。 由于采用了多线程，所以存在着线程安全的问题。 在非高并发的场景下，频繁的上下文切换通常会使程序运行缓慢，甚至不如单线程。 一些需要知道的概念进程 &amp; 线程 &amp; 协程进程即 Process，当我们开启了一个程序，那么这一个程序就可以被称为一个进程（当然有的应用可能会有多个进程，这个就不另外说明了）。进程间的数据无法直接访问。是操作系统分配资源的最小单位。 线程即 Thread，线程是在进程之中分配的多个运行态，如果把进程比喻成火车，那么线程就是火车里面的一个个车厢。线程有各自的调用栈，同时也可以互相访问各自共享的数据。是 CPU 调度的最小单位。 协程即 Coroutine，一般也称为微线程或纤程，它的行为和线程类似，不过线程的上下文切换是通过内核态进行切换的，而协程是通过程序的调度器来进行上下文切换。不需要内核态的参与使得其拥有很好的上下文切换性能。当然一般情况下协程不会只在一个线程中跑，而是会配合多线程，然后在每个线程中开辟一些协程，非必要的情况下只需要进行用户态的切换。 同步 &amp; 异步同步指的是程序发出一个调用的时候，在未取得返回值的时候就不返回。即主动等待返回值。 异步指的是程序发出一个调用的时候，在未取得返回值的时候调用者不会得到真实的返回值，而是返回一个承诺或空值，通过回调的方式（即结果得到的时候调用传入的方法）来执行下一个任务。即被动调用。 阻塞 &amp; 非阻塞阻塞指的是当程序运行到一段耗时的代码时，程序会卡死在那，直到执行完毕。比如读取文件的时候，当文件的内容未读取完毕的时候，程序只能一直处于等待的状态，直到读取完毕，才能执行下一段代码，这一等待的过程称之为阻塞。 非阻塞即和阻塞相反，当程序执行到耗时的时候程序不会等待执行完毕，而是会通过回调或再检查的方式取得返回值。 注意：同步/异步 与 阻塞/非阻塞 二者并不是绑定的关系，可以有同步阻塞、异步非阻塞也可以有同步非阻塞、异步阻塞。 线程通信机制由于线程间是可以进行通信的，这就衍生出了一个问题：线程间的通信机制。通常线程间的通信是通过内存共享或者消息传递。 内存共享是通过线程间读写公共的内存来达到隐式线程间通信的机制。而消息传递时通过发送消息来达到显示线程间通信。 Java 采用的是共享内存的方式来做到线程通信。 Java 内存模型（JMM）Java 线程间通信是通过 JMM 进行控制，JMM 决定了线程间共享的变量的写入何时对另一个线程可见。 结构要了解 JMM 之前肯定是需要先看看 JMM 是什么结构的，这样也方便后续的理解。直接上图.jpg 注意：本地内存不是真实存在的，这是一个抽象概念，包含了缓存，寄存器等。 过程图中已经画好了，当第一个线程更改某个共享变量的时候，会先更新本地内存，然后写入到主内存，第二个线程从主内存中读取更改过的变量然后使用。 这种模式下也衍生出了一种可见性的问题，具体会在后续文章中说明。 重排序重排序指的是代码的顺序和实际执行的顺序不同，之所以存在重排序是为了提高程序的性能而做的优化。 要重排序也是存在条件的，在单线程下，重排序不能改变程序运行的结果，存在数据依赖关系的时候也不允许重排序。 重排序在多线程环境下可能会导致数据不安全。 happens-beforehappens-before (先行发生于) 是 JMM 中最核心的理论，保证了内存的可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在 happens-before 关系，并不意味着一定要按照 happens-before 原则制定的顺序来执行。如果重排序之后的执行结果与按照 happens-before 关系来执行的结果一致，那么这种重排序并不非法。 as-if-serialas-if-serial 指的是所有的操作无论如何被重排序，程序的执行结果都应该和代码顺序执行的结果一致。也就是说结果不能被改变。 结语总算是肝完这篇文章，连续写了两天，真的是啥都不懂 ?。写这篇文章部分是参考了一些网络文章写出来的，所以可能有很多雷同的地方，也可能会有很多错误的地方，如果您发现了文章的错误欢迎留言纠正。?"},{"title":"浅谈缓存","date":"2020-08-13T06:21:25.000Z","url":"/talking-about-cache.html","tags":["浅谈","缓存"],"categories":["折腾记录"],"content":"前言原本是打算写并发相关的文章的，但是目前知识储备还不足，所以就先咕咕了。缓存相对简单点，就先水一篇了 ?。 什么是缓存？作用？缓存（Cache）是用于数据交互的缓冲层，用于提高常用数据的读取速度，缓存非常常见，如 CPU 中的 L1 L2 L3 缓存，浏览器的静态资源缓存等。本篇主要围绕着后端缓存，硬件缓存之类的就不涉及了（我也不懂.jpg）。 缓存一般是用于在读多写少的场景下加快数据的获取，起加速作用。不过缓存其实还有另外的作用，如在高并发的场景下起到保护后端薄弱部分（数据库等）的作用。 一些常见的缓存算法 &amp; 策略基于访问时间 LRU (最近最少使用)：通过一个缓存队列，按每项的最后被访问时间排序。当缓存满了的时候删除队尾，即最后一次被访问时间距现在最久的项。当某个项被使用的时候，则将该项移至队首。 基于访问频率 LFU (最近最少使用)：通过一个缓存队列，按每个缓存块的被访问频率将缓存中的各块排序，当缓存满了替换掉缓存队列中访问频率最低的一项。 LRU-K：是一种 LRU 算法的增强版，LRU 队列的基础上，再添加一个队列维护数据访问的次数，由原来访问 1 次会被添加到缓存中，改为访问 K 次才会被加入到缓存中。 基于访问时间与频率 ARC：兼顾访问时间与频率，使得在数据访问模式变化时缓存策略仍有较好性能。 基于访问模式有些应用有特性的数据访问特点，可以通过制定一个与之匹配的模式来实现高效缓存。 一些名词 &amp; 解释缓存穿透是什么？一般情况下，我们从 API 或数据库等高耗时操作取得数据后才会对值进行缓存，如果没有获取值就不进行缓存，而这时候如果我没读取一条不存在的数据，那么该请求每次都会绕过缓存而打到缓存后的数据库或 API，这个过程就被称为缓存穿透，如下： 带来的问题当系统并发量大并且空值的查询多的时候，大部分请求会打到缓存后的薄弱部分，通常会导致数据库或 API 承受不住而导致不稳定或崩溃。 黑客可以通过这一漏洞对系统进行攻击，造成重大损失。 解决方案这一问题是不缓存空值导致的，那么我们对空值进行缓存即可解决。这种方案有一定局限性，当产生空值的范围很大的时候，这一方案就不太适用了，此时黑客可以利用不断变化查询的 key 达到爆缓存的效果。 还有一种方案是采用布隆过滤器，利用布隆过滤器来判断值是否存在，当从布隆过滤器中得知有值的时候才进入缓存和数据库，否则则直接返回不存在。通常利用这种方法来解决上述爆缓存的问题，但是布隆过滤器有误判几率，所以要依系统的特性选择合适的方案。 缓存击穿是什么？缓存击穿指的是当大量请求正好请求某一个 key 的数据的时候，而这个 key 又刚好失效的时候，这些大量请求会打到数据库或 API 上，这过程就称为缓存击穿。 带来的问题会造成某个时刻数据库或 API 的压力剧增，甚至崩溃的情况发生。 解决方案如果该数据是因为时间过期导致失效，那么就应使用访问频率方式缓存。 如果该数据是因为更新而导致失效，那么可以通过加读锁使请求等待缓存更新完毕。或者使用 CAS 操作，当值更新完毕的时候就替换掉旧的缓存。 缓存雪崩是什么？与缓存击穿类似，都是由于缓存失效导致的问题，不过雪崩指的就是大量的缓存失效。常见的有缓存服务器挂掉，缓存过期时间设置不当（同一时间过期）。 带来的问题在高并发的情况下，一旦出现缓存雪崩，有极大的可能会导致缓存后的服务直接崩溃。 解决方案采用集群缓存的方式，当某一条缓存服务器失效的时候还有其他缓存服务器可以顶替。 当缓存服务器失效后就对服务进行降级和限流，通过降低体验来防止后端服务挂掉导致完全不可用的状况发生。 避免设置相同的过期时间，应使缓存的数据错峰失效。 结语本篇文章主要是对缓存进行介绍，其实就是一些名词解释 ?，后续可能会写一些关于 Redis 和其他缓存系统的介绍和使用，不过应该要等我肝完并发系列的文章和 PHP 框架的文章才会写吧。"},{"title":"无须定义类，Spring 快速注入 Json 参数","date":"2020-08-04T15:27:02.000Z","url":"/spring-quickly-inject-json-parameters.html","tags":["Spring"],"categories":["折腾记录"],"content":"前言不知各位在开发的时候有没有遇到这种情况，当前后端分离的时候，前端时常会把很简单的参数使用 JSON 格式传入，当 Spring 要获取这些参数的时候每次都需要定义一个类，在使用的时候也需要使用对象的 Getter 方法，这样极其不方便。而如果要改前端使用 FormData 的方式传输，那么又会遇到另外一个问题：前端常用的请求库是 axios，而 axios 传输的数据默认是采用 JSON 格式传输的，如果需要使用 FromData 的方式传输，那么需要再每个请求方法上增加 FormData 的 Content-Type，或者添加到默认的配置中。 那么有什么办法可以在 Spring 中使 JSON 可以像 FormData 那样方便的注入呢？ 思路在 Spring 入参 Controller 的时候会经过一系列的 HandlerMethodArgumentResolver，我们可以写一个 Resolver 实现该接口，并在 Spring 中增加这个 Resolver，那么只要符合 JSON 格式参数，那么就可以通过该 Resolver 实现注入。 实现首先我们需要准备一些注解，用于标注是通过 JSON 格式的数据获取参数的： 首先是和 @RequestParam 一样的 @JsonParam，用于标注该参数注入的名称和是否必须注入等信息： 然后是用于标注在方法上的 @RequestJson，通过标注这个注解，我们就可以不需要使用 @JsonParam 注解来描述参数，而是使 Spring 通过参数的名称注入该参数： 还有一些工具类这里就不写了，这些工具类主要是用于一些特性的实现，比如点语法等。具体可以到 这里 查看。 接着就是用于处理 JSON 格式参数的 HandlerMethodArgumentResolver 了： 最后还需要将该 Resolver 添加到 Spring 中： 至此实现的部分就完成了，让我们看看如何使用吧。 使用 可以看到使用的方式和 @RequestParam 无太大差别。 结语最近打算开始接着折腾 Spring 和后端了，感觉我还是更喜欢后端，前端太折腾了 ?。"},{"title":"浅谈 Proxy 和 Aop","date":"2020-08-01T14:45:05.000Z","url":"/talking-about-proxy-and-aop.html","tags":["设计模式","Spring","浅谈"],"categories":["折腾记录"],"content":"前言好久没写浅谈系列的文章了，正好最近正在整理 Aop 相关的资料，之前也写过 DI 和 IoC 的文章，想想还是直接写一篇文章输出下。 寫文的好處嘛，就是一堆你以為已經懂的東西，結果根本是一知半解。 - 来源 什么是 Proxy？在讲 Aop 之前还是需要先讲讲 Proxy。 Proxy (代理) 是实现 Aop (切面) 的基础，使用代理方法我们可以在不修改原始类的情况下增加一些功能，这个行为一般称之为装饰，不过和装饰模式不同的是装饰模式是动态的装饰原始类，可以通过切换不同的装饰器做到不同的效果，在 Java 中，常见的代理有三种： 静态代理：使用代理模式实现 Jdk 代理：使用 Jdk 中内置的 Proxy 类实现，基于接口 Cglib 代理：使用 Cglib 动态生成代理类，基于子类 静态代理静态代理采用的是在代码中写好代理类的方式实现，通常使用代理模式这个设计模式规范设计，由于需要手写代理类，所以当被代理类很多的时候，那么要跟着写很多代理类，所以一般只用于对性能敏感等需要代理少量类的场景下。 Jdk 代理Jdk 代理是一种动态代理，动态代理的好处是不需要我们手写代理类。在 Jdk 中有一个 Proxy 类我们可以通过使用这个类的 newProxyInstance 动态的创建一个代理类，我们只需要实现 InvocationHandler，就可以做到被代理类的装饰。 例子要使用 Jdk 代理需要先准备三样代码：被代理类，被代理类实现的接口，实现 InvocationHandler 的装饰类 首先是被代理类的接口（UserServiceInterface）： 然后是被代理类（UserService）： 由于 Jdk 代理是基于接口的，所以最少需要实现一个接口 最后是实现 InvocationHandler 的装饰类： 执行的方法： 代码很简单，这里就不解释了，我直接贴结果吧： 执行被代理方法前 执行被代理方法中 执行被代理方法后 返回值: syfxlin syfxlin 可以看到，我们通过装饰类 “偷偷” 在方法前和方法后插入了一些代码，生成的代理类的工作是 Jdk 动态完成的。 原理当我们调用 Proxy.newProxyInstance 的时候 Jdk 会调用 ProxyGenerator 的 generateProxyClass 方法，该方法返回 byte 数组，这就是动态生成的代理类，我们可以把 byte 输出成 class 文件，然后使用 Intellij IDEA 反编译查看该类。 下面是生成代理类 class 文件的代码： 反编译的代码这里就不全放了，我只放关键的部分： 从反编译的类中我们可以看出代理的类实现了 Proxy 类，同时继承了我们定义的 UserServiceInterface 接口，并实现了该方法，这也是 Jdk 代理只能代理有接口的类的原因。 然后是 getUsername 方法，代理类通过调用在父类定义的 InvocationHandler 中的 invoke 方法来执行具体的代码。 到这里我们梳理下流程吧： Jdk 代理在 Jdk 中的很多地方都有用到，其中最典型就是注解，我们使用的注解其实是通过 Jdk 动态代理的方式创建对应的注解类，而注解中的属性（方法）其实并不是真实的方法返回值，而是通过动态代理从代理类中的一个隐藏 Map 属性 memberValues 中获取的，操纵了这个 Map 的值，相应方法的返回值也会跟着改变，通过这个特性我们就可以制作出同 Spring 一样的注解别名了。 Cglib 代理Cglib 也是一种动态代理，功能和 Jdk 代理类似，不过 Cglib 使用的是继承被代理类的方式装饰被代理类，所以可以代理无接口的类。 例子要使用 Cglib 代理，我们首先需要准备 Cglib，被代理类（UserService），实现了 MethodInterceptor 的装饰类： Cglib 的导入这里就不写了，导入的方式有很多种，只要导入了就行了。 然后是实现了 MethodInterceptor 的装饰类： 执行的方法： 代码也很简单，输出和 Jdk 动态代理的一样，这里就不细讲了。 原理要生成 Cglib 代理类的 class 只需要设置一下系统的属性就可以了： 下面是生成代理类 class 文件的代码，同样删掉一些不需要关注的代码： 通过上面的代码我们可以看到，代理类继承了我们的 UserService 类，同时实现了一些接口，UserServiceInterface 是我们手动传入的，如果不传入就不会出现在代理类中，不过由继承自 UserService 类，所以其实代理类也是实现了 UserServiceInterface 接口。 Cglib 代理的流程其实和 Jdk 代理差不多，也是转发到一个装饰器，然后通过这个装饰器来动态的增加一些功能。 Cglib 代理具体流程： 什么是 Aop？如果你看过之前写过的关于中间件的文章，想必你已经知道 Aop (面向切面编程) 的作用和使用场景了，不过为了照顾到不清楚 Aop 的同学们，我还是稍微介绍下吧。 Aop 是一种设计范型，旨在将复用的逻辑抽离出来，这么说可能难以理解，我们就举个例子吧，假设我们今天要实现一个 API 鉴权的功能，如果不使用 Aop，我们为了每个 API 都能有权限验证，那么我们需要给每个 API 都增加相应的鉴权代码，这是非常丑陋的，那么我们要如何优化呢？把复用的逻辑抽出来，再进入每个 API 的业务之前对请求鉴权，而这就是 Aop 的思想和功能。 一些名称和概念 Aspect (切面)：定义了处理某段逻辑并且可模块化增强其他类的的类，比如鉴权处理、日志处理。 Join Point (连接点)：被拦截到的点，我们可以简单的理解为方法（Spring 只支持方法级别的切面）。 Advice (通知)：通知指的是拦截到某个点后要执行的代码，比如我们要在进入一个 API 的时候鉴权，就可以用 Before 的 Advice。 Point Cut (切点)：定义要增强的一系列目标对象的位置，比如通过注解标注某个方法要鉴权，那么这个方法就是一个切点。 Target (目标对象)：要被增强的对象，比如处理某段业务的 API Weaving (织入)：即将切面和目标对象组合起来过程，可以采用动态代理的方式织入（Spring），也可以采用编译期织入（AspectJ），这里需要注意一下，Spring 虽然有可以使用 AspectJ 定义切面，不过只使用了 AspectJ 的注解，切点过滤等功能。 原理直接跳到原理吧，例子网上随便找下 Spring Aop 就有了，这里就不在多写了，我在 Github 上也有一份简单的 Demo 代码，不想查找的也可以去看看。 Spring Aop 的切面我没仔细看过，而且也相对复杂，这里就不使用 Spring Aop 来讲解原理了。我使用的是 XK-Java Aop 的代码，这是我从 Swoft 框架抄来的并稍微魔改过的一份相对简单的代码。 首先先讲下结构吧： Advice 接口：定义了通知和切面接口，XK-Java 中没有采用 AspectJ 那种注解方式定义 Advice。 AbstractAdvice 抽象类：实现了 Advice 接口，子类可以继承该类而不需要实现所有 Advice 方法。 CanGetTarget 接口：该接口与此次文章无关，用来实现织入后获取源对象的功能。 AspectManager 类：切面管理器用于存储切面列表，并提供基本的缓存用于加速匹配切面。 AspectPointcut 类：切点匹配器，使用 AspectJ 来对方法进行匹配。 DynamicInterceptor 类：Cglib 的方法拦截器，用于将目标对象的方法代理到 AspectHandler。 JoinPoint 类：连接点，提供一些相关的信息，如目标对象，目标方法，传入的参数等。 ProcessingJoinPoint 类：连接点，和 JoinPoint 差不多，不过增加了一个 process 的方法用于执行下一个切面或目标方法。 TargetSource 类：存储了目标对象的一些基本信息，如目标对象的 Class，Interface 和 目标对象。 ProxyCreator 类：一个工具栏，用于方便的创建 Cglib 代理的对象。 AspectHander 类：切面请求链的执行器。 由于代码量比较大，我就不细讲了，这里就说说 AspectHander 和 DynamicInterceptor 吧。 首先是 DynamicInterceptor，当执行某个被切面拦截的方法的时候，TargetSource 就会从 AspectManager 中获取已经注册好的切面，并返回匹配成功的切面列表，然后新建一个 AspectHandler 执行器，调用执行器的 invokeAspect 方法。 然后是 AspectHandler，这个类是一个责任链模式的实现，具体的流程将代码后的图。 大致的流程如下： 结语到这里这篇文章就差不多讲完了，写了差不多 1w 字（其实还有很多是代码）肝了两个晚上，但愿这篇文章能帮到你。文中很多是我的总结，可能有一些错误的地方，如果你发现了错误欢迎在评论区反馈。"},{"title":"从零实现一个 PHP 微框架 - 初始化请求","date":"2020-07-25T15:02:43.000Z","url":"/implement-a-php-microframework-from-zero-6.html","tags":["PHP","XK-PHP","从零实现","框架"],"categories":["折腾记录"],"content":"前言更新一波文章。 这次的内容相对简单点，初始化请求的过程包括封装 $_GET $_POST 等关联数组到 Request 对象中，用于后续流程的使用，以及从封装 Request 到路由之前的这段过程。 构造 Request构造 Request 是通过 Application.dispatchToEmit 里的 $request = $this-&gt;make(Request::class) 初始化的，make 方法会通知容器初始化 Request 对象。 既然是通过容器来初始化的，那么就需要绑定该对象到容器，Request 对象是通过 RequestProvider 进行绑定的： Request::make从上面的代码可以看到初始化 Request 是通过 Request::make() 的静态工厂方法构造的： 首先是使用 Functions::convertFiles 方法将 $_FILES 关联数组转化到 UploadFile 数组，转化的步骤就不说明了，就是将数组的结构封装到对象（之所以要这么做是为了遵循 PSR 标准）。 然后是拼接 URL，由于 PHP 已经对 URL 进行切割，所以我们还需要拼接回去，以便后续的代码使用。以及 Protocol 的提取。 由于 PHP 将 Request header 存入了 $_SERVER 为了方便使用，我们需要把 $_SERVER 中带有 HTTP_ 前缀的字段都提取出来，这些就是 Request header，同时由于 header 是不区分大小写的，我们直接把 header 的名称转成小写即可。 new Request有了上面的一些基础的信息，就可以正式的创建 Request 对象的： 首先需要对 files 进行验证，判断 files 是否实现了 UploadedFileInterface。 接着就需要对 Request body 进行封装了，Stream 是 StreamInterface 的实现类，提供了对 body 数据流的一些操作方法。 除了 file 和 body，我们还需要把 url 封装成 Uri 对象，该对象实现了 UriInterface，提供了对 url 的一些操作方法。 由于请求的方式可能是通过 JSON 的格式传输的，此时 $_POST 就无法获取到这些通过 JSON 传输的数据，所以，我们还需要解析 JSON。 在 PSR 标准中有说明，当请求没有 Host 头的时候，需要手动设置，保证 Request 对象中存在 Host 头。 结语到这里初始化 Request 的部分就完成了。由于博主忙着重写 XK-Editor，所以更新 文章的速度可能会慢一点 2333。"},{"title":"为 Vue3 添加一个简单的 Store","date":"2020-07-11T09:21:30.000Z","url":"/add-simple-store-for-vue3.html","tags":["Vue","Vuex","TypeScript"],"categories":["折腾记录"],"content":"前言Vue 3.0 挺早就已经发布了 Beta 版本，一直没有机会尝试下。主要是最近在折腾后端，前端几乎没再碰过。现在 XK-Java 已经大致写完了，最近应该也不会添加太多的功能了，XK-PHP 也打算等到 Swoole 支持 PHP8 的时候重构一波，所以比较闲，便打算翻出以前的项目（XK-Note，XK-Editor）重构（重写）一下。 由于 Vue 2.x 对 TypeScript 的支持性不好，所以便打算直接使用 Vue 3.0，顺便体验一把函数化组件。因为 XK-Editor 需要使用 Store 来管理状态，而之前的并不太适合 Vue 3.0，于是便有了这篇文章。 效果首先放下效果： 可以看到风格非常像 React Hook，而且使用起来也很方便，可以通过像 Laravel 的 data_get 一样的点语法来获取到嵌套的 state，同时由于数据是响应式的，同时也可以直接设置值，而不需要另外增加一个 set 方法来设置。当然也不一定需要使用点语法，你也可以像之前的 Vuex 2 的 mapState 一样使用函数的方式获取 state。支持泛型，可以很好的保持 TypeScript 的特性和优点。 分析Store 相关的分析这里就不说明了，本文只介绍 Store 用到的 Vue 3.0 新增的特性。 首先就是最重要的 reactive 函数，这是在 Vue 3 新增的函数，用来将普通的数据转换成响应式数据，替代了 Vue 2.x 中的 Vue.observable。 然后就是 computed 函数，computed 函数对应着 Vue 2.x 的计算属性，由于 Vue 3 不再是 Vue 2.x 的 Options API（虽然依旧可以用）而是采用了和 React Hook 类似的 Composition API，这意味着，我们可以在任何的地方使用 Composition API，而不再局限于组件内。之所以要用到这个函数的原因是外部的响应式数据无法在组件中直接使用，会导致不更新的情况发生，所以需要一层计算属性来解决这种问题，在 Vue 2.x 也存在这个问题。 实现首先我们先创建 State 的部分： 然后是 Actions： 接着就是最主要的部分了： 由于只简单弄了一下，并没有添加 debug 的部分，由于 Vue 不像 React 一样使用不可变数据，所以无法简单的获取旧值，必须要深克隆一份才能保证旧值不随新值变化，这里就不弄了（逃。 使用使用的方式上面已经展示过了，这里就不展示了。 结语Vue 3.0 添加了 Composition API 后编码就不会再像 Vue 2.x 那样为了一个方法满屏幕找的情况了，各种逻辑都可以集中在一个区域里，同时也和 React Hook 一样，可以很方便的利用各种 use 函数扩展功能。响应式也改成用 Proxy，应该不会再遇到各种丢更新的情况了。 Vue 3 香，不过我还是更喜欢 React（逃"},{"title":"从零实现一个 PHP 微框架 - 服务提供者","date":"2020-07-10T04:16:52.000Z","url":"/implement-a-php-microframework-from-zero-5.html","tags":["PHP","XK-PHP","从零实现","框架"],"categories":["折腾记录"],"content":"前言考试在两周前就结束了，因为一直在填坑 XK-Java，所以一直没更新 PHP 微框架系列文章 2333，最近 XK-Java 也填的差不多了，后续打算把 XK-PHP 也适配到 Swoole，还有 XK-Blog 的坑还没填 ?。 什么是服务提供者（Provider）？如果你写过 Laravel，那么你一定对 Provider 不陌生，服务提供者实现了将服务绑定到服务容器（IoC Container），并按需启动的功能。 在 Laravel 中，服务提供者是在 config/app.php 的配置文件中配置的： 这些服务提供者会在框架启动后将服务注册到服务容器上，如果你学过 Spring，那么就很好理解了，这些服务提供者就是用编码的方式来注册 Bean、Component 等等，因为 PHP8 才开始支持注解，所以目前跑在 PHP7 的 Laravel 无法像 Spring 一样很方便的绑定服务实例。 光说肯定没法很好的理解，那么我们就来看一个简单的服务提供者吧： 这是 Laravel 用来注册 CookieJar 实例的服务提供者，可以看到在 register 方法中使用了 singleton 方法将一个的回调注册到了服务容器中，这样，当我们使用 $app-&gt;make(&#39;cookie&#39;) 的时候就可以取得 CookieJar 实例了。 当然服务提供者不止可以注册服务，还能在服务注册后启动实例，只要重写 boot 方法即可。 定义 Provider了解了服务提供者，那么就可以开始编码了。 首先，我们需要定义 Provider 的接口和抽象类来规范 Provider，如下： 可以看到 Provider 和 Bootstrap 其实差不多，所以这里就不对抽象类做说明了，具体请看 Bootstrap 篇。 编写 Provider由于 Provider 数量众多，所以这里就不全部写了，只列举几个比较典型的。 CookieProviderCookieProvider 是一个简单纯注册服务的 Provider： RouteProviderRouteProvider 在注册后还会提供预加载，即 boot： AspectProvider除了简单 Provider，还有一些比较复杂的 Provider，如 AspectProvider： 在 AspectProvider 中不止注册了 AspectManager，还会读取配置文件将切面也加载进服务容器，同时在启动时把切面依次放入 AspectManager。 加载 Provider有了 Provider，那么 Provider 是如何被创建和执行的呢？ 在 Bootstrap 有两个 Provider 相关的 Bootstrap，分别是 RegisterProviders 和 BootProviders，上一篇文章只是简单介绍了这两个 Bootstrap 的功能，这里就详细的讲解一下。 然后我们看看 ProviderManager： 其实看起来复杂，不过 ProviderManager 做的事情也很简单。 首先利用 Class 创建对应 Provider 实例，然后将 Provider 添加到 ProviderManager 的 Provider 数组中，最后判断有没有 register 方法，如果有则执行该方法。 有了注册，那么还需要一个启动： 在 BootProviders 中 boot 方法会从服务容器中取得 ProviderManager，然后调用其 boot 方法，依次执行 Provider 的 boot 方法。 结语到这里 Provider 的部分就说完了。现在也放假了，PHP 微框架的文章会逐步更新。不过最近还是比较忙的，更新速度会慢一点。?"},{"title":"WSL2 踩坑记录","date":"2020-06-28T17:05:11.000Z","url":"/wsl-2-recording.html","tags":["Windows","Linux","WSL"],"categories":["折腾记录"],"content":"前言前不久 Windows 20H1 正式推送了，我们终于可以用上 WSL2 了，博主因为是 Release 通道的 Insider，所以比其他用户早升级到 20H1，由于之前比较忙，所以一直没折腾 WSL2，直到前天考完了试，并且我之前部署的 Ubuntu 虚拟机总是出现一些问题，于是就打算试试 WSL2。 安装准备环境由于 WSL2 使用的是 Hyper-V 虚拟平台，所以我们需要先开启虚拟机平台，使用以下命令开启，或者也可以使用 Windows 的界面进行设置。 设置完成后重启下 Windows。 准备发行版重启完成后我们可以先使用 wsl -l 查看已经安装的 WSL 发行版。 由于 WSL2 和 WSL1 可以共存，如果你想日常继续使用 WSL1，只将 WSL2 用于 Docker 等用途的话，我建议你复制一份，然后将其转成 WSL2，就如上面的截图一样（Ubuntu 是 WSL1，Ubuntu-WSL2 是 WSL2）。 复制 WSL 发行版的方法如下： 首先安装 LxRunOffline，Scoop 可以使用 scoop install lxrunoffline 安装。其他的安装方式这里就不写了，具体请自行查看。 使用 LxRunOffline 复制的方式很简单，使用以下命令即可： 当然有时候我们会使用新建的发行版来用于 WSL2，这时就可以用 LxRunOffline 导入新的发行版，也可以用 Microsoft Store 安装。 切换 WSL 版本有了要转换的发行版后我们就可以用以下命令将 WSL1 转换成 WSL2 了。 等待其切换完成，切换完成后就可以通过 wsl -d &lt;发行版&gt; 进入到 WSL 中，此时 WSL2 的安装就完成了。 初始化 WSL2对于初始设置 Apt 镜像，安装基础应用，Docker，Systemd，Zsh 的脚本我已经制作好了，并发布到了 Github 上，你可以直接使用此脚本完成对 WSL2 的一些初始化操作。 使用此脚本安装的 Docker 已经预先配置好了 tcp:2375 端口，Windows 下只需设置 DOCKER_HOST 的环境变量就可以无痛使用 Docker 和 Docker-Compose，而无需安装 Docker for Windows，同时在 WSL1 中也可以通过这种方式使用 WSL2 中的 Docker（不过一般也不需要，WSL1/2 中可以直接使用 Windows 下的命令和程序。 注意: 在某些情况下，可能会出现 2375 端口处于监听状态，但是 Windows 无法连接的情况，所以博主建议使用 socat 来暴露 docker 的管理端口，具体查看 docksal/service-socat 同时，本脚本会设置一个启动时进行一些设置的 shell 脚本，具体功能如下： 自动设置 hosts，由于 WSL2 中目前还无法实现使用 localhost 访问 Windows 下的服务，所以需要通过 hosts，或者 IP 来间接访问 Windows 的服务，但是由于 WSL2 的 Hyper-V 交换机在每次重启的时候都会重设 IP，这就导致了 hosts 无法设置成静态的，不然一重启就需要重新设置了。解决这个问题的方案是在每次进入 WSL2 的时候自动从 /etc/resolved.conf 中获取 Windows 的 IP，然后将该 IP 设置到 hosts 中，同时删除旧的 hosts。（默认设置的域名是 h.test） 设置 WSL_HOST 环境变量，如果不想使用 hosts 的域名，也可以使用 WSL_HOST 来访问 Windows。 设置 DISPLAY 环境变量，通过该环境变量，我们就可以将 Linux GUI 应用转发到 Window 下的 X Server。 启动 systemd，由于 WSL2 依旧是使用 init 进程，而非 systemd，所以我们无法使用 systemctl，这对 WSL2 的使用产生了很多的限制，不过我们可以通过一些手段来启动 systemd，具体见 ubuntu-wsl2-systemd-script。本脚本对其进行了一些修改以适应本脚本。 一些使用技巧停止 WSL2：wsl --shutdown wsl -t &lt;发行版&gt; 备份：wsl --export &lt;分发版&gt; &lt;文件名&gt; 恢复：wsl --import &lt;发行版&gt; &lt;安装位置&gt; &lt;文件名&gt; [--version &lt;版本&gt;] 设置默认登录用户：lxrunoffline su -n &lt;发行版&gt; -v &lt;UID&gt; 卸载：lxrunoffline ui -n &lt;发行版&gt; 移动：lxrunoffline move -n &lt;发行版&gt; -d &lt;路径&gt; 复制：lxrunoffline d -n &lt;要复制的发行版&gt; -d &lt;复制后存储的路径&gt; -N &lt;复制后发行版的名&gt; Windows 目前已经可以使用 localhost 访问 WSL2 了，不过由于 Hyper-V 端口映射的一些问题，可能在 Windows 下会出现没有使用的端口也提示占用的问题并且 netcat 也未显示，这是因为 WSL2 的动态端口设置有点问题，WSL2 的动态端口是从 1024 开始映射的，可以用以下的命令调整到高一点的端口。 Docker for Windows 似乎会调整 WSL2 Hyper-V 交换机的类型，这会导致 Windows 无法使用 localhost 访问 WSL2，解决的方案是将 WSL2 的 Hyper-V 交换机调回内部网络 由于 Hyper-V/WSL2 的网络不属于防火墙的专用组，所以部分应用会因为防火墙的问题而无法访问 Windows 下的端口，解决方案是使用以下的命令添加防火墙规则，同时删除阻止规则。（由于 Window 防火墙阻止规则的优先级大于允许，这会导致以下设置的规则无效） 如果你一定需要使用静态 IP，那么也可以用以下的命令另外添加静态 IP。（重启失效） 在 Windows 中要使用 WSL 中的应用我们可以创建一个 Proxy 脚本来代理调用 WSL 的应用，具体创建的方式如下，创建好后就可以用这个在 Windows 下执行该脚本，相当于在 WSL 中执行命令： 在 WSL2 的 Shell 中使用 docker-compose 你可能也会遇到这个问题： 此时你只需要运行以下的命令即可： 无意间发现的小特性如果你看过 WSL 导出的系统你会发现导出的是 rootfs，而碰巧 docker 导出的容器也是 rootfs，所以理论上是可以通用的，而且 WSL 本来就可以导入 docker 的基础系统（如 Ubuntu 镜像），那么从基础系统上构建的镜像也是可以运行在 WSL 上的。 由于从 DockerHub 上拉取的是分层的镜像，所以我们需要创建成容器后再导出。 导出后我们就取得了 nginx 容器的 rootfs，然后通过 lxrunoffline 导入这个 rootfs 到 WSL 导入后就可以启动了 博主我稍微测试了下，运行是没有问题的，不过有可能会有坑，如果你不想在 WSL 里跑 docker 的话也可以考虑试试这个方案。 结语WSL2 其实我们可以把它看成是一个轻量的虚拟机平台，介于 Docker 和 VM 间的存在，WSL2 相比于传统的 VM，它的启动速度飞快，同时占用更小，而且自动设置了端口映射和目录挂载，同时导入发行版的速度也比从头安装系统快出许多，我试过导入一个 Ubuntu Core 的镜像，并转成 WSL2，算上打字的延迟，只需要 28s。 相比 Docker 虽然差了很多，不过偶尔需要使用非 Docker 的 Linux，也不再需要等待漫长的安装了。 不过 WSL2 目前还不够完善，还有许多的问题，比如 WSL2 访问 Windows 的问题就挺难受的，还有 export import 的效率不如 VMware 和 VBox 的快照等等。 希望微软能越做越好吧，现在 WSL 已经支持 GPU 加速了，那么下一个功能会是什么呢？好奇.jpg"},{"title":"浅谈浏览器Event Loop [更新]","date":"2020-06-24T11:05:00.000Z","url":"/talking-about-browser-event-loop.html","tags":["JavaScript","前端","浅谈"],"categories":["折腾记录"],"content":"更新此篇文章的原因是看到一个 JSConf 关于事件循环的演讲，建议有能力的（能上 YouTube）看看这个演讲。 Jake Archibald: 在循环 - JSConf.Asia 什么是 Event Loop？若你了解过 JavaScript，你一定知道 JavaScript 是一种单线程语言，为什么 JavaScript 是单线程呢？为什么不使用多线程呢？JavaScript 作为浏览器脚本语言（虽然现在也在后端挺流行的），JavaScript 的主要用途是与用户互动，以及操作 DOM。若使用多线程就会导致一些问题，比如更新丢失等问题，当一个线程要删除 DOM 的时候另一个线程要更改它，那浏览器该如何操作呢。所以 JavaScript 为了避免多线程带来的一系列问题采用了单线程的运行机制。 而若只是单纯的同步单线程的执行便会导致 JS 运行到某个需要等待的位置时就会造成假死状态，比如当 JS 要从网络中获取一张巨大的图片，发起了 HTTP 请求，在等待 HTTP 请求中若是不采用某种机制来处理的话就会导致卡住的假死状态，我们可以用 Java 来模拟一下: 从上面的运行结果可以看到，同步运行的时候 Java 在 begin 和 end 中间隔了非常久的时间，程序也在那时候被阻塞住了，而UI是不能被阻塞的否则会严重影响用户体验，所以 JS 采用异步来防止这种情况发生。 当JS线程执行到需要异步的操作的时候就会把该任务发到任务队列，然后继续向下执行，当所有的同步代码都执行完毕的时候，JS 线程就会从任务队列读取任务并执行，若遇到异步操作就继续入队。。。如此往复，这就是Event Loop(事件循环)。 Task在浏览器中存在着一个任务队列，如上图，左侧绿色的部分，任务队列中存放着将要执行的任务，当任务队列中没有任务的时候，事件循环会进入空转的状态，但这并不代表浏览器是休眠的，从上图我们可以看到，除了任务队列外，事件循环还要处理渲染相关的任务。一旦有任务进入任务队列了，浏览器会在可以执行任务的时机从任务队列中取出任务并执行，执行完一个任务后就进入下一个循环，而不是逐个取出任务执行直到任务队列为空。 为了容易理解 Task，我们通常把 Task 分成 MacroTask (宏任务) 和 MicroTask (微任务)，宏任务很好理解，就是一些异步的任务，如 setTimeout 等等，而微任务比较常见的就是 Promise。微任务会在宏任务执行完后，并且 JS 调用栈为空的时候执行。具体的过程下面会分析。 PromisePromise 是 ES6 新增的一种异步解决方案，它的运行方式是当需要进行 I/O，等待等异步操作的时候，不返回结果而是返回一个 Promise（”承诺”），当这个承诺完成的时候，即状态变为 fulfilled 或者 rejected ，这个 promise 就定格了，也可以认为返回值是一样的了，你可以在任何位置任何时间利用 then 得到这个结果（返回值），或许这有点难以理解，那就举个例子吧： 运行重置输入 从上面的运行结果可以看到 re 确实在第一次调用 promise1 的时候被修改为 foo2，但是当第二次调用 promise 时的 value 并没有跟着改变，也就是说 promise 不会再调用第二次，而是直接返回结果。 async/awaitES7 中添加了 async 和 await 的关键字，async 返回的必定是 Promise，可以理解为就是异步函数，await 是等待 Promise。 async 可以使一个函数成为异步函数，返回 Promise，我们可以把 async 认为使new Promise 的语法糖，所以当函数 return 值的时候 return 的不是值而是Promise，若要得到 async 中 return 的值就需要使用 then。 运行重置输入 await 是等待后面东西，可以是 Promise，可以是值，可以是表达式，当可以直接得到值的时候 await 会立即返回值，但若是 Promise，await 就会将 JS 阻塞住，直到 Promise 兑现，有了 await，我们可以把异步的 JS 写成同步的 JS，可以有效的解决回调地狱。 一个有用的例子 运行重置输入 看到这个代码，是不是很晕，先不要放到JS中运行，让我们一起来看看这个的输出，你可以先不看以下的步骤自己思考一下，或许能得到不小收获。 首先，sync1的console.log肯定是第一个输出的，调用栈先进了console，然后出栈，控制台输出sync1 然后程序来到了第一个setTimeout，这是一个异步宏任务，所以放到宏任务队列中，然后跳过该setTimeout。MacroTask Queue:[setTimeout-1] 接下来程序来到了new promise，new promise是同步的，所以会进入到function中，遇到第二个setTimeout，此时将这个setTimeout放到宏任务队列中，然后跳过setTimeout，执行到console.log，输出pro_new，接着遇到resolve，是微任务将其放到微任务队列中，然后退出function。MacroTask Queue:[setTimeout-1,setTimeout-2]，MicroTask Queue:[resolve] 接着遇到了promise的then，这是属于resolve的回调，当resolve状态改变的时候才执行，所以跳过该部分。MacroTask Queue:[setTimeout-1,setTimeout-2]，MicroTask Queue:[resolve] 然后又遇到了一个setTimeout，同样将其放到宏任务队列中。MacroTask Queue:[setTimeout-1,setTimeout-2,setTimeout-4]，MicroTask Queue:[resolve] 接着遇到了最后一个console.log，输出sync2，此时同步代码已经执行完毕。 微任务列表不为空，所以需要在这个tick中执行，不能先取宏任务，调用resolve的then，输出pro_then，同时将setTimeout放入宏任务队列。MacroTask Queue:[setTimeout-1,setTimeout-2,setTimeout-4,setTimeout-3]，MicroTask Queue:[] 微任务队列空了，从宏任务中取出队首的任务，即setTimeout-1，执行后输出sync_timeout1 取出队首任务，setTimeout-2，输出pro_new_timeout 取出队首任务，setTimeout-4，输出sync_timeout2 取出队首任务，setTimeout-3，输出pro_timeout，此时宏任务列表和微任务队列为空，js引擎进入等待状态。 sync1 pro_new sync2 pro_then sync_timeout1 pro_new_timeout sync_timeout2 pro_timeout 你们猜对了吗？反正我第一次是没猜对（逃 一些值得了解的地方很多文章会把 Task 分成 MacroTask 和 MicroTask，并说明 MicroTask 是在 MacroTask 的末尾执行完毕，其实这并不准确。我们来看看以下代码： 代码很简单，为一个按钮注册两个点击事件，当用户点击后，控制台会输出一些日志： Listener 1 Microtask 1 Listener 2 Microtask 2 按照微任务在宏任务完成后执行的流程，对照这输出，似乎并没有错误，但是，如果我们手动触发点击事件会如何呢？ 此时的输出就变成了： Listener 1 Listener 2 Microtask 1 Microtask 2 从以上输出可以看到，微任务一定会在该宏任务下执行完毕的说法是错误的，那么，是什么原因造成二者的差异呢？其实，这是就是我在 Task 章节里说到的，微任务会在宏任务执行完后并且 JS 调用栈为空的时候执行。在第二段代码中，执行完 Listener 1 宏任务的时候，JS 调用栈还存在着 button.click() 这个函数的栈帧，所以 Microtask 1 微任务就无法被执行，直到 Listener 2 完成的时候，button.click() 函数调用帧才会出栈，此时 JS 调用栈才为空，微任务才可开始执行，所以就有了以上的输出。 结语学了好久的前端，之前对异步只处于会用的状态，前几天刚了解了一下 JS 的异步，刚好好久没写过文章了，便自己整理了写成一篇文章，输出才是最好的学习，其实是为了水文章（逃。(￣y▽,￣)╭"},{"title":"从零实现一个 PHP 微框架 - Bootstrap 启动加载","date":"2020-06-18T14:09:25.000Z","url":"/implement-a-php-microframework-from-zero-4.html","tags":["PHP","XK-PHP","从零实现","框架"],"categories":["折腾记录"],"content":"前言抽了个空更新一下，给博客除除草。 Laravel 框架中在启动的时候，会依次调用 Illuminate\\Foundation\\Http\\Kernel::$bootstrappers 中的启动类，这些启动类会完成对 .env 文件的加载，配置文件的加载，配置错误处理器，注册 Provider，并启动 Provider。XK-PHP 也参考该流程制作了对应的 Bootstrap，但是 XK-PHP 并没有用 Kernel 来加载，而是使用 Application 这个类来作为核心，调控框架。 定义 Bootstrap首先我们需要创建一个 Bootstrap 接口和抽象类来管理 Bootstrap，Bootstrap 接口和抽象类如下： 由于我们在 Bootstrap 中可能需要用到 Application 中的实例或方法，或者需要将将类或实例绑定到 Application 中，我们可以通过构造器传入一个 Application 实例，当 Bootstrap 具体的实现类需要使用的时候就可以直接使用 $this-&gt;app 来取得 Application，而不再需要使用 Application 的静态方法来调用。 编写 Bootstrap首先我们先看下需要哪些 Bootstrap，同时需要知道那些需要在 Bootstrap 中加载。 Bootstrap 的作用是在应用启动时对一些配置文件，环境变量，门面，异常处理这些进行读取注册，主要的工作是在 Provider 未开始执行的时候提供 Application 运作的基础服务，而具体的服务，如切面，路由，数据库等不是基础服务，应在 Provider 中进行加载，关于 Provider 我会在下一篇中介绍。 我们直接看看有那些 Bootstrap 吧，Bootstrap 列表是在 Application 中定义的，如下： LoadEnvironmentVariables该 Bootstrap 主要的工作是加载环境变量和 .env 文件，使用的是 vlucas/phpdotenv 这个库，所以加载的部分就很简单了，直接调用其方法即可。 LoadConfiguration然后就是加载配置文件了，之所以不直接使用 env 来作为配置，主要的是 env 并不需要将所有的配置都写全，应用要调用的时候就需要设置默认值，当该配置文件多了，需要改默认值的时候，就容易遗漏，非常不好管理。所以我们需要另外的配置文件来集中的管理。LoadConfiguration 的内容很简单，就是绑定 Config 类实例到容器中，其中配置文件的读取是在 Config 类中完成的。 在 Laravel 中，LoadConfiguration 还进行了许多的操作，比如，如果有 Config 缓存文件则直接读取缓存文件，当没有缓存文件的话，Laravel 才会扫描 Config 目录，在 Laravel 中，Config 是支持文件夹的，不过 XK-PHP 就没对文件夹进行处理。Laravel 在 LoadConfiguration 还会对一些值进行初始化，如设置时区 date_default_timezone_set，设置编码 mb_internal_encoding，然后检测是开发环境还是生产环境，并将该值设置到容器。 RegisterFacades在 Laravel 中，门面是一个很方便的东西，我们可以通过门面快速对方法进行调用，同时也不需要关系我们调用的方法来自哪个类，是静态方法还是实例方法。XK-PHP 也采用这一设计，不过 XK-PHP 也缩减掉了部分功能，比如同一个门面调用不同类的方法等等。 XK-PHP 中注册门面的过程也是很简单，就是将 Application 设置到门面抽象类中的静态属性，如下： 具体的实现这里就先不说明了，后续讲门面的时候在说吧。 HandleExceptions接下来就是注册异常处理了，在说明具体的实现之前，我们需要先了解一下 PHP 异常处理相关的函数。 error_reporting：设置报告的异常等级，0 表示不报告错误，-1 表示报告所有错误。 set_error_handler：设置自定义的错误处理函数，当应用抛出错误没有使用 try/catch 捕获的时候，会调用该函数设置的处理函数对错误进行处理。 set_exception_handler：设置自定义的异常处理函数。 register_shutdown_function：设置一个在 PHP 脚本停止时调用的函数。 有了上面这些函数，我们就可以很方便的进行异常处理了： RegisterProviders注册 Providers，在一些基础服务加载后，就可以注册服务提供者了，XK-PHP 另外写了一个类来管理 Provider，所以 Bootstrap 的代码也挺简单的： 关于 ProviderManager 的内容会在下一篇讲解，本篇就不做太多的说明了。 BootProviders最后就是启动 Provider 了： 结语最近学院里安排了考试，同时又安排了 JavaWeb 体验实习的课程（说白了就是培训班的课程，真的浪费时间，会的都会了，不会的这期末开课也没人想听），所以最近没有什么时间来更新文章和项目了，等 6 月底考完后应该就会有比较宽松的时间，虽然说还有体验实习的课程和对应的课程设计，不过 XK-Java 也已经完成了，写项目会比纯 JavaWeb 写起来容易多了，所以应该还行。 "},{"title":"从零实现一个 PHP 微框架 - IoC 容器","date":"2020-05-13T14:21:08.000Z","url":"/implement-a-php-microframework-from-zero-3.html","tags":["PHP","XK-PHP","从零实现","框架"],"categories":["折腾记录"],"content":"前言差不多该写写该系列文章了，咕了好几天 ?。 在 XK-PHP 中 IoC 容器是框架的核心，其掌管着框架中实例的存储和初始化，并提供自动依赖注入等功能，我们可以把 IoC 容器看成一个拥有存储功能的工厂，当我们需要某个实例的时候，工厂会依靠需求将实例组装好并返回给需求者，如果实例是单例的，那么制作好的实例就可以存到仓库中，当需求者再次需要的时候就可以直接返回实例。需求者无需关心实例是如何制造的，只需要将需求提交给工厂即可。这看起来似乎就是工厂模式？IoC 容器和 工厂模式 很类似，但是工厂模式注入的依赖是定死的，而 IoC 容器可以依据需求按需注入依赖。 DI &amp; IoC由于我之前写过 DI 和 IoC 的介绍文章，这里就不重复写了，链接见下方： IoC 容器由于之前的文章已经说明了 IoC 容器的实现了，这里就不再讲解 IoC 容器内部的细节了，本文就只讲述将 IoC 容器集成到我们上次创建的项目之中。 首先，因为我们的容器需要兼容 PSR-11 ，那么就需要引入 psr/container 的包，来引入 ContainerInterface 接口： 然后容器需要使用两个自定义函数，我们将其放到 app/Helper/functions.php 中，并修改 composer.json，使函数能被 Composer 自动导入并且全局生效： 修改了 composer.json 的 autoload 后需要运行以下命令后才能生效： 然后就可以写容器的代码了，首先创建 app/Kernel/Container.php 的文件，输入以下代码，本文的容器代码和之前的文章中的容器不一样，但是流程是一样的： 测试完成以上步骤后就可以测试下容器是否可以正常工作了，首先创建几个测试类： 然后修改 public/index.php 文件，把之前 Test 相关的代码都删了，然后添加以下代码： 添加完毕后就可以进行测试了，运行 index.php： 可以看到，我们并没有写赋值 Cat 和 Dog 的代码，按理使用的时候应该为 null，而 CatShop 和 DogShop 却可以正常使用，这是因为 IoC 容器中为我们完成了赋值的工作，我们只需要关心需要使用什么而不需要关心依赖是如何来的，这样就可以很好的解耦代码，同时也简化了代码的编写。 结语结语。。。实在不知道写什么了 ?。"},{"title":"从零实现一个 PHP 微框架 - PSR & Composer","date":"2020-05-09T15:04:20.000Z","url":"/implement-a-php-microframework-from-zero-2.html","tags":["PHP","XK-PHP","从零实现","框架"],"categories":["折腾记录"],"content":"什么是 PSR？如果你不是刚入门 PHP 新手，那么你应该已经知道了 PSR 标准，不过为了照顾到不清楚的同学，这里还是要介绍一下。 PSR 即 PHP Standard Recommendations （PHP 推荐标准）的简写，由 PHP-FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。类似于 Java 的 JSR 标准，它提供了 PHP 编程概念的标准化。目的是通过各框架作者之间的讨论制定一个标准，各框架都应遵循该规范进行开发，避免了不同框架自行发展阻碍了 PHP 的发展。 PSR 标准：Github（英文） LearnKu（中文） 什么是 Composer？Composer 我应该不用介绍了吧？（逃 Composer 是 PHP 的一个依赖管理工具。类似于 NodeJS 的 NPM，是用来管理依赖包的。为什么需要依赖管理呢？当我们开发一个项目的时候，总会用到一些第三方的 Library，而不同的 Library 的安装方式都不相同，使用的方式也不相同。但是可被复用的代码集或功能集，都应该以一致的方式编写和声明，并且发布到云端的仓库中。这样能够减少使用者的了解与学习成本，并且能够通过工具来管理。而包管理器就是那个工具，通过包管理器，我们可以以一致的方式引入 Library，使用 Library，当我们不需要的时候又能轻易的卸载不需要的 Library。 自动加载PSR-4 自动加载规范 是一个给 PHP 自动加载器将命名空间映射到文件系统的规则，PSR-4 是对 PSR-0 的补充，PSR-4 是为了解决 Composer 目录层次的问题。 写 PHP 最麻烦的就是 require 和 include 了，而有了自动加载，我们就不需要再写麻烦的 require/include 了，利用 spl_autoload_register PHP 就会在需要的时候自动加载，同时也不会遗漏或者把不必要的类加载进来，同时也不会因为大量的类而编写庞大的 require/include 代码。 自动加载带来的好处： 使用类或代码前无需使用 require/include。 但有使用的时候才会 require/include，实现了懒加载。避免了遗漏和多余。 无需考虑路径的问题，我们只需要按照规范编写代码即可。 初始化项目利用 Composer 我们就无需直接编写自动加载器的规则，只需按照 PSR-4 的标准编写代码，Composer 会在我们需要的时候自动加载类和代码。 首先我们先找个一个文件夹，然后用 IDEA 打开它（你也可以用 PhpStorm，VSCode 等编辑器），然后打开终端，输入： 输入信息后 Composer 会在项目根目录（以下简称根目录）下生成一个 composer.json 的配置文件。 然后我们在根目录下新建一个 app 文件夹，作为框架的主要入口，同时在 composer.json 中添加 autoload 的配置项，完成后的 composer.json 如下： 其中 psr-4 指的是按 PSR-4 标准加载的命名空间，key 是命名空间，value 是路径，此时在 app 下的所有类如果按 PSR-4 标准进行编写，那么 Composer 就会自动加载了。 然后执行以下代码初始化 Composer 的 autoload 文件： 不过此时还不算完成，我们还需要写一个入口文件，作为网站的入口，这里我放到根目录下的 public 文件夹下，这样外部就无法直接访问根目录了。在 public 文件夹下建立 index.php 文件，内容如下： 此时 Composer 已经可以正常工作了，我们写一个类来测试下，在 app 目录下新建一个 Test 类： 然后在 index.php 下添加 echo (new Test())-&gt;name，然后运行测试下： 结语今天就简单介绍了下 Composer 和 PSR，下一篇文章不出意外就是 IoC 容器了，您可以先前往我之前的文章了解一下："},{"title":"从零实现一个 PHP 微框架 - 前言","date":"2020-05-07T07:22:59.000Z","url":"/implement-a-php-microframework-from-zero-1.html","tags":["PHP","XK-PHP","从零实现","框架"],"categories":["折腾记录"],"content":"前言前不久为了准备用 PHP（原本打算是用 Spring，但是还不太会 233） 写一个博客项目，因为不打算使用任何框架，于是便打算自己写一个应用模板来完成博客这个坑。由于之前用过 Laravel 并且很喜欢 Laravel 接口的风格，一开始打算是弄一个接口与 Laravel 类似的模板，所以就没有考虑到 PSR 相关的标准。后来由于博客项目暂时咕掉了 ?，而且 PHP 模板也逐渐完善便打算将其作为一个独立的项目来进行开发。 在开发的期间学习了许多有趣的功能和设计模式，看了不少 Laravel 的文章和源码（XK-PHP 有部分代码是基于 Laravel 缩水而来，当然也有不少添加了一些功能 ?）。 最近 XK-PHP 已经趋于完善，于是就打算把开发过程遇到的坑和学到的知识写成文章，做下记录顺便分享给有想了解框架如何实现的同学们。 本系列文章（没错，我要水好几篇文章 ?）主要是围绕着 XK-PHP 的实现过程展开，同时也会提及 Laravel 和 Swoft 等 PHP 框架的代码或问题。（预计可能会写好几个月 目录 从零实现一个 PHP 微框架 - 前言 从零实现一个 PHP 微框架 – PSR &amp; Composer 从零实现一个 PHP 微框架 – IoC 容器 从零实现一个 PHP 微框架 – Bootstrap 启动加载 从零实现一个 PHP 微框架 – 服务提供者 Github 地址目前 XK-PHP 大部分的功能均已完成，如果不想看文章的话也可以直接到 Github 上查看代码。 主要功能 IoC 容器，兼容 PSR-11 中间件，兼容 PSR-15 请求和响应，兼容 PSR-7 注解 Aop MVC Facade ReactJS 集成，类似于 Laravel Mix 简单事件系统 简单任务队列，类似于协程，但是是同步阻塞的，只是可以主动让出 PHPUnit 单元测试，HTTP 测试 响应异常处理 日志系统 模板系统，类似于 Yii 的视图 …… 流程图 框架成果 由于框架已经实现，所以我们就先看看结果吧。可以看到使用的方式和 Laravel 类似，当我们需要某些对象的时候，只需要在方法参数声明即可，IoC 容器会自动注入到方法中，也可以在构造器中或使用注解的方式注入到类中，同时也支持切面，日志，事件等功能。 结语XK-PHP 参考了以下的框架： Laravel Swoft Yii 感谢这些框架为我提供了实现和学习的思路。"},{"title":"MVVM 简单实现","date":"2020-04-20T16:09:16.000Z","url":"/mvvm-simple-implementation.html","tags":["JavaScript","Vue","前端","设计模式"],"categories":["折腾记录"],"content":"什么是 MVVM？MVVM 即 Model-View-ViewModel 的缩写，最早由微软提出，其中的 Model 和 View 想必大家都很清楚了，这就只讲 ViewModel 吧，ViewModel 是 View 和 Model 中的一座桥梁，将 View 和 Model 进行绑定，使得 Model 中数据的变化可以传递给 View 引起视图的变化，反之亦可，这一过程是自动化的，这种轻量级的架构使得开发更加高效便捷，同时也保证视图和数据的一致性。 MVVM 模型 谈谈 MVVM 框架MVVM 在挺多的地方都有使用，如 Android，Web 等，这里就只讨论 Web。 在前端 Vue.js 提供了类似于 MVVM 的数据双向绑定方式，它的核心是 ViewModel，主要负责 View 和 Model 的数据绑定。 实例如下： let data = { msg: “value” }; let vm = new Vue({ el: “#app”, data: data }); 可以看到当第一个 input 改变值的时候，第二个 input 也会跟着改变，反过来也是可以的，然而我们并没有写两者绑定的代码，这一过程是 ViewModel 自动为我们完成的。 实现一个 MVVM 这里就不谈 Vue.js 是如何实现的了，原理都差不多，网上相关的文章也很多，可以自行搜索查看，本篇文章主要讲述 MVVM Demo 的实现原理和过程。 流程首先先放一张流程图： 从图中可以比较清楚的看到创建 MVVM 时需要对 模板(View) 进行编译，对 数据(Model) 进行劫持，然后创建 监听器(Watcher) 以及 发布器(Dispatcher)，最后将 Watcher 绑定到 Dispatcher 上即可完成 Model 绑定 View，对于可以修改的 View 元素，如 input，则需要同时创建一个更新事件，当可修改的元素发生改变后则直接修改 Model 中的数据，此时就完成了 View 绑定 Model。 Model 到 View 的更新过程如上图蓝色路线，当被劫持的数据即 Model 发生改变后，则调用与之绑定的 Dispatcher 的 notify 方法，notify 方法则会调用与其绑定的每个 Watcher 的 update 方法，update 方法会调用对应的元素的更新回调方法，如普通的文本节点修改的是 textContent，input 元素修改的是 value，具体的修改方法是在创建 Watcher 的时候指定的，更新回调执行完毕后对应的更改就会反映到 View 上。 View 到 Model 的更新过程如上图绿色路线，当 View 修改的时候，会触发对应的更新事件，更新事件是在编译模板的时候就指定的，该更新事件会直接对 Model 的数据进行修改。不过此时同样会触发 Model 的 set，为了防止死循环就需要进行节流，即判断新值是否和旧值相同，如果相同则不调用 Dispatcher 的 notify 方法。 实现相关的流程讲完了，那么就进入实现的过程吧。ヾ(≧ ▽ ≦)ゝ 创建 VM创建VM的 过程 很简单，就是 劫持数据 和 编译模板： 劫持数据劫持数据的方法目前有挺多种的，可以使用传统的观察者模式，或者使用 Object.defineProperty，也可以使用 Proxy 的方式。本文劫持数据的方式使用的是 Proxy。 Proxy 只能代理对象，而不能代理基本数据类型，所以 Vue 3.0 的 Ref 为了代理基本数据类型将基本数据类型封装成只有一个 value 键的对象，不过本文就不弄那么复杂了，遇到基本数据类型就 直接返回值。由于 Proxy 并不能深度代理数据，所以需要 递归 的对每一个对象进行代理。 当发现这个对象没有子对象的时候就可以创建 Proxy 代理对象了，不过在这之前需要先创建该对象的 Dispatcher，作为该对象改变的通知调度器。Proxy 可以定义多种陷阱方法，这里就只设置 set，get 和 deleteProperty，下面就具体说下这 3 个方法。 首先是 get 方法： 在创建 Watcher 的时候，会设置 Dispatcher.target 为当前 Watcher，并且因为模板中并没有绑定数据，所以要从 Model 中首次获取数据，此时就会调用对象的 get 陷阱方法，也就是上面的代码，判断 Dispatcher.target 不为空的时候就会将 Dispatcher.target 的 Watcher 绑定到该对象的 Dispatcher 上，此时 Model 就和 View 绑定在了一起。Dispatcher.targetFor 同理，只不过这个指向的 Watcher 是父元素，用于 for 循环。 然后是 set 方法： 由于设置值的时候也可以设置相同的值，此时一样会触发 set 陷阱方法，会造成不必要的更新，同时可能会导致死循环，所以需要在真正设置值和 notify 前对其进行节流，当新值和旧值相同时就不操作，直接返回 true（Proxy 的 set 方法要求返回 true，返回 false 或不返回会抛出异常），如果值不同，就可以设置，不过由于设置的可能是一个对象，这个对象可能不是 Proxy 对象，所以还需要递归的代理该对象。设置完毕后就可以调用 notify 方法来通知 Watcher 更新视图了。 由于数组有可能新增或减少，所以可以判断更改的是否是 length 属性，如果是则通知 for 循环的 Watcher。 deleteProperty 和 set 差不多，这里就不讲了。 模板编译劫持数据说完了，接下来就是模板编译了。编译普通的模板其实挺简单的，比如这个编译纯文本： 代码其实很简单就是创建一个 Watcher，创建 Watcher 的时候 Watcher 会将获取到的值（第一次的值）保存到 value 属性中，只需要将指定节点的 textContent 属性设置为这个 value 就可以了。 不过除了像文本节点和属性节点外，还有 input 这种输入节点，此时还需要为 input 增加监听器，当 input 更改的时候触发监听器设置 Model： Dispatcher &amp; WatcherDispatcher 和 Watcher 这里就不介绍了，其实就是订阅者模式稍微改变下而已，具体可以自行查阅。（￣︶￣）↗ 使用使用的方法有点类似于 Vue： 结语总算码完了这篇文章，具体的代码可以到 Github 上查看，文中可能有错误或不足之处，如果您发现了问题欢迎反馈。[]~(￣▽￣)~*"},{"title":"浅谈 DI 和 IoC","date":"2020-04-09T13:02:40.000Z","url":"/talking-about-di-and-ioc.html","tags":["Laravel","设计模式","Spring","浅谈"],"categories":["折腾记录"],"content":" 前言用过 Laravel 或者 Spring 的人一定都听过 依赖注入(DI) 和 控制反转(IoC) 这个概念，对于刚接触这两个个概念的人来说，这两个概念很难理解，正好最近折腾了下设计模式把这两个概念给补上了，于是便打算写一篇文章记录下。 控制反转是什么？用单纯的语言肯定讲不清楚这个概念的，所以，我们先来看一段代码吧： 首先我们先看一下上面的代码，玩家要玩游戏，但是玩家并没办法仅靠自己完成这个操作，需要借助一台电脑，此时电脑就称之为 依赖，而玩家操作电脑玩游戏的过程就称之为 控制。 不过随着科技的进步，手机游戏逐渐的取代了部分桌面游戏，该玩家也因为各种广告的熏陶逐渐想玩某款手机游戏了，不过玩家发现自己已经和电脑 “绑定” 在一起了，如果要更换设备就需要修改内部的代码。不过这样以后就不能再使用电脑，作为一个重度电脑依赖的玩家这怎么能接受。 那么有什么方法可以解决这个问题吗？有的，那就是把 控制反转 过来，将 依赖，也就是设备动态的赋予玩家，玩家不控制设备的创建和销毁，玩家只负责使用设备，如下代码： 依赖注入是什么？从上面的代码可以看到设备是动态传入的，当需要更换设备的时候就只需要更换传入的参数即可，而不需要修改玩家类，而将参数传入到类的过程就称之为 依赖注入。 常见的依赖注入的方式有三种： 构造器注入 接口注入 设置属性注入 上方代码使用的就是 构造器注入 的方式。 依赖注入可以解决依赖需要切换的问题，解决各部件之间的强耦合问题。但是依赖注入也有个麻烦，如果依赖项太多了怎么办？每次使用的时候都需要创建一堆的依赖，并设置这些依赖： 可以看到这样的代码并不优雅，还会加大对象创建的难度和复杂度，这种情况可以使用工厂模式来解决： 工厂模式解决了创建对象复杂的问题，但是你会发现，这样就又回到了原点，对象的依赖就被工厂绑定了，当需要使用到其他依赖的时候工厂就无用武之地了。 IoC 容器那么还有什么的其他的方法能解决依赖注入的问题吗？答案是使用 IoC 容器。那么什么是 IoC 容器呢？我们可以把 IoC 容器 看成一个 仓库，里面存放着 依赖项，在运行的时候 注册绑定 一些需要用到的依赖，当我们要使用的某个对象的时候，直接 提取制造 一个出来即可，容器内部会自动创建并注入依赖。 反射反射是 IoC 容器实现的关键，通过反射 IoC 容器就能知道类或者方法用到了哪些依赖，知道了需要使用的依赖后就可以到依赖列表中进行查找查找完成后就可以将依赖赋值给对应的类和方法。 举个例子说明下吧： 可以看到代码中通过 PetShop 的反射类获取到了构造器的参数列表，并且通过反射参数获取到参数的类名，此时就可以通过类名创建对应的依赖，最后再使用反射类实例化出对象。 容器代码首先先贴代码： 这个 IoC 容器是给 XK-PHP 设计的，参考了 Laravel 的容器和网上一些代码改造而来，实现了大部分 Laravel 容器的功能，所以显得很复杂 2333。这里就大致讲一下流程。 容器创建后就需要调用 bind 方法绑定依赖，bind 方法再通过调用 setBind 方法完成对依赖的绑定，在 setBind 中会判断传入的 concrete 是否是闭包，如果不是闭包则 创建 一个闭包，之所以使用闭包而不是直接 new 一个依赖是为了达到懒加载的效果，如果直接 new 一个依赖其实就变成了单例模式了，单例模式的实例是不会变化的这样也就没必要使用容器了。 完成依赖的绑定后，当我们需要使用到某个对象的时候，就需要调用 make 方法，make 方法会 运行 对应对象的闭包，闭包的返回值就是当前对象的实例，这个闭包可以自行设置，也可以使用 默认的闭包，在默认的闭包中会调用 build 方法来构建实例，构建的流程其实就是上面反射一节中的流程，在 build 方法中会调用 injectingDependencies 方法来处理要注入的依赖参数。若对应的依赖通过是通过外部传入的则直接进行 设置。若需要的依赖是一个类，则调用 resolveClass 方法来处理类依赖，由于依赖可能还需要使用到其他依赖，所以需要调用 make 方法来进行递归处理依赖。如果需要的依赖不是一个类，则通过 resolvePrimitive 方法来处理依赖，查找的方式是使用变量名的方式，如果容器中有绑定对应变量名的依赖则 注入 对应的绑定，如果没找到绑定的变量，那么就看看有没有 默认值，如果默认值也没有，那么就抛出异常。如果一切正常那么最终就会 实例化 对应的对象。 当然，有依赖注入类的，自然也有注入函数或方法的，具体这里就不讲了，过程和注入类类似，相关的代码见 Github 结语总算写完了，又是一篇水文呢 o(^▽^)o，不知道大家有没有看懂呢？文中可能有错误或不足之处，如果您发现了问题欢迎反馈。[]~(￣▽￣)~*"},{"title":"中间件实现 [PHP]","date":"2020-03-29T13:46:40.000Z","url":"/middleware-implementation-with-php.html","tags":["PHP","Middleware"],"categories":["折腾记录"],"content":"中间件是什么？要实现中间件，首先就需要知道中间件是什么。中间件是很多 PHP 框架中都提供的功能，中间件提供了一种方便的机制过滤进入应用程序的 HTTP 请求。这么说可能会比较抽象，我们就举个具体的例子吧。 比如某个商城应用，当用户把商品加入购物车的时候和购买的时候，我们需要验证用户是否已经登录，传统的方式是在执行每个业务之前判断是否登录，如下演示代码： 可以看到，当需要验证用户的时候就需要写重复的代码，那么我们为什么不把验证的部分另外抽出来呢，如下： 可以看到这样遇到相同需要验证的时候就不再需要写重复的验证代码了，而这种做法其实就是中间件的思想，抽离出来的验证登录就是一个中间件。有了中间件我们就可以这些操作，比如权限验证、CSRF验证等等都写在中间件里，然后通过使用不同的中间件组合不仅能够实现需求还降低了代码的耦合度。 中间件比较常见的中间件模型有两种，一种是洋葱模型，一种是切面模型，其实这两个可以看成是一种，不过分开来比较好理解 2333。 左：洋葱模型，右：切面模型 这两个图看起来是不是有点吓人，切面模型其实还比较好理解，洋葱模型看起来就有点懵了，是不是有点像函数的嵌套调用 Middleware2(Middleware1(App()))？其实这并不是这样的，因为函数的嵌套调用是先执行内层的函数，然后才会执行外层的函数。若你经常使用回调函数方式的编程，那么你就能发现这其实像闭包嵌套： 优雅的实现可以看到上面的实现是写死的，如果要增加或者动态使用中间件就极为麻烦，所以我们需要对其进行改造，改造成可以动态调用的中间件。这也是我在 XK-PHP 中使用的方法。 这段代码如果不熟悉闭包的看起来可能有点懵，不过仔细理解下就很简单了。 在中间件的类中有一个 handle 函数用于处理请求或响应，外部向该函数传入了一个 $next 闭包，这个闭包其实就是后续的 中间件 和 App 的打包成的 闭包。通过循环就可以不断的组成新的闭包，合并所有中间件后就可以执行了，此时只需要执行最终的闭包，最终的闭包会不断的嵌套调用 $next 闭包，直到最后的 App 其实就是个递归的过程。不过我这里干讲也无法讲清楚，最好还是要利用 IDE 一步一步调试才能更好的理解。 更优雅的实现第二个实现虽然已经很好了，但是并不符合 PSR-15 的标准，所以如果要更优雅的方式来实现中间件的话需要按照 PSR-15 的标准来实现，这样就可以复用 PSR-15 的中间件，并且也符合 PSR-7 消息接口的规范。具体的代码这里就不贴了，请移步 Github 查看。"},{"title":"告别 Windows 终端的难看难用，打造好用的  PowerShell","date":"2020-03-14T10:00:32.000Z","url":"/say-goodbye-to-the-ugly-and-hard-to-use-windows-terminal-and-build-a-good-powershell.html","tags":["Windows","PowerShell"],"categories":["折腾记录"],"content":" ?超长文和多图警告，流量少的同学和时间紧张的同学请注意 2333。 不知你有没有使用过 Linux 上的 oh-my-zsh？用过后你一定会惊叹，黑乎乎的终端也能变得这么好看，还有各式各样的的插件提升着终端的使用效率。不过，我们平常编程的时候一般是使用 Windows，那么 Windows 也能把 PowerShell 打造成 oh-my-zsh 的样子吗？是的，这是可行的，本文将会讲述如何打造好用好看的 PowerShell。(下图为 oh-my-zsh，使用 ys 主题 美化有好的界面才能开心的使用命令行，正所谓颜值才是第一生产力（不是 (/▽＼)。 更换默认的 PowerShell 终端首先，我们要把默认的 PowerShell 终端换掉，默认的终端又丑又伤眼，而且调整的空间较小，为了得到更好的效果，我们需要把默认的终端换掉。 博主推荐使用巨硬（微软）最新推出的 Windows Terminal，虽然说设置相对麻烦（没有 UI），但是启动速度快，功能较为完整。当然你也可以使用其他终端，比如 Fluent Terminal，Terminus 或者 Hyper。 安装 Windows Terminal 的方法很简单，直接到 Microsoft Store 安装即可，本文采用 Scoop 来安装。 打开 Windows Terminal 我们可以看到其默认的样子： 是不是依旧很丑？别怕让我们来改造改造它。 配置 Windows Terminal点击标签栏的下三角，我们可以看到 Settings 的选项，按住 Alt 然后点击它，就可以打开 Windows Terminal（以下简称 WT）的默认配置，然后松开 Alt 再次点击它，就可以打开我们需要修改的配置文件，注意不要改动 WT 的默认配置文件，如需覆盖默认配置只需要在个人配置文件中新增或修改即可。 下面我只会举例部分字段的使用，如需完整的设置项可以到官方文档查看： Profiles.json Documentation Editing Windows Terminal JSON Settings 全局配置 Profiles 配置在新版 WT 中已经可以为所有的 Profile 设置默认配置，不需要再为每个 Profile 设置重复的配置了。 下面以 PowerShell 为例： 把之前的 defaultProfile 设置为某个 Profile 的 GUID，打开 WT、新建标签页时就会默认使用这个 Profile。否则就需要使用 + 号旁边的 下拉按钮 来开启其他非 hidden 的 Profile。 配色方案WT 自带了一些配色方案，如果其中某个配色刚好是你喜欢的配色可以直接使用，WT 自带的配色有：Campbell、Campbell Powershell、Vintage、One Half Dark、One Half Light、Solarized Dark、Solarized Light。 如果这些配色你都不喜欢，那么就可以到这个仓库 mbadolato/iTerm2-Color-Schemes 下载你喜欢的配色。 按键绑定按键绑定这里就不写了，因为涉及到很多 command ，WT 自带的按键已经基本够用，如果有需要的可以到 WT 的文档中查看。 右键菜单启动很多时候我们需要在文档管理器中直接启动 WT，此时就需要添加一个右键菜单启动项了。 新建一个 bat 文件，填入以下内容（注意修改成你的配置），然后以管理员运行该 bat 即可。 WT 部分小结至此 WT 部分就配置完毕的了，大致的效果如下： oh-my-posh光有 WT 肯定是不够的，使用一下你会发现，也就主题的颜色变了，外表变了，字体好看了，终端很多字符都还是白色，并没有像 oh-my-zsh 那么色彩斑斓。本节就来改造下 PowerShell（以下简称 Posh）。 zsh 下有 oh-my-zsh，Posh 下也有 oh-my-posh 可以做到和 oh-my-zsh 一样的外观。 本文一样采用 Scoop 来安装 oh-my-posh，同时也提供了 Posh 默认的方式安装。 安装完后，我们还需要配置下 Posh 才能使其变成 oh-my-zsh 的样子。 首先在 Posh 中输入 $profile 并回车，Posh 会输出你当前使用的 Profile 文件地址，打开该文件（若没有就需要新建），在该文件中写入以下内容。 重新启动后，你就会发现终端的样式变了几乎和 oh-my-zsh 的外观一样了，并且也有 git 状态的提示了： 注意：部分主题需要使用到 PowerLine 字体才能正确显示，若你要使用这些主题，请安装 PowerLine 字体并将 WT 的字体设置成 PowerLine 字体。 功能光有好看的外表可不行，还要实用才行，oh-my-zsh 中有很多插件可以增强 zsh 的功能，其中如 zsh-syntax-highlighting，zsh-autosuggestions 等，zsh-syntax-highlighting 的功能 oh-my-posh 已经可以实现了，但是能够极大提高效率的 zsh-autosuggestions，Posh 有没有类似的实现？答案是有的，PSReadLine，这个插件早就默认集成在了 Posh 中，只是该插件需要配置才能使用，而该插件就可以做到和 zsh-autosuggestions 或 fish 的自动查找历史记录并填充的效果。 PSReadLine配置PSReadLine 的配置较为麻烦，但是官方已经提供好了 样例 可以直接白嫖使用。 直接将样例配置复制到 $profile 文件中即可。 然后在 Import-Module PSReadLine 下增加一行： 使用介绍首先是类 Bash 选择菜单，输入命令的时候按下 Tab 键触发，再次按 Tab 可以在菜单中进行选择，如下： 然后是类似于 zsh-autosuggestions 和 fish 的历史记录搜索和补全，输入一半命令后可以通过上下键进行选择与前缀相匹配的历史记录： 其他功能还有右引号和右括号自动补全等功能，需要的可以自行查看样例配置中的注释自行尝试即可，功能很全面。 Git Bash 工具包有了一些增强功能，不过 Linux 终端的强大并不只有这些，还有其好用的 GNU 工具，虽然说 Windows 大多情况下可以用一些其他工具来做到和 GNU 工具一样的效果，但是偶尔也可能会用到这些 GNU 功能，那么 Windows 要如何安装使用这些工具呢？ Windows 上的 GNU 工具可以有很多方式来安装，比如 Cygwin，MSYS2，Git Bash，CoreUtils 等等，但是这里推荐直接使用 Git Bash 的即可，因为不需要在安装 Git 后多安装一套工具。 可是 Git 的 GNU 工具不是给 Git Bash 用的吗？Posh 要如何使用这些工具？如果你看过 Git 的 usr\\bin 目录你就知道了，这些 GNU 工具都是 exe 可执行文件，Posh 完全可以直接运行这些工具。要在 Posh 下使用这个工具，只需要将 Git 的 usr\\bin 目录添加到 PATH 中即可。 可是当你设置完后实际运行下你会发现，似乎并没有用，Posh 还是运行了 Posh 的命令 这其实是命令别名把 GNU 的工具命令覆盖了导致的，我们只需要删除这些 Posh 自带的命令别名即可。 利用 Get-Alias 命令就可以查看 Posh 中设置那些命令别名，这样我们就可以很方便的找出冲突的命令，并取消对应的命令别名。 找出冲突的别名后就可以用 Remove-Item alias:\\&lt;command&gt; 删除命令别名了，比如我删除了以下的命令别名： 再次运行 Posh 你就会发现被覆盖的 GNU 工具可以正常使用了 不过需要注意下，Git Bash 的 GNU 工具中并没有 wget，如果要使用 wget 可以另外下载安装，这里就不写了。 结语完整的配置文件已放到了 Gist 中你可以参照我的配置文件修改使用：windows-terminal-profile.json posh-profile.ps1 又是一篇长文，肝了一个下午，总算把 Windows 终端的配置给讲完了，写这篇的目的有两个，一个是给直接的踩坑留下记录，方便以后重装系统之类的使用，二是希望受 Windows 终端使用苦恼的同学们一点微小的帮助。 其实 Posh 还是很好用的，甚至比 zsh bash fish 等命令行好用，只是生态没有这些好，社区中好用的工具插件不如这些命令行多。[]~(￣▽￣)~*"},{"title":"VSCode Java输出中文乱码问题解决[更新]","date":"2020-03-13T09:29:00.000Z","url":"/vscode-java-output-chinese-garbled-problem-solving.html","tags":["Java","VSCode"],"categories":["折腾记录"],"content":"重写了下这篇文章，官方默认的配置可以正常输出中文，但是输入还是会造成乱码，经过了不少时间的尝试，终于把输入和输出乱码的问题解决了。 本文适用于Windows，Linux中应该不会出现这种问题。 首先先说明下此方法需要更改 VSCode Java 插件的 launcher.bat 启动文件，可能会在后续的使用中带来问题。 前言前几天由于要写OJ题我又打开了尘封已久的 VSCode Java 工作区，使用过程中遇到了中文乱码的问题，照理说应该是不会出现这种问题的，因为我当初在配置Java环境的时候就已经解决了中文乱码的问题。然后一直懒得修，直到今天有空。 博主我原先是将 JDK 的编码和 Java 文件的编码都设置为 GBK，这样在运行的时候就不会出现中文乱码的问题，不知从那个版本开始这种方式就不可行了，于是只能重新的测试。 方案首先，先创建一个项目，然后创建一个 Java 文件用于测试，注意：该文件的编码应使用 UTF-8，上传到 Linux 也方便，不用再批量改编码。 然后创建一个 launch.json 的启动文件，操作方法如下： 正常情况下 VSCode 会自动生成一个可用的 launch.json 文件，直接使用此配置可以正常输出中文，但是无法正常输入中文，如下： 此时，我们将修改下 launch.json 的配置，增加 &quot;encoding&quot;: &quot;GBK&quot; 字段，如下： 此时再运行你会发现，输入和输出都不行了，此时不要担心，请接着进行以下配置即可。 下一步就需要修改 launcher.bat 文件了，请在修改前备份下该文件。launcher.bat 位于 VSCode Java 插件目录下的 scripts 目录，也可以按住 Ctrl 然后点击之前启动时 VSCode 的启动脚本的 launcher.bat 直接跳转到该文件。 打开该文件后将 `@chcp.com 65001 &gt; NUL修改成@chcp.com 936 &gt; NUL` 然后再次运行，你就可以看到输出和输入都正常了 结语现在已经我不写需要用 Scanner 的项目了（其实是不用写 OJ 题了）不过看到该文章有挺多人浏览的，大家都遇到了这个问题，之前写的确实比较水，并没有解决输入乱码的问题，这次更新了下，希望此篇能帮助到其他同学。"},{"title":"浅谈浏览器渲染","date":"2020-03-06T13:36:11.000Z","url":"/talking-about-browser-render.html","tags":["Web","浅谈"],"categories":["折腾记录"],"content":" 好久没写理论性较强的文章了。最近刚好正在了解浏览器的工作原理，于是打算写一篇文章来加强下，输出才是最好的输入嘛 hhhh。 什么是渲染？在计算机图形学的领域 渲染 是 render 的翻译，看到这个词，写过 React 的开发者应该很熟悉，在 React 中 render 函数做的是将 数据 变成 HTML 代码 的工作。而在图形学中 render 指的是由 模型 生成 图像 的过程，同理在浏览器中 render 做的就是将 DOM 绘制成我们可以看到的 网页。 在谈真正的 渲染 之前，我们需要先了解 布局树 是如何生成的，有助于更好的了解后续的渲染过程。 加载当用户开始访问一个页面的时候，浏览器就会向服务器请求资源，当网络进程从服务器获取到数据的时候，就会将数据发给渲染进程的 HTML 解析器进行解析，这个过程是实时的，也就是说网络进程收到多少数据，HTML 解析器就解析多少数据，而不会等网络进程收到所有数据后才解析 HTML。 解析DOM当渲染进程收到 HTML 字节流 的时候，就会调用 HTMLParser 把 HTML 解析成 DOM 树，具体流程见下图： 渲染进程收到字节流时会根据指定编码（UTF-8 等）把字节流转换成字符串，也就是我们写的代码。而渲染引擎是无法直接理解和使用代码的，所以需要将 HTML 转换为浏览器能理解的结构，即 DOM 树。 要将 HTML 转换成 DOM 树还要经过词法分析，将 HTML 转换为 Tag Token 和 文本 Token，例子如下： 分词完成后，就需要将 Token 解析成 DOM 节点，并将其添加到 DOM 树中，解析的过程这里就不写了，最终生成的 DOM 树如下所示： CSSOM和 HTML 一样，渲染引擎也是无法直接理解和使用 CSS 的所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。浏览器解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含 CSS 规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。 当 CSS 转换成浏览器可以理解的结构的时候，那么接下来就要对其属性值进行标准化操作。CSS 中一般都有各种各样的单位，如 rem em blue bold 等，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。具体样例见下图： 样式已经标准化了，下一步就是计算 DOM 树各个节点的样式和属性了。 首先是继承，CSS 中部分样式是可以被子元素继承的，这些可以继承的属性应该同时添加到子元素的样式中。然后是层叠，层叠是 CSS 的一个基本特征，它是定义了如何合并多个不同来源的样式的算法。CSS 的全称即层叠样式表即说明了层叠这个特性在 CSS 中的重要地位。 最终生成的 CSSOM 如下： 布局树有了渲染引擎可以理解的 DOM 树 和 CSSOM 树，就可构造成最终要绘制的布局树了。 为了构建布局树，浏览器大体上完成了下面这些工作： 遍历DOM树中的所有可见节点，并把这些节点加到布局中； 而不可见的节点会被布局树忽略掉，如head标签下面的全部内容，再比如属性包含 dispaly:none 的元素等等。 布局计算 &amp; 分层此时，渲染引擎就可以根据这个布局树来绘制网页了，但是在绘制之前，还需要进行节点的布局计算，布局计算首先需要计算出各个节点的位置坐标，但是只有坐标还不够，因为页面中还有复杂的变化、滚动、层叠和 z-index 排序等等的情况，浏览器为了实现这些就需要创建图层，就像用 PhotoShop 绘图一样，最终这些图层才构成了我们所看到的页面图像。Chrome给我们提供了很好的开发者工具，我们可以通过Chrome的开发者工具来查看网页的图层信息，如下（博主使用的是 New Edge）： 从工具中我们可以清晰的看到图层是如何放置并最终形成了我们所看到的页面。具体的分层这里就不说了，有兴趣的可以自行查阅。（￣︶￣）↗ 绘制完成上面的步骤后，渲染引擎就可以绘制每个图层。渲染引擎绘制页面的方式其实和写 SVG 矢量图一样，都是从基本图形开始绘制的，渲染引擎会把图层拆分成很多小的步骤，然后提交到合成线程逐一进行绘制，剩下的步骤就是光栅化、合成和显示，最终就形成了我们所见到的页面，这里就不写了（因为我也不太懂这些计算机图形学的东西 2333 重排 &amp; 重绘 &amp; 合成重排，顾名思义，即重新排列，我们经常能在各种文章中看到重排的开销很大，重排的开销很大是因为它会改变页面的布局，改变页面布局就需要重新计算布局，分层以及绘制，经过了很多子阶段。所以我们在写代码中应尽量避免重排，任何会改变元素的位置或尺寸大小的操作都会触发重排。 重绘，即重新绘制，不同于重排，重绘并没有改变布局，所以重绘的可以跳过计算布局和分层的步骤，而是直接进入绘制，所以执行效率会高上一点。任何改变元素颜色，显示效果的操作都会触发重绘。 合成，合成是跳过主线程的布局计算，分层和生成绘制列表的部分，直接发由合成线程进行合成操作，相比重排和重绘，合成效率是最高的。使用 CSS 的 transform 来实现的效果触发的是合成。 阻塞渲染在进行分析阻塞渲染之前我们需要知道以下几点： 布局树依赖于 DOM 和 CSSOM，当 CSSOM 未加载完成的时候浏览器不会构建布局树和绘制页面 JavaScript 有操作 DOM 和 CSSOM 的能力 当 HTML 解析器解析到 script 标签的时候，此时 HTML 解析器会暂停对 DOM 的解析和构建，因为 JavaScript 有可能会更改 DOM 的结构，如果不暂停 DOM 解析就有可能导致更新丢失的情况出现。HTML 解析器需要等到 script 标签中的 JavaScript 代码执行完毕才会恢复解析，但是通常我们会通过引入 JavaScript 文件，在执行这个 JavaScript 之前需要先下载 这个 JavaScript 文件，而在下载的过程中 DOM 的解析和构建就被阻塞住了，一般情况下，下载是非常耗时的。所以我们就应该要尽量将 script 文件放置于 HTML 文档的末尾，防止造成过长的白屏。 说完了 JavaScript 的情况我们来说说 CSS，由于 CSSOM 和 DOM 的构建是独立的，所以在只有 HTML 和 CSS 的页面中，CSS 并不会阻塞 DOM 的构建。但是，如果在页面中包含了 JavaScript 那就有所不同了，当解析到了 JavaScript 脚本的时候，DOM 的解析和构建会暂停，此时 JavaScript 引擎会开始执行 JavaScript 代码，但是由于 JavaScript 拥有修改 CSSOM 的能力，那么在执行 JavaScript 代码之前，就需要将 CSS 解析成 CSSOM，也就是所 CSS 在部分情况下也会阻塞 DOM 的解析和构建。 不过，现代浏览器都提供了预解析的功能，在 DOM 的解析和构建被阻塞的时候，解析器会停止构建 DOM，但是仍然会继续解析后面的资源，当解析到需要从网络中获取的资源，浏览器就会预加载这些资源。 下图可以大概体现执行的顺序，不过图画的不太准确，请不要认为这就是真正的执行流程。 结语至此文章就讲完了浏览器渲染的流程，希望大家能有所收获，写出更好的代码，本文是博主通过阅读一些网络文章结合自己的理解写成的，所以可能会有一些错误之处，如果您发现了文章的错误欢迎留言纠正。[]~(￣▽￣)~*"},{"title":"Vue-Cli@2 项目迁移日志","date":"2020-02-21T07:37:03.000Z","url":"/vue-cli2-project-migration-log.html","tags":["Vue","Web"],"categories":["折腾记录"],"content":"前不久刚把 XK-Editor 的项目结构改成了 Vue-Cli@4.x ，前端项目的变化真快呀， XK-Editor 是去年初创建的，当初的 Vue-Cli 似乎才刚要发 3.x ，然而现在已经 4.x 了。之所以要升级 Vue-Cli@4.x 是因为随着 webpack vue 等包的升级，有一些配置已经不一样了，而且也产生了一些兼容性的问题，比如 `sass-loader@8.x需要webpack@4.x，而如果直接将webpack升级到4.x` ，则会引起一连串的问题。所以升级 Vue-Cli 也是为了减少麻烦。 项目结构 标注的文件或文件夹是各自版本特有的，在 3.x+ 中 vue.config.js , babel.config.js 和各种 config 文件替代了build config 中的配置文件以及 .babelrc .postcssrc ，这有点类似于 React 未 eject 化的项目结构 迁移方式在迁移中， package.json 的迁移是最难解决的，我个人推荐的方式是用 vue create 创建一个项目，在创建项目的时候选择需要的模块，比如 XK-Editor 需要使用到 sass ，那么在创建的时候选中相应的模块，创建一个临时的项目文件，这样我们就可以较为轻松的得到 `Vue-Cli@3.x+的package.json` 文件。 如果你没有添加过 devDependencies ，那么就可以将原项目的 devDependencies 直接用创建好的 package.json 文件覆盖 将创建的 package.json 的 dependencies 添加到原项目的 package.json ，同时替换 scripts ，此时 package.json 部分就完成了。 然后我们就可以开始迁移各种配置文件了，将创建的项目中的各种 [name].config.js 复制到原项目中，如果有配置过对应的配置则需要修改对应的配置文件。 创建 vue.config.js 文件，修改对应的配置，如果不需要配置 webpack 可以不用创建，比如 XK-Editor 需要使用到 webpack externals 则需要配置 vue.config.js 接着，我们就可以移动静态文件了，首先在项目中创建一个 pulic 目录，在 `Vue-Cli@2.x的静态文件是放置于 static 文件夹下的，而Vue-Cli@3.x+取消了 static 文件夹，转而使用public文件夹，如果不想重新设置静态文件的 URL 则可以将static直接拖动到public目录中，然后将index.html拖动到public` 中。 如果需要使用 test 则需要将原项目的 test 文件夹重命名为 tests 。 最后，我们就可以开始测试项目能否正常工作了，首先删除原本的 node_modules 文件夹，然后运行 npm install 或者 yarn 安装依赖，安装完后使用 npm start 或者 yarn start 运行，此时会有很大的几率会遇到以下提示。 出现这种情况只需要修改下 main.js 文件中的 new Vue 即可 最后，清理下原项目，按照前面的项目结构图圈出的部分删除文件或文件夹即可。"},{"title":"Laragon & Scoop 集成踩坑记录","date":"2020-01-24T11:51:19.000Z","url":"/laragon-scoop-integrated-pit-logging.html","tags":["Windows","Laragon","Scoop"],"categories":["折腾记录"],"content":"作为一个 PHPer ，在开发中一定是离不开 PHP 开发环境的，在 Windows 下有各式各样的 PHP 开发环境，比如 Laravel Homestead ， XAMMP ， PHPStudy ， Laragon 等。博主我选择使用 Laragon 是因为不太喜欢虚拟机开发环境以及 Laragon 较为简洁等因素。原本是采用 Chocolatey + Laragon 管理 Windows 下的软件环境的，普通软件使用 Chocolatey 装，开发用的软件使用 Laragon ，但是在前不久换成了 Scoop ， Scoop 的管理软件的方式不再是 Chocolatey 的原生安装式了，之前的 Scoop 有提到过可以利用 Scoop 来管理 Laragon 中的开发环境，这次就完整的介绍下。 思路Laragon 的开发软件都存放于 Laragon 下的 bin 目录，结构与 Scoop 的 apps 目录一样，都是一个软件放置于一个文件夹，然后在目录下放置多个版本。结构一样我们就能利用软链接或者硬链接将 Scoop 的软件目录 apps 链接到 Laragon 的 bin 目录，这样 Laragon 就能直接使用 Scoop 中安装的软件。 踩坑有开发者已经写了 PowerShell 脚本了我们可以直接使用，不用再自己折腾链接 首先安装 Scoop 和 Laragon 以及该 Module （安装 Scoop 的方法见上一篇文章， Laragon 可以无脑下一步） 安装完后就可以直接使用 inla 和 unla 安装卸载 Laragon app 了 如果安装的软件在 Laragon 已经存在就需要先将 Laragon 对应软件的文件夹删除，删除后才能使用 inla 命令来安装，另外注意 PHP 版本应选择 NTS 版即线程非安全版，否则可能会遇到 PHP 无法正常工作的问题。 今天又折腾了下Scoop，又遇到了不少问题，2333，也分享出来吧。 Scoop 中安装的 PHP 中会包含一个 cli 文件夹，该文件夹是持久化的，也就是说升级了 PHP 版本后不需要再重新配置 ini 文件， cli 中的 php.ini 和 conf.d 的 custom ini 会覆盖PHP根目录下的 ini 文件，同时若直接用 Scoop 安装插件，如 xdebug ，则会和 Linux 中了 PHP 读取配置的方式类似，利用模块化的 custom ini 载入配置。而 Laragon 默认不是采用模块化的 ini 加载的，会导致 Laragon 不能使用 Scoop 安装的 xdebug 。那么如何让 Laragon 也使用模块化加载 ini 文件呢？其实很简单，只需要修改 LARAGON\\etc\\apache2\\fcgid.conf 文件即可，在 #Location php.ini: 下添加以下配置，然后重启 apache 即可 "},{"title":"「一行代码」优雅管理 Windows 软件","date":"2020-01-22T10:02:38.000Z","url":"/one-line-of-code-elegantly-manages-windows-software.html","tags":["Develop","Windows","Scoop","包管理器"],"categories":["折腾记录"],"content":"想必小伙伴们苦恼 Windows 下没有和 Ubuntu 等 Linux 下方便的包管理吧，不过经过较长时间的体验我觉得 Scoop 可能是 Windows 上体验最好的「包管理器」。 那么如何安装 Scoop 呢？首先你需要打开 PowerShell ，然后输入以下命令允许执行本地脚本。 然后运行以下命令安装 Scoop 静待脚本执行完成就可以了，安装成功后，让我们尝试一下： 这说明了 Scoop 安装成功了，通过 Scoop 安装的软件默认会位于 C:\\Users\\&lt;user&gt;\\scoop 如果是安装到 global 环境的是 C:\\ProgramData\\scoop。 Scoop 安装成功后我们就可以利用它来安装其他软件了，Scoop 的命令和 Linux 下的包管理器非常类似都是「scoop + 动作 + 对象」的语法，比较常用的动作主要是以下几种操作。 Scoop 常用操作? 搜索，比如我们不清楚 Scoop 中是否有我们想要的软件或者不清楚 Scoop 中软件的名称，就可以使用 scoop search &lt;app&gt; 来查找软件。 ? 查看软件相关信息，当我们通过搜索找到软件的名称，但是不确定是否是该软件的时候，我们就可以通过 scoop [info|home] &lt;app&gt; 进一步确认软件 ? 安装，确认软件了，我们就可以开始安装了 scoop install &lt;app&gt;，注意：Scoop 偶尔 可能会因为网络错误安装失败，但是 Scoop 会显示已安装，这时可以用 scoop uninstall &lt;app&gt; 卸载，然后再次安装 ? 卸载，安装后如果不喜欢这个软件怎么办？当然是卸载呀，那么 Scoop 如何卸载呢，很简单 scoop uninstall &lt;app&gt; 即可完成卸载，不过作为 Debian Apt 党怎么可能喜欢 uninstall ，remove 走起(。・∀・)ノ ? 升级，那么软件有新版了如何升级呢？用 scoop update &lt;app&gt; 就可以了，那我要一键升级所有的软件呢？用 scoop update * ，或者可以添加 upgrade 的别名，那我的一个软件不想升级怎么办？可以利用 scoop hold &lt;app&gt; 放置某个软件更新 ? 清除旧版本，升级后 Scoop 并不会自动删除旧版本，而只是将当前版本切换到新版，当我们需要删除的时候就可以使用 scoop cleanup [&lt;app&gt;] 清除旧版本 ? 切换版本，有时候我们需要使用到旧版的软件怎么办？比如 Python3 和 Python2 的切换，这时我们可以用 scoop reset &lt;app&gt;@&lt;version&gt; ? 检查状态，有时候我们不想直接升级，而是想看看是否有新版本，或者有的应用安装失败需要重新安装的我们没注意到怎么办？用 scoop status 就行啦 ? 列出已安装软件列表 ? 添加软件源，当我们需要的软件不在列表中怎么办？这时我们就可以看看有没有软件源中包含了我们需要的软件，Scoop 的软件源称之为桶 bucket ，在 rasa/scoop-directory 上可以找到所有的 Scoop 桶，添加桶 scoop bucket add &lt;bucket_name&gt; &lt;bucket_url&gt; ，删除桶 scoop bucket rm &lt;bucket_name&gt; ? 清除缓存 ? 别名，有的时候，我们不喜欢 Scoop 的某些命令，比如 scoop uninstall &lt;app&gt; 怎么办？可以添加别名来解决 scoop alias add &lt;name&gt; &lt;command&gt; &lt;description&gt; 结语至此你应该能很好的使用 Scoop 来管理你的 Windows 软件了。 Windows 下还有一个 Chocolatey 这个包管理器，为什么不使用 Chocolatey 呢？毕竟它毕竟全，若你用过了 Chocolatey ，你一定会苦恼 Chocolatey 乱放软件，一会儿 C:/tools 一会儿 C:/Program Files ，这是因为它是使用传统软件安装的方式来安装软件了，只是将找软件，下软件，删软件的步骤省掉了而已，并没有解决放置软件的问题。Scoop 的 Wiki 有 完整的对比 对了，若你也是 Laragon 的使用者的话我后续会发布将 Laragon 和 Scoop 集成的文章，如果等不及也可以直接上手 star2000/scoop-ext-laragon"},{"title":"[青空之蓝-2019]-年度总结","date":"2019-12-31T13:53:48.000Z","url":"/my-blog-2019-year-end-summary.html","tags":["年度总结","博客记录"],"categories":["站长杂谈"],"content":" 又到了一年一度的年底，转眼间又过了一年，2018似乎才刚过，2019就已经即将结束。原本打算从前几天开始写的，但是由于要应对毛概考试，所以没空写，今天考完了，是时候水一篇年度总结了。 音乐和图片随便挑的，我比较菜就没办法同大佬们自制海报和精心挑选配乐了。 [hermit autoplay=”false” mode=”auto” preload=”auto” ]netease_songlist#:443242[/hermit] 往事2019发生了许多事，虽然不够精彩，但也算不平凡的一年。2018刚进入大学，虽然说之前有稍微接触过编程等技术，大一也学了不少知识，但是还只能说是新手，甚至可以说未入门的菜鸡。从2019开始，我逐渐转变了学习策略从深入学习改变成广泛学习，即广泛折腾和学习各种技术，方向也比较明确就是Web端，广泛学习也产生了不小的成效，使我的眼界不再狭小，也在一定程度上提升后续深入学习的效率。 2019博主我开发了3个项目，一个是Origami主题，一个是XK-Note，以及XK-Editor，早期的代码水平和质量实在不忍直视，都只是处于能用的状态，各种Bug百出，但也算是几次不错的实践。经过了半年的学习终于将3个项目的代码改到了能看的地步。其中Origami v2和XK-Note v2可以说是完全重写的。 在2019我主要是折腾和学习前端方面的技术（原本是打算先学后端的，最后还是发现前端比较好玩，逃），明年打算转变学习的主要方向了，深入的学习后端技术。 站点我这菜鸡的站点就没其他大佬们那么亮眼，除去丢失部分统计数据（大概半个月的数据），博客和个人主页共被访问了20,012次(UV)，浏览38,940次(PV)，平均停留时间2分3秒，可以说是非常菜了，隔壁大佬们一个月的流量说不定就比我一年的高了。由于去年并没有部署访问统计，所以也没法与去年对比，但可以知道的是今年的访问量比去年翻了一倍不止，一是博客多篇VSCode相关的文章在多数搜索引擎的排名较高带来了许多流量，二是Origami主题的发布也带来了不少流量。 博客今年也崩了挺多次的，不是服务器被墙就是上游提供商的网络爆炸。同时也更换了两次主题（Origami v1，Origami v2），同时也利用CI每天将本站转换成Hexo备份到Github。个人主页也重写了一遍，原本是打算随便找个模板改改，最后还是参考了部分设计完全从零开始写。。。同时也为主页和博客重写了WorkBox规则，使博客支持全站缓存了。 友人今年新增了6个友链，也认识了更多的大佬了，同时也认识了许多有趣的人，在这里真心的感谢大佬们一直以来对我的帮助，帮助我这个辣鸡解决各种问题。 同时也感谢能与我共度互联网的朋友们。 技术2019年由于我是广泛学习，所以学到的技术非常杂，同时也只是皮毛，新开这个板块是为了检查一下一年来的成果和发现不足。 前端部分，2019主要是学习前端的框架，学了React和Vue，以及“过时”的jQuery，同时也深入的学习了浏览器的工作原理和JS的运行原理等。也“熟悉”了JavaScript，CSS和HTML。 后端部分，由于我们有数据库和数据结构与算法的课程，于是便自己扩展知识范围，通过某平台的专栏学习的数据结构与算法和数据库，顺便也看了网络协议，但是并不是特别了解，后续还需要重学一遍。也学了Laravel框架，其实也不算学，只能算学如何用，稍微接触了下Spring。 运维部分就相对少了，今年似乎只学了Docker如何用。。。学会了如何操作容器，如何build容器，以及Docker的工作原理（表层而已）。Kubernetes还没看过。。。 哎，今年似乎也只学了这么点东西。我太菜了，看来还需要非常努力才能看到大佬们留下的脚印啊。（逃 项目总结下今年开发的项目，其实是推广（逃 ? XK-Note | 一个集各种神奇功能的云笔记 ? XK-Editor | 一个支持富文本和Markdown的编辑器 ? Origami | 一个拥有许多强大功能，简洁，轻快的WordPress主题 其他请前往 XK-Lab 查看 未来未来，未来该做什么呢。。。其实我现在还不是很清楚，所以就不写了吧。 尾声这篇年度总结写了估计有2个小时吧，2019发生了太多事了，hhh。 2020博客应该不断会有文章水文产出，愿本站的文章能帮助各位来本站做客的访客们。 2020望一切顺利，祝各位新年快乐。 "},{"title":"为Vue添加简单的Store","date":"2019-12-03T04:50:44.000Z","url":"/add-simple-store-for-vue.html","tags":["JavaScript","Vue","Vuex"],"categories":["折腾记录"],"content":"前言没错，我又来水文章了，Vue的简单Store其实比React的简单Store更早就制作好了并已用在了XK-Editor@1.3.0上，只是没有写到博客上而已，这次正好写了React的简单Store，顺便就把Vue的也补上。至于为什么要用Store或者为什么不用Vuex，其实和React的差不多，这里就不说了，如果不了解可以移步上一篇 为React添加简单的Store 分析Vue的简单Store和React的差不多，只是React改变State的叫Reduce，Vue叫Mutation，同样简单Store并不需要这部分来增加代码的复杂性，在Vue的官方文档的状态管理中有说明如何创建一个简单的Store，但是那个例子并不够完整，而且需要挂载到根节点data中，访问也过于复杂需要使用this.$root.shareState冗长的访问方式，所以我们需要改进这部分来提高Store的实用性。参照Vuex的使用方式我们可以同Vuex一样添加mapState和mapActions来进行简单的调用，由于Vue提供了Vue.observable的方法来创建响应式数据，所以我们就不需要将Store挂载到根组件，而是可以和组件分离独立的工作。 实现首先，我们需要引入Vue，同时初始化State和Actions 然后我们需要编写对应的map方法，同时将map方法导出 由于该Store制作较早，所以并没有考虑到添加打印State变动，如有需要可以参考React的方式添加debug输出。 那么，如何使用呢？同Vuex的使用方式，在对应的组件中导入Store的map方法，然后就可以同Vuex一样对State和Actions进行操作了 "},{"title":"为React添加简单的Store","date":"2019-11-29T17:08:02.000Z","url":"/add-simple-store-for-react.html","tags":["JavaScript","React"],"categories":["折腾记录"],"content":"前言前几天打算使用React开发一个博客系统，由于有许多数据都是要共用的，比如Tags，Categories等，而React相比Vue会组件嵌套的情况会更严重，如果将数据一个个转发势必会造成代码逻辑过于复杂，耦合度过高，所以，我们需要全局状态管理。React有一个好伙伴Redux，Redux是一个用于应用程序状态管理的开源JavaScript库。但是Redux相对复杂，需要编写太多模板代码，而博客系统这种轻应用并没必要使用Redux。这时就需要自制一个简单的Store来管理全局状态。 分析在正式编写代码之前我们需要先分析一下我们的Store需要什么功能，以及结构。 首先Store需要有State来存储数据，Action来触发全局的事件，以及对State的更改，我们并不需要Reduce，有Reduce可以很好的分辨State的变动，但是我们的应用并没有这么复杂，所以并不需要多一步Reduce来改变State。 由于我使用过Redux和Vuex，通过对比可以发现Vuex的Action调用相对简单灵活，但是并不能很好的应对同步的场景，所以为了后期的开心编码，我们需要结合二者的一些优点。 React在16.x添加了Context，使得我们在组件树中传递数据能够简单的实现，我们只需要将root组件的状态作为全局状态通过Context传递下去即可。 实现首先，我们需要初始化State和Action，或许你会对下方的this感到疑惑，耐心看完下面的代码就能理解了。 然后我们需要导入initialStore并创建Context，同时导出Context，用于子组件 这时我们就能创建一个Store组件来存储和转发Context 使用Class组件的原因是为了将该组件的this绑定到Action上，这样Action就能通过this.state和this.setState操作读取State了，你也可以使用Hook来达到相同的目的，只是需要利用useRef来防止函数读取到旧的状态，使用起来比Class复杂，所以这里直接使用Class了。 改进使用全局状态管理在调试的时候不太容易跟踪状态的变化，所以我们需要在状态变化的时候打印变动信息，让调试更方便。 在setState注入输出日志，我们就能在控制台清晰的看到状态的改变，以及执行栈。 那么，如何使用呢？使用其实就是从Context提取出State和Action，把它们当成变量和函数执行即可 "},{"title":"为Vuex添加同步Action","date":"2019-11-16T16:10:43.000Z","url":"/add-sync-action-for-vuex.html","tags":["JavaScript","Vue","Vuex"],"categories":["折腾记录"],"content":"为什么要添加同步Action？在某些操作中，如获取内存中的数据时，需要立即返回对应的值，而Vuex的Action规定了只能返回一个Promise，这时，如果我们想获取返回值就需要使用then或者await，代码就会变得不直观，而如果触发Mutation再从State获取值也是同理，所以如何能让Action不是异步的又能保持和Vuex的Action拥有一样的功能呢？ 添加同步Action首先我们先看看Vuex的Action的结构是如何的： 可以看到，action中传入了context和data，所以我们添加的同步action也需要增加这两个参数，同时将store绑定到action的this。 在index.js导入对应的模块和同步actions对象，同时导出修改过的同步action，用于mapSyncActions，并为每个同步action绑定this和注入参数。 然后，我们还要实现对应的dispatch方法和mapActions方法，来实现调用该action，在index.js同级文件夹下添加一个syncActions.js 如果要在Vuex模块中使用，只需要导入syncActions.js然后同Vuex的action调用一样即可。 若要在组件中使用，只需要同mapActions一样使用mapSyncActions即可，或者使用dispatchSync。 结语说实在搞这个其实没啥用，因为用到的机会其实也很小，只是当初我把XK-Note重构到Vuex时，不想修改太多的代码逻辑搞出来的，本文的实例具体可以查看XK-Note。"},{"title":"浅谈B+树","date":"2019-09-28T17:15:40.000Z","url":"/talking-about-bplus-tree.html","tags":["数据库","数据结构","浅谈"],"categories":["折腾记录"],"content":"前言B+树（B Plus Tree）是MySQL数据库索引的底层数据结构，B+树也是一种平衡树和AVL树以及红黑树有着同样的性能，不用你说，我知道你肯定又个疑问，为什么数据库要使用B+树作为数据库索引而不是其他平衡树呢？为什么需要使用B+树呢？或许看完这篇文章你应该就懂了。 其他结构的问题数据库索引作为数据库中的重要组成部分，同时也是数据库性能的重要指标，数据库是索引必须拥有较好的性能，这包括执行效率（时间）和内存消耗（空间），在执行效率方面，我们希望通过索引，查询数据的效率尽可能的高；在存储空间方面，我们希望索引不要消耗太多的内存空间。 在以上的需求下，支持快速增删改查的数据结构除了B/B+树大概还有以下几种： 哈希表（Hash Table） 跳表（Skip List） 二叉搜索树（Binary Search Tree） 红黑树（Red-Black Tree） 平衡二叉树（AVL Tree） 首先看下哈希表，哈希表拥有O(1)的增删改查的性能，乍一看似乎是最适合作为数据库索引的数据结构。但是，数据库索引不止能等值索引还需要支持范围索引，而哈希表并不能提供范围索引的功能，所以哈希表不能胜任。 接着是跳表，跳表之前的文章介绍过了，这里就直接说它的理由吧，跳表的空间复杂度是O(nlogn)相比其他平衡结构差，而数据库需要应对的是大量的数据，需要大量的内存和磁盘空间，所以一般不采用跳表作为数据库索引的数据结构。 二叉搜索树在极端条件下会退化成链表，造成数据库性能不稳定的情况，而其他平衡树拥有更稳定的性能，所以不会使用二叉搜索树。 AVL树都是一种极为成熟的平衡树结构，维护AVL树的平衡是非常耗时的，AVL树适合用于插入删除次数比较少，但查找多的情况。而数据库有可能进行频繁的插入删除操作，所以不适合。 红黑树似乎是和B/B+树一样适合作为数据库索引的，但是为什么MySQL不使用红黑树而是采用B+树呢？首先红黑树并不太适合范围查找，还有其他的就在下面说明吧。 B+树B+树是什么样子的呢？首先为了支持范围查找，二叉树需要进行一些小改造：把数据都移到叶节点中，上层树结构只存储下层的索引。思路类似于跳表，但是上层索引使用的是树结构而不是链表结构。 除了执行效率和内存消耗的考虑，数据库索引还需要考虑其他一些东西：在海量的数据中索引应该存在哪？有些同学可能会说内存啊，但是内存真的能存下海量的数据索引吗？假如我们要存储10亿个字段，每个索引12B则叶节点大概需要11G，整个索引树内存占用不大于20G。20G对于一台服务器已经是不小的压力了，所以，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘IO操作。树的高度就等于每次查询数据时磁盘IO操作的次数。而磁盘IO操作又极为耗时，所以为了减少磁盘IO操作则二叉树需要进行改造，将层高减少，即使用N叉树。 这样的结构就可以减少对磁盘IO的操作次数，同时又保留了高效的增删改查效率，而这种结构就是B+树，数据由叶节点的指向，索引中在保留key，节省内存。 这时有人就会问这个N要设置为多少为才是最好的？我们知道磁盘是按一定大小读取数据块的，这个大小是一个固定值，通常是4KB，装系统中常说的4K对齐其实就是设置数据块的大小，为了防止读取一个B+树节点的时候多次操作磁盘，同时最大化的利用每个数据块，B+树的每个节点应尽量充满整个数据块，通过计算就可以得出N的大小。 B+树是如何维持平衡的呢？说了这么多，那B+树作为一种平衡结构肯定有一种方式来维持平衡，在跳表中是随机高度，在平衡树中一般是采用左右旋的方式维持平衡，那么B+树又是如何呢？ 当数据量庞大的时候势必会造成某个节点的大小超过数据块的大小，如何很好的解决这种问题？没错就是分裂，将一个节点分成两份，这样每一份就都小于数据块的大小了，就能保证每次读取一个节点只需要一次磁盘操作了。 那分裂又是如何进行的呢？我们知道叶节点才是存储数据的节点，其他上层节点只存储了key，但叶节点过大的时候节点进行分裂，分裂后数据的位置就不同了，所以还需要更新上层索引，当上层索引过大的时候就需要同叶节点一样分裂，直到分裂到根节点。 删除的时候就和分裂相反，当某个数据删除后节点中的数据数量少于某个特定的阈值的时候（通常是N/2）就需要与兄弟节点进行合并，合并后同样需要更新上层索引，若合并后节点过大的时候就应该同插入一样进行分裂，直到两个节点的大小处于合理的范围之中。 总算更完这篇文章了，溜了溜了。插图看看吧，有空再画 （逃 "},{"title":"浅谈跳表","date":"2019-09-14T14:51:29.000Z","url":"/talking-about-skip-list.html","tags":["数据结构","浅谈"],"categories":["折腾记录"],"content":"为什么使用跳表跳表是（skip list）Redis实现sorted set使用的数据结构，是一种平衡数据结构，其中常用的数据结构有：B树，AVL树，红黑树等，如果你了解过这些平衡结构，你或许会有个疑问，为什么要使用跳表？想象一下，给你一支笔，一张纸，一个编辑器或者IDE，你能在短时间内写出一个红黑树或者AVL树？这很难吧。而跳表，我们只需要对链表稍加改造就可以支持快速增删改查，使用类似于二分搜索的查找算法，而这种数据结构就是跳表。它的效率和红黑树以及AVL树不相上下。 什么是跳表首先我们先来看一个链表： 对于这种链表来说，即使链表之中是有序的，如果我们要从中查找某个值，也只能从头逐个查找，运气好的话查找一次就能找到，运气差的话或许要查找n次。在使用数组存储的方式中我们可以通过二分搜索来快速的查找某个值，而链表由于不支持随机查询，所以就不能使用二分搜索的方式来查找。 那么如何能提高查找效率呢？在O(n)的时间复杂度下如果要提高运行效率，二分是必不可少的，树结构可以通过左右子树来分区，那链表又如何分区呢？建立索引，我们对这个链表加上一层索引。 假如我们要查找6，只需要走1-&gt;3-&gt;5-&gt;6，减少了2步，那如果我们再加几层索引呢？ 这时的查找其实就是二分查找了，查找效率已经有质的提升。而这种的原理其实很简单就是通过分区来跳过大量的节点。 上面所说的结构是静态的，当我们向上方的跳表中不断加入数据，如果不更新索引就有可能出现某节点之间出现大量节点的情况，在极端的情况下还会退化成链表。而如果在插入的时候重建索引那势必会导致跳表的插入效率大幅下降。那要如何解决动态插入的问题呢？在红黑树和AVL树中是使用左右旋来平衡二叉树，而跳表同样也有一种机制来平衡：通过随机函数来是插入的节点的层高是随机的，不强制要求1：2的分区。如，我们要在以下的跳表中添加一个值为18的节点： 首先我们需要通过一个随机函数来得出新节点的层高。假设在这次插入中得到的层高是3 然后搜索到插入的位置。 最后将节点插入并重新设置指针，从上一张图中我们可以看到游标走了所有的层，而游标在游走的时候就可以记录层信息，就可以重设指针了。 简单分析跳表效率从上面图中我们可以知道，大致每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2k)。那么假设层数足够高，即最高层只有两个节点，那么可知n/(2k)=2，即k=log2n-1，若把原始链表计算在内那k=logn，若每次查找都要下降m层的时候，那在跳表中查询一个数据的时间复杂度就是O(m*logn)。而m可以认为是参数，所以跳表查询一个数据的时间复杂度就为O(logn)。 说完时间，那么我们来说说空间，比起链表和二叉树，跳表需要多个指针域，肯定需要比链表和二叉树多许多空间。若我们两个节点就提升一层，那需要的索引数量就为n/2+n/4+n/8+…+2，即n-2，所以可以知道跳表所用的空间复杂度为O(n)，看起来似乎很大？但是我们需要考虑原始链表中数据存储的大小，若数据的大小很大，那么索引使用的空间就微不足道了。 实现代码 忘记附上代码了，逃 结语跳表的时间复杂度是O(logn)，空间复杂度是O(n)，虽然不如平衡树来的“高效”，但是跳表的实现非常灵活，可以有效的平衡执行效率和内存消耗，并且实现起来也比平衡树容易，所以多数情况下跳表会是比平衡树更好的选择。"},{"title":"浅谈数据库索引","date":"2019-09-07T14:53:01.000Z","url":"/talking-about-database-index.html","tags":["Mysql","数据库","浅谈"],"categories":["折腾记录"],"content":"前言提起索引我想你应该不陌生，当我们查阅一本大部头的时候我们应该如何快速的找到想要的内容呢？很简单，先找目录，通过目录我们就可以了解到我们要找的内容在书中的什么地方，而这个目录就担任着索引的功能。相同，数据库为了能快速的寻找到指定的数据必须要建立索引。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。 几种常见的索引数据模型有序表最简单的方式就是有序线性表的存储方式，而这种方式包含了两种存储类型，分别是数组和链表。有序数组(Array list)在等值查询和范围查询的情景下性能非常优秀，但是当我们需要在这之中插入数据的时候就需要将后方的数据全部进行移动，成本非常高，所以一般只适用于静态存储引擎。而另外一种有序链表(Linked list)，在增加删除插入的场景中性能表现优秀，但是在查询的场景中就不太合适，但是我们知道对有序表的查询一般采用二分搜索，而这个二分搜索是通过分区的方式来提高查询效率，如果我们为有序链表建立分区索引，那有序链表的查询效率就能达到O(logN)，这也是Redis的有序集实现方式跳表(Skip list)，关于跳表的内容这里就不说了，有兴趣的请自行查阅。 哈希表除了有序集的方式还能通过无序集的方式来作为索引，哈希表(Hash table)，哈希表是通过计算key的散列值从而定位value在数组中的位置来进行查询的，不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。而哈希表由于是无序的所有只适用于等值查询的场景， 比如Memcached及其他一些NoSQL引擎。 树除了集合的方式还有二叉搜索树这种方式，二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。而磁盘的读取时间并不快，当树高20的时候数据库就有可能读取20个数据块，所以为了尽可能的减小磁盘的读取次数，则不应该使用二叉树，转而使用N叉树，N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。如MySQL的InnoDB和MyISAM。 数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。 InnoDB的索引模型在MySQL中，索引是在存储引擎层实现的，所以有多种不同的索引，即使索引使用同一类型的的索引，工作方式也可能会不一样。而在MySQL中主要是使用InnoDB，所以这里就来分析InnoDB的索引模型 在InnoDB中，索引使用的是B+树作为索引结构，根据叶子节点的内容，索引类型分为主键索引（聚集索引 Clustered index）和非主键索引（辅助索引 Secondary index）。主键索引的叶节点中存储的是表中的行数据，非主键索引中的叶节点存储的是主键的值而不是地址。当我们使用主键索引对表中的数据进行检索时，就可以直接得到行数据，而不用进行二次检索。而使用非主键索引进行检索时，我们得到的是主键的值，当我们查询的列不只有主键的时候，就需要通过搜索到的主键值再到主键索引中搜索一次，这种过程被称为回表。 通过上面的说明我们知道非主键索引存储的是主键的值，所以当主键的值占用的空间越小，非主键索引就能越小，需要读取的数据块就有可能越小，所以在创建数据表的时候应该选择一个合适的字段作为主键，或者使用自增主键。 InnoDB索引策略覆盖索引举个例子说明比较容易理解，假设有一个people表，表中有id和name两列都是索引，id为主键，当我们执行以下查询SELECT id FROM people WHERE name=otstar;的时候，InnoDB会去name索引中寻找主键即id，而我们要查询的值id已经在name的索引中存储了，所以不需要回表，由于在非主键索引中的查询覆盖（满足了）了查询请求，所以称为覆盖索引，由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 联合索引联合索引就是创建一个支持两种或以上字段比较的索引，比如name,age的联合索引，当我们查询SELECT id,name,age FROM people WHERE name=otstar AND age=18;的时候就只需要再name,age中直接查询，而不再需要回表。从而提高查询效率和减少开销。 最左前缀原则从名称中就可以看出，最左优先，如当创建了一个name,age的联合索引，就相当于创建了name的单索引和name,age的多索引，这时我们就没必要再去创建name的单独索引，但是如果需要age也是索引则需要另外创建一个age的单索引。 那有这种特性的出现有要如何排序联合索引呢？当我们将一个索引放置到左边的时候可以减少创建一个索引的时候我们就应该优先考虑这种情况，还有一种是空间，name字段一般是比age字段大的，如果我们创建age，name的联合索引，当我们需要name的单独索引的时候，就需要创建name的单独索引，而创建一个name的索引对存储的开销比age大。简单的比喻下，如name的索引占用2空间，age占用1空间，则name,age+age的索引占用4空间，而age,name+name则需要占用5空间。 索引下推假设有一个包含id,name,age,nikename的people表，id为主键索引，name,age为联合索引，当我们执行SELECT * FROM people WHERE name LIKE &#39;o%&#39; AND age=18 AND nikename=otstar;，依照最左前缀原则，这句查询只能使用name单索引查询，而不能使用name,age的双索引查询，因为还有一个nikename字段需要匹配，所以当查询到符合name的查询的时候，在MySQL 5.6之前就只能拿id的值去回表看看其他字段是否匹配，而5.6之后引入了索引下推，也就是把age字段也加入索引，当name匹配后就可以一并对age进行判断，而不用连age字段都要回表比较，这时候就可以减少不少的回表次数。 结语在满足语句需求的情况下， 尽量少地访问资源是提高数据库性能的一大关键，理解索引的原理，我们才能不浪费性能或资源，提高数据库的效率，从而提高程序的运行效率。"},{"title":"MySQL事务隔离","date":"2019-09-05T15:06:22.000Z","url":"/mysql-transaction-isolation.html","tags":["Mysql","数据库"],"categories":["折腾记录"],"content":"事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。 或许这么说你可能难以理解，那我们举个经典例子来说明事务的用途吧： 用户A向用户B转账，我们需要进行以下操作：从A账号中把余额读出来。对A账号做减法操作。把结果写回A账号中。从B账号中把余额读出来。对B账号做加法操作。把结果写回B账号中。在这些操作中需要保证这些操作是一体的要么都成功做完，要么都不成功。 为了解决这种问题这也就是事务诞生的背景。 ACID特性数据库事务拥有以下4大特性： 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 1. 原子性原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。 简单来说就是操作成功了就成功了，一旦操作失败了就会放弃事务中已经执行的操作，回到事务刚开始的状态。 2. 一致性一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 一致性就是说不管操作是否成功，总的数据不会发生改变，即A给B转账，A和B的总金额不发生变化。 3. 隔离性多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 如果A在转账1亿给B（事务1），同时C又在转账3亿给A（事务2），不管事务1和事务2谁先执行完毕，最终结果必须是A账户增加2亿，而不是3亿，B增加1亿，C减少3亿。 事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性(序列化)要求数据库同一时间只执行一条事务，这样会严重影响性能。 4. 持久性这是最好理解的一个特性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持） 隔离性和隔离级别隔离性隔离性是通过锁实现的，当一个事务对某项数据进行更新操作的时候就会对数据加锁，从而防止其他事务对该数据的影响，锁的级别一般有3种，全局锁，表锁，行锁，MySQL中的InnoDB支持以上的三种锁，MyISAM不支持行锁。锁获取的时机是事务执行的第一句才开始锁住数据的，并不是在数据开启的时候获取的，当事务提交成功后才会释放锁。 隔离级别隔离级别有4种从低到高分别是读未提交（Read uncommitted）、读提交（Read committed）、重复读（Repeatable read）、序列化（Serializable）。 读未提交（Read uncommitted）从名称中就可以看出，读 未提交，即一个事务可以读另一个事务未提交的数据，简单来说就是一个事务修改了某个数据当它还没提交的时候，另一个事务读取该数据的时候会读取到修改后的数据，即使修改的事务还没有提交。这种隔离级别解决了更新丢失，一事务写时其他事务可读不可写。 读提交（Read committed）从名称也可以看出来，读 提交，一个事务要等另一个事务提交后才能读取数据，即事务期间独占数据，其他数据不能对该数据进行读写操作。这种级别解决了脏读和更新丢失，一事务写时其他事务不可读写。 重复读（Repeatable read）这个从名称应该是无法看出来了，重复读即一个事务重复读的数据是相同的，就是当一个事务对数据进行读操作的时候其他事务不能对其进行修改但可读。这种隔离级别解决了脏读，更新丢失和不可重复读，一事务读时其他事务可读不可写。 序列化（Serializable）这是最高的隔离级别，所有的事务只能一个接一个的执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。 简单说一下事务的问题 更新丢失：当事务1更新失败时会回滚数据，而在回滚之前事务2若成功更新数据，则事务2更新成功后的数据会被回滚覆盖，造成更新丢失。 脏读：当事务1读取了事务2未提交的数据，而事务2若失败回滚数据了，则事务1读取到是数据就是无中生有的数据，即脏数据 不可重复读：事务1读取某个数据后，事务2对其做了修改，当事务1再次读该数据时得到与前一次不同的值。 幻读：事务1读取在读取某范围数据时，事务2插入一条数据，当事务1再次数据这个范围数据时就不一样了，出现了一些幻数据 简单整理一下各种隔离级别可避免的问题更新丢失 脏读 不可重复读 幻读 读未提交（Read uncommitted） 避免 读提交（Read committed） 避免 避免 重复读（Repeatable read） 避免 避免 避免 序列化（Serializable） 避免 避免 避免 避免"},{"title":"算法复杂度分析(1)","date":"2019-08-28T09:10:03.000Z","url":"/algorithm-complexity-analysis-1.html","tags":["算法"],"categories":["折腾记录"],"content":"为什么需要算法复杂度分析，实际运行一遍然后收集运行的信息和统计不就可以了？这总事后分析的方法确实没有错，但是当环境发生变化，数据量发生变化，或者数据模型改变了，程序的执行效率就有可能发生巨大的改变，所以我们需要一种粗略的，不需要具体测试数据的估算程序执行效率的方法，而这种方法就是复杂度分析。 大O复杂度表示法大O表示法是一种特殊的表示法，指出了算法的速度有多快或者多慢。谁在乎呢？实际上，你经常要使用别人编写的算法，在这种情况下，知道这些算法的速度大有裨益。 这里我们拿一段代码来进行解释： 这段代码是用来求数列和的，我们把每一句代码执行的时间记为1u，然后默认每句基础代码执行的时间都是一样的，从上面的代码我们可以看出，int num = 0;和int i = 1;各执行了1次，sum = sum + i;和i++各执行了n次，return部分我们不看，那么这个函数所执行的总时间就应该是(2n+2)*1u，我们把总时间记为T(n)那么，可以看出执行的总时间和n成正比关系，即和执行次数成正比关系，而这种规律我们可以总结成一个公式即: T(n) = O[f(n)] 而上一个公式就可以表示成T(n) = O(2n+2)，当n到大一定程度的时候我们就可以把+2和n的系数2给忽略掉，这时候的T(n) = O(n)，这就是我们常说的O(n)时间复杂度或O(n)空间复杂度的由来。 时间复杂度分析那么当代码越来越长，越来越庞大是时候难道还这样一步步分析吗？当然不是，当我们对算法或者程序进行分析的时候我们只需要关注以下几点即可： 1. 只关注循环次数最多的代码还是拿上面一段代码来分析。 从代码中我们可以看出，只有一个循环n次的for循环，而其他部分的代码只执行了一次，这时我们就可以直接忽略掉那些只执行一次的代码，只关注执行最多的代码，即for循环中的代码，所以这个函数的时间复杂度就是O(n)。 2. 加法法则：只关注执行次数最多的代码的时间复杂度 从上面的代码我们可以看到4个for循环这时候应该如何判断呢？首先我们先找出它们各自循环了几次，第一个执行了10次，第二个执行了n次，第三个执行了10n次，第四个执行了n2次，这时候我们只需要关注执行最多的那个循环的复杂度即可，即第四次（我们均默认n很大），所以这段函数的时间复杂度为O(n2)。 3. 乘法法则：嵌套代码的时间复杂度等于嵌套内外的时间复杂度的乘积 从上方代码看出，fun函数中的for循环每次循环都需要调用一次cal函数，而我们可以很轻松的判断出cal函数的时间复杂度是O(n)，而fun一共需要调用n次cal函数，即O(n) O(n)，即O(nn)，简化下就是O(n2)。 到这里我们就基本讲完了时间复杂度的分析方法了，下面我们就来看以下几种常见 的算法时间复杂度。 番外：常见的时间复杂度1. O(1)这个时间复杂度并不是表示只有一句基础代码，而是代表常数的时间复杂度，即使你有100句基础代码也不能表示为O(100)，而应该表示为O(1)。 2. O(logn), O(nlogn)对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。 我这里就拿算法图解这本书中的一张图来说明： 来自《算法图解》 我们要得到一张16格的纸，如果采用对半折的方式就只需要4次就能完成，即4 = log216若把4换成T(n)，16换成n，我们就可以得到T(n) = O(log2n)，然后我们忽略掉常数的底数，就变成了O(logn)，并不是只有2才能忽略掉底数，所有的常数底数都可以被忽略。 3. O(m+n)、O(m*n)或许你有看过这种复杂度，或许没有看过，这种其实非常简单，我们通过下面的例子来进行分析： 当我们看到这个函数的时候是不是就应该通过加法法则排除掉一个呢？然后你会发现若不知道m和n的大小关系根本无法对其进行判断，也就无法排除掉其中的一项，这时候就应该保留两个未知数，即O(m + n)，另外的O(m * n)同理。 空间复杂度分析空间复杂度的分析十分的简单，我们直接通过一个例子来进行分析吧： 这段例子非常简单，就是创建了一个大小为n的数组，所以这段代码的时间复杂度就是O(n)。 结语复杂度的分析其实不难，只要多练习，多分析就能熟练的掌握它，还有最好时间复杂度，最坏时间复杂度，以及平均时间复杂度等一些分析我留着下一篇在说吧，零零散散的写了一篇文章，还是挺累的，完全手打了2300+个字，其实是懒 （逃，(￣y▽,￣)╭ 。"},{"title":"一年来的经验总结","date":"2019-08-26T13:22:46.000Z","url":"/summary-of-experience-over-the-past-year.html","tags":["总结"],"categories":["站长杂谈"],"content":" 自从进入大学已经接近一年的（还差几天），这一年中我从一个什么都不知道的小白变成了一个了解不多的菜鸡，写过许多谜之代码也写过几个垃圾项目，学过许多古董技术也用过一些神奇的东西或框架，这一年来我走过了不少弯路，浪费了不少时间，写这篇文章的目的是为了总结一下这一年的来走过的路和一年来的经验，调整我的方向。也希望能给访客们带来启发。 本文的主观性很强，若有不足和不妥之处请多包涵，有不明白的地方或者可以改进的地方请在下方留言。 我选择计科的原因说起原因的话不得不提高二的时候，那时候还没有推出无限量的流量套餐，作为一个住校生肯定会搜寻附近是否有开放的网络，那时候还用着酷派的大神F2，信号很好，可以连接到一楼的开放WIFI，后来被盗了然后找同学买了部大神Note3，却发现信号很渣，于是乎买了个香橙派来中继，然后接触到了Linux，Web和WordPress，逐渐的发现对这些非常感兴趣，期间也折腾了HTML/CSS，但只停留在爱好的阶段。后来毕业了选专业，看着列表上乱七八糟的专业才发现还是软工比较适合我，但是没得选，后来听说了计科和软工差不多后选择了计科。 我一年来的学习历程开学后我知道了要学习哪些课程，其中的编程课是C语言，作为一个喜欢先行出发的折腾怪，我就打算早在同学之前完成部分课程的学习，当时原本是打算看书来学习的，后来发现我的学习方式并不适合看书，当初啃书的时候是非常痛苦的，啥都不懂，看着书上那堆乱七八糟的东西一愣一愣的，3天看了还不到20页，于是经过一些考虑后我选择了看视频学习，一开始不知道去哪找资源，经别人推荐去了网易云课堂随便找了一个视频教程学习，照着视频我学了C的基本语法，条件语句，循环语句，以及数组等基础的知识。 对了，当初我使用的编辑器并不是古老的VC6也不是CodeBlocks更不是Dev C++，而是Visual Studio Code，当初用这个编辑器的原因是因为用习惯了，至于怎么用习惯的那又是另一个故事了，但是作为一个过来人，我极其不推荐使用VC6,CodeBlocks,Dev C++等古老的编辑器，现在的大学课堂总是喜欢简单粗暴的教学生们装一个VC6，美其名曰“我当年还用XXX的编辑器写XXX”，要说为什么不推荐使用这些编辑器的原因是它们对新手都不友好，没有代码高亮，没有补全，连报错都是乱七八糟的，调试更不用说。为什么需要这些？因为什么都没接触过的小白想要学好这门技术首先需要的是信心和兴趣的搭建，而一个快捷方便的编辑器（可以是VSCode，VS等现代的IDE[编辑器]），可以使他们不会因为一些小错误而对编程丧失信心和学习的兴趣。在过去的一年中我为我的大部分舍友安装了VSCode，并教他们如何使用，实际使用下来他们的确在用VSCode的阶段（学C的阶段）中表现得不错，后来学Java使用了Eclipse（没像我这么固执，其实是我实在用不惯Eclipse） 拉回正题，C的前面部分学习还算顺风顺水，因为我有写过PHP，PHP和C的语法还是非常像的，直到遇到了指针和结构体。指针和结构体可以说是学习C的一大拦路虎，好在最后还是靠着Google的帮助学会了。后来学习了Java和汇编这些就不谈了，有了C的基础学习起来就只是思想转换的问题了。 个人的经验之谈在大一，我学习了C，Java，PHP，JS和一些相关的框架，但都只学了皮毛，并没有去深究它们，大一重要的是打开视野，而不是去深究某项技术，更不是从底层学起，也不是沉迷于刷题无法自拔。学会腾出时间去了解目前互联网是如何如何，大咖们都在关注什么，寻找自己喜欢什么，想学什么，了解如何通过互联网快速寻找到你想要的答案。如果可以请到墙外看看，看看世界上正在发生什么，程序员之间是如何协作的。学会利用好Github，Stackoverflow，MDN，甚至是Google等网站。 比起刷OJ我更推荐你去找一个小项目，试图去读懂它，了解它，模仿它，甚至是改进它优化它，你会发现在这之中学到的知识远比刷100题OJ来的多。 然后试着去写个项目，当你写项目遇到问题时，你才会真正的去思考要如何解决问题，当你在项目中遇到如线程，进程，并发，异步，同步等问题的时候，你自然而然的会去思考进而学习相关的知识，当你把这之中的问题都逐一找到答案的时候，那种成就感和兴奋感是无可比例的。当你发现你的程序运作起来很慢的时候，你自然而然的会去想如何优化它进而去学习算法，优化的方法。学习编程不是填鸭式的学习，驱动式学习才是学好的关键。 在我看来，在编程这条路上这些最好不要做： 不格式化代码，随性的编写代码，一行当成100行使用 不参考最佳规范，不看优质代码 什么问题都喜欢问他人，不去学习如何独立的解决问题 喜欢把所有的代码写在一个主函数中 不管学什么都要买一本书，或者捧着一本大部头，试图线性的从头看到尾 在我看来，你应该学习的或者应该去做的: 学会使用Github 学会如何使用搜索引擎（这里不推荐使用百度，如果用不了Google也请用Bing或者第三方搜索引擎） 学会对知识进行输出（建一个博客或者去一个优质平台把自己学到的知识写成文章） 学会如何寻找学习的资源 学会使用一个好的开发工具（编辑器，CI等） 学会阅读（文档，文章，代码等） 结语首先感谢你能看到最后， 或许这篇文章并不能给你带来什么，但我们有缘一起走上一程，望各位都能有好的成就。 很多建议是我从各类消息源阅读收集而来，由于有的时间久远无法一一寻找 ，在此统一表示感谢 。 感觉还没写完，所以还会添加一些内容ԅ(¯ㅂ¯ԅ)"},{"title":"Acrylic - VSCode Extension","date":"2019-07-19T13:28:26.000Z","url":"/vscode-acrylic.html","tags":["VSCode"],"categories":["分享推荐","折腾记录"],"content":" 为VSCode添加 Acrylic 或者其他效果 前言前几个星期一张带毛玻璃效果的VSCode的图片进入了我的视线，后来搜索了相关的设置教程发现只有MacOS才能启用这种效果，作为一个折腾青年，后来通过使用了ewc，VSCode确实增加了 Acrylic 的效果，但是并不能使整个编辑器获得Acrylic（第一次尝试是使用和 GlassIt-VSC一样的方式，即通过JS调用Powershell为VSCode窗口增加效果），可能是CSS没有写好，也可能是该方法不适用，反正最后放弃了折腾。直到昨天看到了 vscode-vibrancy ，该扩展使用的是Acrylic效果，Acrylic效果虽然美观但是会出现拖动延迟的问题，而Blur效果和Acrylic相近并不会产生拖动延迟，于是便打算将 ewc （支持Acrylic和Blur等效果）通过 vscode-vibrancy 的方法加载进VSCode，于是便有了这个扩展。 支持的系统Windows10 ✔ 使用方式 安装该插件 Visual Studio Code Marketplace 切换到任何的暗色主题，因为Acrylic效果和Blur效果在亮色主题下表现不佳 按F1键运行“Enable Acrylic ” 重启VSCode 运行“Enable Acrylic”时VSCode应使用管理员权限运行 卸载方式按F1键运行“Disable Acrylic ” FAQs为什么不支持MacOS？vibrancy插件已经实现了MacOS下的vibrancy效果，没必要重复写插件，并且MacOS下的效果和Windows下的效果并不同。 为什么要制作这个插件？请看前言 相关链接 Visual Studio Code Marketplace Github Introduction Thinks vscode-custom-css vscode-vibrancy ewc RenderAcrylic BlurBehind TransparentGradient"},{"title":"ace编辑器设置惯性滚动","date":"2019-05-11T08:21:19.000Z","url":"/ace-editor-sets-inertial-scrolling.html","tags":["JavaScript","Mobile"],"categories":["折腾记录"],"content":" 上个月我写了XK Editor这个项目，使用了ace编辑器和tinymce编辑器作为基础编辑器，但是当项目进入适配移动端的时候，遇到了一个很头疼的问题，ace编辑器不支持惯性滚动，用起来会非常变扭，于是便为之增加惯性滚动的功能。 原理惯性滚动，即在触屏设备中滑动手指，当手指离开屏幕后，滚动事件并不会立即停止，而是会继续移动一段距离，这段距离是由手离开屏幕时的滚动速度和预设的摩擦力决定的，通过这时的速度，预设的摩擦力和特定的公式计算出一系列滚动点，然后逐个滚动到滚动点，来模拟惯性滚动。 实现方案 监听开始触摸的事件，记录开始的时间和开始的坐标，同时重置滚动(防止连续滚动出现Bug) 监听触摸结束的时间，记录结束的时间和结束的坐标 通过公式v = (endY - startY) / (endTime - startTime) * 1.5 1.5的值可以调整 定义“摩擦力”deceleration = dir * 0.0018 0.0018也可以调整 在每次微滚动前都计算一下滚动的坐标，然后进行滚动。 直至速度为0或者速度方向改变的时候停止滚动 实现代码"},{"title":"为apt方式安装的nginx重新编译增加WebDAV","date":"2019-05-05T17:34:15.000Z","url":"/recompilation-of-nginx-installed-for-apt-mode-adds-webdav.html","tags":["apt","nginx","WebDAV","编译"],"categories":["折腾记录"],"content":" 由于机房装了还原卡，重启就会恢复磁盘，作为VSCode的重度使用者实在受不了Eclipse这个编辑器，并且大部分时间也并非在编写Java，所以博主搭建了code-server作为Cloud IDE，把开发环境放到了服务器上，但是当回到了宿舍使用自己的笔电的时候Cloud IDE就派不上太大的用场(Node除外，Node这东西实在太吃性能了)，于是同步就成了大问题，这时有人会说用Git，可惜Git并不具备实时性，在需要将服务部署在服务器上运行的时候操作就相对繁琐，所以就想到了挂载云端的文件到本地，然后SSH连接上服务器。 --- 假装有分割线 — 之所以选择webDAV是因为它基于HTTP，传输性能优于SFTP和FTP， 同时能够利用 HTTP 的各种扩展，比如 HTTPS，HTTP 2.0等等。 选择Nginx作为webDAV的服务程序是因为其轻量化，同时也可以为PHP等服务。 apt安装的Nginx自带了一个http_dav_module，但是为了让 nginx 能够支持 WebDAV 规范中的PROPFIND和OPTIONS，还需要安装模块 [nginx-dav-ext-module]() 。 一、查看Nginx版本并下载对应源码包 其中nginx version就是Nginx版本，前往下载对应的版本，并解压 二、下载nginx-dav-ext-module进入nginx-x.x.x文件夹 三、配置configure首先复制上方nginx -V命令得到的configure arguments，进入nginx-x.x.x文件夹，加入--add-module=./nginx-dav-ext-module参数 运行后可能会有出现报错，一般是都是依赖不存在导致的，利用apt安装对应的依赖，后重新运行一遍configure即可，注意：依赖是一个个报错的，请确认没有报错的情况下进行下一步。 以下是部分常见的报错和依赖的安装方法1. rewrite需要pcre支持./configure: error: the HTTP rewrite module requires the PCRE library 2. http cache需要openssl./configure: error: the HTTP cache module requires md5 functions from OpenSSL library 3. 安装libxslt./configure: error: the HTTP XSLT module requires the libxml2/libxslt libraries 4. 缺少GD library./configure: error: the HTTP image filter module requires the GD library 5. 安装GeoIP library./configure: error: the GeoIP module requires the GeoIP library 四、编译Nginx首先安装编译工具 开始编译，注意：执行make即可，不需要再执行make install 编译完后新的nginx二进制运行文件就出现再objs文件夹下，接下来只需要复制到/usr/sbin即可 先备份下 然后复制新的nginx到/usr/sbin，并重启nginx 五、配置WebDAV进入/etc/nginx/sites-enabled文件夹，新建一个conf文件，并使用以下配置文件 接着重启nginx即可 结语至此WebDAV就配置完成了，当时配置的时候就遇到了一大堆没有安装的依赖，依赖一个个跳出来，差点把我心态搞炸，好在最后还是编译成功了，上面的配置还有些问题，暂时还不支持移动和新建文件夹的操作，博主正在研究修复，请耐心等待(￣▽￣)”。"},{"title":"Java图实现","date":"2019-05-05T03:03:10.000Z","url":"/java-graph-implementation.html","tags":["算法","Java"],"categories":["折腾记录"],"content":" 没有介绍，请自行百度或谷歌，代码经过了一定的测试，但不保证没有Bug。 "},{"title":"Java二叉树实现","date":"2019-05-05T02:59:47.000Z","url":"/java-binary-tree-implementation.html","tags":["算法","Java"],"categories":["折腾记录"],"content":" 这是一篇水文，逃，代码已经经过一定的测试，但无法保证没有Bug。介绍网上一大堆这里就不介绍了，直接放代码吧(￣▽￣)” "},{"title":"XK-Editor - 一个支持富文本和Markdown的编辑器","date":"2019-04-27T18:15:10.000Z","url":"/xkeditor.html","tags":["JavaScript","Vue","Editor","Markdown"],"categories":["折腾记录"],"content":" 前言这个项目原本是为了升级 XK-Note 而创造的，后来因为功能的不断完善，逐渐的改成了可复用的组件。XK-Note原本是使用Editor.md的编辑器，使用起来也很不错，但是总有一些不如意的地方，于是便打算自己造个编辑器。 XK-Editor基于Vue是因为双向绑定这个特性，同时也是模板语法，便于开发，之所以采用ACE编辑器其实是当时觉得CodeMirror太丑了，实际开发中ACE实在太难弄了，文档跟不存在一样，只能阅读源码来实现一些不常见的功能，同时也修补了Editor.md中一些不如意的地方，比如没有打字机模式，每次写到屏幕下方的时候总是要重新滚动，代码高亮不够漂亮，没有自动补全等等。。。又引入了Tiny MCE使得编辑器拥有了富文本编辑的功能。 简介 IntroductionXK-Editor = Vue2.0 + Ace + TinyMCE; XK-Editor 支持富文本编辑和 Markdown ，同时可以在 Markdown 和 HTML 互转，满足各种人的需求。 特性 Feature [两种编辑器] 支持富文本编辑和 Markdown 编辑 [两种格式互转] 支持 Markdown 和 HTML 互转 [打字机模式] 支持打字机模式，编辑时无需使用鼠标滚轮，并可调节定位位置，满足各种屏幕和使用者的需求 [粘贴自动格式化] 支持在粘贴 HTML 时自动将 HTML 格式化为 Markdown [图片粘贴自动上传] 支持粘贴图片自动上传，并自动填充链接 [嵌入运行块] 支持嵌入可运行的代码块，通过与后端交互可以支持多种语言 [下载] 支持导出下载 Markdown 和 HTML 格式的文件 [即时保存] 支持即时保存到浏览器，无惧网络波动 [移动端优化] 优化移动端的编辑体验，支持惯性滚动，并默认关闭实时预览 [滚动绑定] 支持双向/单向滚动绑定，使预览能够跟随输入 [树形 TOC] 目录可折叠，不用再翻阅很久来定位 [自定义主题] 支持自定义主题，可以通过替换 CSS 来更换显示样式 [Emoji 表情] 支持 Github 语法的表情 :smile: [Task lists] 支持创建 Task 列表 [TeX 公式] 支持插入 KaTex 公式 [流程图/时序图/甘特图] 支持 mermaid 语法编写各种图 [解析 HTML] 支持解析各种 HTML 标签，并支持过滤标签 [独有的扩展语法] 拥有一些扩展语法 [自动补全] 支持语法自动补全 [图片上传] 支持图片上传 还有多种神奇的功能等待你的发掘。 演示 DemoXK-Editor 安装 Install注意事项XK-Editor 还在不断的改进中 API 可能会更改 从 Version 1.0.8 开始，为了减小 Vendor 体积，防止加载时间过长，XK-Editor 默认使用 jsDelivr CDN 加载部分 node_modules 需要在 index.html 中添加以下 script 标签，若您不打算使用该方式加载，请将 node_modules/xkeditor/components 下的文件中所有的 import 注释取消。 从 Version 1.4.6 开始，模块默认通过 webpack externals 方式导入，所以您需要修改 webpack 的配置文件，添加对应的配置，如下 从 NPM 安装你可以轻松将 XK-Editor 引入你现有的项目 安装 XK-Editor 将 XK-Editor static 文件复制到项目根目录 导入 XK-Editor 组件 使用 XK-Editor 组件 所需依赖 config &amp;&amp; data 运行代码块运行代码块除 javascript 不需要使用后端，其他语言都需要有后端负责执行代码。 后端执行器基于 judge0/api 重新 build 而来，支持的语言详见 run-code ，若您有其他语言的需求，您可以自行参照教程重新 build run-code 文档 DocWiki Github求 star =￣ω￣= 维护者 MaintainerXK-Editor 由 Otstar Lin 和下列 贡献者 的帮助下撰写和维护。 Otstar Lin - Personal Website · Blog · Github 许可证 License 根据 Apache License 2.0 许可证开源。 渲染 Render 结语首先感谢你能看到最后，同时感谢你对该项目的兴趣。 该项目虽然不大，大部分核心的部件也是使用现成的组件，但是对我来说也是一次良好的经验，也是我第一个完整的前端项目，所以难免会有Bug，若您在使用遇到了问题，请及时联系我进行修复，或者到Github上提交issue，我会尽快的处理，另外若您有其他好的建议或者有希望增加的功能，请联系我进行添加或者提交Pull Request。 Coding最大的乐趣，不在Coding，而在Creating。 — Otstar Lin "},{"title":"JS生成列表树","date":"2019-04-19T15:51:16.000Z","url":"/js-generate-list-tree.html","tags":["JavaScript","目录树","递归"],"categories":["折腾记录"],"content":" 上一篇文章我们使用PHP的构建简单的目录树，这次由于一个项目的需要（构建标题大纲），需要在前端使用JS构建ul li的多层次列表，其实就是类似于ZUI的树形菜单啦(￣▽￣)” 实现原理首先需要准备一个对象数组，数组中的对象拥有level和title（可以自行命名，由于博主是生成标题的索引所以就使用title命名） 另外，该数组需要按一定的顺序进行排序，否则就需要自行设置索引，排序的规则是子级必须紧跟在父级后，例如 有了目录的对象数组，我们就可以通过递归或者栈来构建列表树了 实现代码构建HTML 通过调用getTocHtml()就可以获得目录的HTML，生成后的效果如下 从代码中可以看到在li标签中还有img标签和带锚点的a标签，a标签是为了跳转到指定位置而设置的，可以按不同的需求进行调整，img标签是为了点击时显示和隐藏子级列表而设置的 为目录添加toggle功能废话不多说，先上代码 initTocTree()是用来初始化列表树的，该函数会修改有子列表点的父级列表图片，并为其添加onclick事件，toggleToc()是在img标签被点击的时候展开/隐藏子级列表的，同时修改其img图像，便于用户判断子列表是否已经展开，具体效果如下 虽然有上篇文章的参考我还是想了很久，写出来的代码也很渣，看来还需不断的学习啊＞﹏＜"},{"title":"Laravel生成目录树","date":"2019-03-15T13:46:31.000Z","url":"/laravel-generating-directory-tree.html","tags":["PHP","目录树","递归","Laravel"],"categories":["折腾记录"],"content":" 在XK-Note项目中由于需要读取取所有文件夹和所有文件，但是Laravel并没有提供生成目录树的函数，所以只能自己动手丰衣足食。ㄟ( ▔, ▔ )ㄏ Laravel 提供了一个强大的文件系统抽象，我们可以直接使用，这样就不会使目录树只支持从本地存储生成。 实现原理Laravel内置了 Storage::files($directory)可以读取指定目录下的文件并生成一个索引数组， Storage::directories($directory)可以读取指定目录下的子目录并生成索引数组，利用这两个函数就可以将指定文件夹下的所有文件和所有子文件夹的信息都存入数组中，然后可以递归提取出来的子文件夹进行深层查找，直到没有子文件夹为止，但是这样提取出来的数组会变得乱七八糟的，在生成目录列表的时候就不容易，所以要在递归的同时修改生成的索引数组。 生成的目录树结构如上，当key为数字时则代表value为文件，当key为字符串时则代表value为文件夹。 实现代码FolderModel FolderController"},{"title":"XK-Note - 集各种神奇功能的云笔记","date":"2019-03-10T07:17:00.000Z","url":"/xknote.html","tags":["PHP","Laravel","Note","ZUI"],"categories":["折腾记录"],"content":"v2已开发完毕，您可以按照安装方式重新安装 前言博主是个计科的大学生，所以经常需要将一些不太理解的代码或者经验记录下来，纸质笔记对一些经验还好，一旦涉及代码。。。，所以博主的笔记都是电子的，在弄好这个笔记时使用的是Typora，确实非常好用，但是有个硬伤，同步不便，到机房上课的时候笔记就派不上用场，并且查看还要使用支持Markdown的编辑器。可谓苦不堪言，直到我在Github上看到了Editor.md这个项目，于是便开始了Coding。 简介 IntroductionXK-Note = Laravel . Vue2.0 . XK-Editor; 一个由上方代码组成，集各种神奇功能的云笔记。 特性 Feature [云存储] 云端撰写笔记，随时保存，多端同步。 [跨平台] 多平台支持，撰写查阅只需一个浏览器，无惧任何不兼容情况。 [响应式] 所有页面均采用响应式设计，即使尺寸极小的设备也能保持良好的体验。 [在线浏览] 拥有独立的浏览模式，查看笔记不再困扰。 [历史版本] 笔记支持历史版本查看和回滚，您可以切换到任何提交过的历史版本，无惧误删除。(基于 Git) [Git 同步支持] 独有的 Git 支持，支持版本控制，无惧误操作，随时从旧版本恢复笔记。 [浏览器临时保存] 独有的浏览器端保存功能，即使断网了也能安心写作，无惧任何网络波动。 [发布到博客] 笔记可以在编辑完成后一键推送到 WordPress，Hexo 等博客系统。 [多笔记同时打开] 笔记可以随时打开，您无需在编辑其他笔记时关闭之前开启的笔记。 [多用户] 笔记主要面向个人使用，但是也支持多人同时使用，每个用户的笔记互相隔离保存，无需担心笔记泄露。 [导出笔记] 支持多种导出格式，保存为 MD 文件，html 文件，由本地即时生成，无需繁琐的操作。 [多种模式] 拥有多种模式，写作，预览，阅读，满足各种人的需求。 还有多种神奇的功能等待你的发掘。 演示 DemoXK-Note 账号： demo@ixk.me / demo 密码： demodemo 安装 Install 目前 XK-Note v2 还处于测试阶段，所以可能存在 Bug，若您在使用中遇到了 Bug 或者疑似 Bug 的情况，请提交 issue 或与我取得联系，以便第一时间取得修复。 一键安装 安装依赖 克隆本仓库 复制一份.env.example文件，并重命名为.env，修改对应的信息，并关闭调试模式 安装 升级 若您是使用手动安装的话请先确认git是否存在xknote-github的remote，如果没有，请添加后运行下方命令 手动安装手动安装较为复杂，请前往Github查看 文档 Doc暂无 Github求 star =￣ω￣= 维护者 MaintainerXK-Note 由 Otstar Lin和下列贡献者的帮助下撰写和维护。 Otstar Lin - Personal Website · Blog · Github 许可证 License 根据 Apache License 2.0 许可证开源。 渲染 Render "},{"title":"PHP GD图片处理[转换格式-水印-缩略图]","date":"2019-02-14T10:35:32.000Z","url":"/php-gd-image-processing.html","tags":["PHP","PHP-GD"],"categories":["折腾记录"],"content":" 最近准备弄一个图床，既然是图床就需要能对图片进行一些常用的操作，比如水印，转换格式，生成缩略图等，前几天刚好接触了PHP的GD库，于是便花了点时间封装了这个简单的图片处理函数。 "},{"title":"PHP GD生成验证码","date":"2019-02-14T04:39:21.000Z","url":"/php-gd-generates-verification-code.html","tags":["PHP","PHP-GD"],"categories":["折腾记录"],"content":" 此验证码功能将会添加到Origami主题中 "},{"title":"Origami - 简洁轻快的WordPress主题","date":"2019-02-05T05:49:20.000Z","url":"/theme-origami.html","tags":["Develop","Wordpress","Web","WordPress-Theme"],"categories":["折腾记录"],"content":" Origami v2现已发布，增加了许多功能，目前已经可以在WordPress中直接升级。 QQ群已建立，794691511(没人用的 Origami) 本主题谨献给在我博客道路上遇到的朋友们。 前言其实我很早就想自己写个主题了，由于一些原因我没能把这个想法实现，直到我察觉到最近博客的访问速度变得很慢，迫不得已 才制作了这个主题，主题的 UI 和排版参考之前的主题（我实在不会设计/_ \\） 现在大部分博主都将博客换成了 Hexo，我之所以还继续使用 WordPress 是因为 WordPress 的写文章和维护较为方便，而且我也不太熟悉 Markdown，另外也有非常多的插件加持，并且不需要第三方评论系统。现在更多的是因为 Gutenberg 编辑器才继续使用 WordPress。 Origami 主题Origami 即 折纸，为什么将这个主题称之为折纸主题呢？因为主题的风格偏向纸片化，大多元素都是方方正正的，扁平化设计，并且刚开始制作的时候期望它能像纸片一样轻盈。为什么我会喜欢这种风格呢？其实是我看腻了MD的设计，普通的扁平化设计又太“圆滑”，原主题的纸片化设计可以很好的维持长久的观看体验，但是也有比较大的缺点，就是配色不能太鲜艳，当时在调色的时候可头疼了＞︿＜ Origami v2 参考了 Aurora 主题的设计改成了 半透明 + 背景 的风格，配色使用了 Spectre.css 默认的配色。 Feature 特性 [独家] REST API 加载，发布评论 [独家] 评论者可在设置的时间内修改或删除评论，不必担心评论错误 [独家] Origami Markdown 区块(支持补全高亮，Gutenberg 区块) [独家] Origami 代码区块(支持补全高亮，Gutenberg 区块) Live Chat 实时聊天 REST API 实时搜索 前端修改主题 3 种布局风格 侧栏右置 / 左置 / 不显示 灵感 / 时光轴 / 友链模板 Markdown 评论 流程图 / 时序图 / 甘特图 / Katex 支持 Lazyload WorkBox 注册和卸载 OwO 表情 页脚显示建站至今的时间 评论者标注（站长，友链认证） 6 个短代码，多种页面模板 可视化编辑器和文本编辑器添加短代码 阅读转移 代码高亮 文章目录 ImgBox 评论页面选单 … Loading speed 加载速度Gtmetrix：100% (Pagespeed) 97% (YSlow) 0.6s (加载时间) Lighthouse：100% (Desktop) 100% (Mobile) web.dev：99% Loading time：946ms (第一次加载) 187ms (第二次加载，即有缓存情况) Demo 演示此博客即使用 Origami 主题（v2） Origami 演示站（v2） Docs 文档Wiki Features 功能请前往 Origami 演示站 查看 Install 安装前往 Releases 下载，若下载速度过慢可以到  进行下载（注意将x.x.x改为当前的版本号，此位置的Origami随时可能迁移），然后上传到 WordPress 中，确保主题文件夹名称为 Origami 首次安装请先将对主题进行设置，防止出现未知问题 从 v1 版本升级请在升级后重新对主题进行设置 若要启用 WordBox，请先将主题文件夹下的 js 文件夹中的 sw.js 复制至 WordPress 根目录 已经修复了 WorkBox 的缓存规则，这里说明一下，启用 WorkBox 会使用户的浏览器的请求完全被 WorkBox 接管，一旦启用后，页面的加载速度将得到质的提升，但是若要删除就必须加载卸载 WorkBox 的 js，否则用户访问的页面将不会更新 若站点使用 https，同时又需要引用 http 的资源，请将功能设置中的阻止混合内容关闭 Github求 star =￣ω￣= Maintainer 维护者Origami主题 由 Otstar Lin 和下列 贡献者 的帮助下撰写和维护。 Otstar Lin - Personal Website· Blog· Github License 许可证根据 GPL V3.0 许可证开源。 结语首先感谢你能看到最后，同时感谢你对该主题的兴趣。无论你是否已经完成建站，我都诚挚邀请你来尝试一下这个主题。 然后，这款主题是开发不久的，尽管我在发布的时候做了细致的测试，也难免存在 Bug，若你在使用中遇到问题，请及时联系我进行修复。 由于第一次接触这种“大型项目”，项目中的代码可能非常混乱，我会在未来继续优化代码 另外，Origami 主题是免费发布的，根据 GPL V3.0 许可证开源，你不需要为此付出任何费用，但是，你必须保留底部的 Theme - Origami By Otstar Lin 标识。"},{"title":"为WordPress启用WorkBox","date":"2019-02-02T12:45:46.000Z","url":"/wordpress-enabled-workbox.html","tags":["Wordpress","Service Worker","WorkBox"],"categories":["折腾记录"],"content":" 若你是一个追求极致Web体验的站长，那你一定或多或少都听说过Service Worker，而现在已经是2019年了，Service Worker已经不是一项令人惊叹的技术了，Service Worker会接管全站的请求，若一不留神用户说不定就再也无法看到站点最新的资讯了，不过Google Chrome 团队推出了 Workbox，使编写缓存规则不再困难。 本文是面向WordPress的教程，不适用于Typecho 使用方法注册Service Worker在主题的functions.php加入以下代码 引入WorkBox框架 若成功引入就会在浏览器的控制台中输出Yay! Workbox is loaded ? 同时可以在开发工具中的Application选项卡中的Service Workers中看到激活信息 写入规则由于WordPress是动态博客，所以在写规则的就会遇到一些静态博客不会遇到的问题，比如静态博客的页面是已经渲染好的，只要缓存html等静态文件就可以实现离线访问，而php的页面是实时渲染的，并且有后台，还有评论系统，这些都不能进行缓存 建议安装WP Super Cache 首先定义缓存的版本号和默认最大缓存数目（可以忽略，但后面的代码需要进行修改） 然后限制必须使用网络的资源 结尾至此站点除了后台，其他的页面应该就可以进行全站离线访问，但是由于使用了缓存，若站点未将评论分离的话，就会导致评论不能实时更新，这时候就可以使用第三方评论系统来代替默认评论，如Disqus（国内处于被墙状态） 我的新主题已经使用了WorkBox，可以去尝试一下 Link 从缓存中的加载页面的速度可以达到惊人的219ms "},{"title":"[青空之蓝-2018]-年度总结","date":"2018-12-30T19:13:32.000Z","url":"/my-blog-2018-year-end-summary.html","tags":["年度总结","博客记录"],"categories":["站长杂谈"],"content":" 又到了一年一度写年度总结的时候，博主我从29号就准备开始写，一直咕咕到了31号，是时候回顾一下2018了。 配乐是博主从歌单随便选的，可听可不听 [hermit autoplay=”false” mode=”circulation” preload=”auto”]netease_songlist#:28661195[/hermit] 往事2018年前半年博主由于是高三学生，为高考努力着，相对平淡，没有什么能值得回忆的事，也忘记了许多事，但是还依稀记得当初东拼西凑的完成了Toastr.js其实是从文章中看到的，主页貌似也换了几代 2018年6月8号考完后正式解放了，终于有了点时间弄点奇奇怪怪的东西，将主页换成了现在的样子，其实也是从网上找的模板，但是加了一些新奇的东西，比如延迟加载啦，貌似也只加了延迟加载 7-8月由于在学车，所以文章各种咕咕咕，只是优化了博客的访问，添加了部分特效，并未学习任何技术。 9月进入大学后有了许多时间，用了一个月将大一C语言学完了，之后学习了Java，Python，但是都只学到了表层，至今还未学完，目前正在苦逼的复习中，防止期末挂科＞﹏＜。 站点部分已经在上方说了，这里就重新整理下 博客主题换成了Grace，并沿用至今 博客从去年年底迁至VirMach并使用到3月 4月博客迁至Vultr，然后博客访问速度逐月下降 8月迁至Hostwinds，直到现在还在用 博客Grace主题被我多次修改，将原本古老的a配色调成了现在的浅蓝色 导入了canvas-nest.js，就是博客背景那些会动的小点，刚加上去的时候玩了一个多小时(￣▽￣)” 博客4月换了域名，一个月后，谷歌,必应,百度等搜索引擎收录 为博客增加了Toast通知 主页改版，并加入了伪按需加载 同时为主页和博客启用Service Worker，二次加载缩短至1秒内，前提是访问的设备不会太垃圾 前几天修改评论插件的一些细节 其他大多都记不住了。。。。 友人友链24个，2018年我加入了Zohar大佬创建的TG群，群里除了我个个都是大佬，从群里认识了许多有趣的人，有Zohar、Axton、LWL、Sukka、Edison Jwa、Elepover、Fly、立音、Indexyz、Meto、Milkice等等。。。，线下也认识了⑨BIE大佬 除此之外，我还认识了新的同学，都是一些志同道合的优秀人士 首先要感谢[博主交流群]中的友人们，是你们将我引领进神奇的互联网，使我能够了解Web各种方面的技术。 也感谢能与我共度互联网的朋友们。 未来 繁忙的高中已经结束，进入了大学，专业又是计算机科学与技术，所以未来都是研究这些东西，搞搞新奇的小玩意等等，这里就随便写写吧 将Java学完，同时学习Spring Boot框架 学习Python和前端 看完想看的书籍 还有其他的暂时还没想到。。。 尾声写了挺久的，具体时间没统计，应该有一个多小时吧，大多时间都在想要写什么(￣▽￣)” 2019我将会咕咕咕积极更新文章，同时提高文章质量，给能来我这已经长满杂草的博客的人士最大的帮助。。。 无论如何，感谢你能读到最后。新的一年，让我们继续努力吧！ 2019望一切顺利，祝各位新年快乐。 "},{"title":"Windows IP变化自动发送邮件","date":"2018-12-30T09:18:40.000Z","url":"/windows-ip-changes-to-automatically-send-mail.html","tags":["Lab","Python"],"categories":["分享推荐","折腾记录"],"content":" 由于学校的机房使用的IDE过于坑爹，什么VC6.0啦，VS2008啦，DEV-C++啦，一点补全功能都没有，Java用的是反人类的Eclipse，无奈只能远程连接我的工作站，其实就是垃圾笔电啦，这时就需要知道笔电的IP，然而学校并不提供固定IP，什么时候变化都不可知，若IP变了然而我不知，上课时只能咕咕了，所以只好造个通知的脚本来检查IP变化，并在变化时发送邮件通知我 原理还要什么原理，就是执行windows的ipconfig命令然后提取其中的IPv4地址，与之前检测存储的IP进行比较，若相同，则IP不变化，若变化就写入新的IP，同时调用发送邮件的脚本 实现本文使用Python3来开发，所以需要先装好Python3的环境，至于为什么要用python来开发，请看上一篇文章，其实就是Java要导入jar包，之前没解决如何jar包，无奈只能使用不太熟悉的Python来开发 检查脚本 发送邮件脚本 博主偷懒就只发送ipconfig的返回值，没切片得出IP，需要的可以将切片代码从检查脚本复制到通知脚本即可"},{"title":"VSCode Java手动导入jar和源码包","date":"2018-12-30T08:45:59.000Z","url":"/vscode-java-manually-imports-jar-and-source-package.html","tags":["Java","VSCode","开发环境"],"categories":["折腾记录"],"content":" 使用Maven等包管理的可以不用向下看了，以下只讲述如何为普通Java项目导入单独的jar包 之前有一篇文章讲述了如何配置VSCode的Java调试环境，博主我从配置成功使用到现在一直只使用了JDK自带的包，直到昨天由于有一个项目需要进行邮件发送，需要引入Mail包，网上的教程大多是在JDK中引入jar包，但是这时VSCode会报一大堆莫名奇妙的错误，然而实际运行JVM却没有报错，直到今天学习JDBC时Eclipse导入jar包时才发现可以在每个Java项目中独立导入jar包，然而VSCode又该如何导入jar包？ 探索在之前的教程中我的方案时利用一个插件来创建Java项目，而创建的Java项目就是Eclipse项目（VSCode支持Eclipse项目），创建项目后我们看到在项目文件夹中有两个子文件夹，一个用来存源码，一个用来存class文件，另外还有两个文件一个是.classpath文件，一个是.project文件，通过从Eclipse导出添加过jar和源码的项目可以发现，在.classpath的文件中多了一行配置 从中可以看到，在VSCode中引入jar包只需将jar的路径填入到path中，源码路径填入到sourcepath中即可 实现第一步：在项目文件夹中添加一个lib目录，一般引入的jar包都存储在lib目录，方便后续操作 第二步：将要引入的jar包复制到lib目录下 第三步：修改.classpath文件，增加一行classpathentry，并填入正确的路径，可以填相对路径，也可以填绝对路径 若不导入源码只需将sourcepath属性删除即可 若要导入源码请继续往下 第四步：在lib目录中新建一个sources文件夹，然后将该jar包的源码复制到该文件夹即可 第五步：在该jar包的classpathentry标签中增加sourcepath属性，并填入正确的路径 第六步：Ctrl+S保存，然后回到java文件，此时一堆莫名奇妙的报错应该都已经消失了，若还存在，请重新启动VSCode或者重置VSCode中的Java环境 结语这时有些人可能会吐槽这么麻烦为什么不换其他的IDE，因为已经掉入了VSCode的坑里爬不出来了，各种神奇的插件，非常快的启动速度，以及多种编程语言快速切换，博主我有多个工作区，比如C和Java的，切换时只需关闭目前的工作区然后切换另一个工作区，VSCode就会将该语言的编译环境自动加载，同时VSCode的代码补全也是极为方便的，基本只需要打两个字母然后按下Tab键，VSCode就能完成正确的补全，这时就要吐槽一下Eclipse反人类的补全快捷键，大多编辑器和IDE的补全快捷键都是Tab键，然而Eclipse却是不同寻常的Enter键，用起来实在难受，然而学校机房就是使用Eclipse（捂脸"},{"title":"C 结构体的定义和使用","date":"2018-12-26T08:20:53.000Z","url":"/definition-and-use-of-the-c-struct.html","tags":["C/C++"],"categories":["折腾记录"],"content":" 应同学请求更新了这篇文章，正好没有水文的借口 （逃 1.前言在C语言中结构体指一种数据结构，是C语言中复合数据类型，结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员，且这些成员可以为不同的类型，成员一般用名字访问。 与Java中的类类似一个结构体看可以看作是一个类别，某类事物的集合体，比如要表示一本书的各种属性（作者，页数，出版时间等），在没有使用结构体的时候，就需要使用各种基本数据类型进行存储，这时会发现在表示数据的时候乱七八糟的，调用的时候也不容易调用，但如果使用了结构体，那结构体名称就可以使用书名表示，书的各种属性就可以放在结构体中，在使用的时候可以很直观的用结构体名称（书名）调用 2.实践定义结构在使用结构体的时候需要定义结构体，可以不先定义结构体变量，但必须先定义好结构体的结构 tag : 结构体的标志，可以不设置，但是如果不设置就必须在定义时声明variable-list，一般使用全大写表示，建议每个结构体都要有tag member-list : 结构中的成员，在定义的时候必须定义结构体中的所有成员 variable-list : 结构体变量列表，若不声明就必须要有tag，可以声明多个，使用逗号隔开，也可声明结构体数组 定义时也可以使用typedef来创建一个数据类型，下面会针对这两种定义方式进行分析 嵌套结构体 声明结构体变量结构体变量可以紧跟结构体后创建，不过由于结构体在函数外创建，所以紧跟结构体后声明的结构体变量是全局变量 还有一种是在函数中创建 使用typedef的创建 创建结构体指针 访问结构体成员创建好了结构体变量后才能进行访问 3.结语结构体是C语言和多种类C语言中的一种数据结构，在Golang，C#，C++都有结构体，但是除了Golang，其它两种语言都支持面向对象，所以一般很少用到，但是在C中它是非常重要的，。。。。。。。。。编不下去了(￣▽￣)” （逃"},{"title":"C链表实现重制版","date":"2018-12-26T02:42:20.000Z","url":"/c-linked-list-implementation-new.html","tags":["算法","C/C++"],"categories":["折腾记录"],"content":" 重写了C链表的算法，将原本多个函数整合成一个函数，并且保留原本功能的函数，只不过现在是通过调用父函数实现，也就是子函数通过调用一个集成了多种功能的父函数实现部分父函数功能，减少了大量的代码，另外目前新算法是在之前写的Java链表的基础上写的，并且改进了部分代码，重新看了一遍自己写的Java链表才发现还有许多不足，不久后将会在这个算法上修改自己写的Java链表，(￣▽￣)” [alert-success]Coding了两个小时终于将排序部分弄完了，这次加入了快速排序，链表的排序不再缓慢 &lt;-这是不可能的，其实快速排序在某些情况下的速度会降到O(N^2)，正常情况下的时间复杂度是O(NlogN)，还加入了两个获取数据的函数[/alert-success] "},{"title":"图的搜索(遍历) - BFS & DFS","date":"2018-12-19T05:02:14.000Z","url":"/graph-search-bfs-dfs.html","tags":["Develop","算法","C/C++"],"categories":["折腾记录"],"content":" BFS，即 Breath First Search（广度优先搜索） DFS，即 Deep First Search （深度优先搜索） 图的搜索是对于连通图的一种遍历策略，常用于走迷宫的问题 本文的算法基于C语言编写，过几天会使用Java重写这两个算法 另外本文的算法是对基于数组的图进行搜索，基于链表的搜索暂时未弄 （逃 1.BFS广度优先搜索顾名思义，就是在广范围进行搜索，从一个顶点V0开始，辐射状地优先遍历其周围较广的区域 算法的基本思路在广搜中不需要记录节点是否走过，但是要记录上一个节点的位置，若将整个过程画成树，即可观察到广搜是一层一层进行遍历的（这里就不画图了，逃），这时若要搜索下一层节点就需要读取上一层节点的位置，并对父节点的所有节点逐个进行搜索，将符合要求的子节点逐个存入下一层节点，直到判断到达终点即停止搜索 基础算法采用递归，存储搜索各层节点采用队列，但由于C语言中没有队列所以采用结构体数组代替，使用二维结构体数组，其中一维对应层数，另一维存储该层的节点，另外若要使广搜拥有寻迹功能，即可以输出行进路程中每一步，就需要在结构体中增加一个结构体指针指向父节点，然后记录最后一个节点的地址，通过访问指针来访问父节点，直到到达起点 算法的实现 本算法由于要进行寻迹操作，所以保留了每一层的数据，若不需要寻迹建议只保留两个队列，即两个一维结构体数组 2.DFS深度优先搜索类似于广度优先搜索，也是一种图的搜索算法，但是不同于广度优先搜索，广搜注重范围，而深搜注重深度，通俗来说，广搜就是广撒网，深搜就是一路走到黑，不撞南墙不回头\\(￣︶￣\\)) 算法的基本思路深搜需要定义一个跟原图相同的数组，然后通过该数组对数据进行标记，若已经走过就标记，回到父节点时将父节点的标记取消，基础算法依旧使用递归 算法的实现 两种算法的比较广搜由由于需要维护多条路径，同时存储多条路径，所以在正常情况下广搜使用的内存会比深搜多，编写也相对复杂，但是由于广搜一般是采用队列来存储路径所以没有爆栈的危险（C语言不适用），而深搜是使用栈进行存储的，由于系统分配给程序的栈是有限的，所以当深度过高时深受可能会出现爆栈。 一般来说用DFS解决的问题都可以用BFS来解决。DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，资源的消耗也较多。但是在不同问题中两者占优的情况是不同的，当图较为复杂二者其实差别不大。"},{"title":"Java链表实现","date":"2018-11-29T14:40:03.000Z","url":"/java-linked-list-implementation.html","tags":["Develop","算法","Java"],"categories":["折腾记录"],"content":" 转换阵营ing，大部分的介绍都在注释写了，这里就不再重复了，注释中没有关于链表的原理，如果还不懂链表的可以先去看其他教程，这里不写主要是我比较懒(￣▽￣)” [alert-success]之前的算法有问题，现在已经修改完成，并重写了部分代码，对数据域使用泛型，可以存放任何对象了，存放不同数据类型时就不再需要定义多个链表类了ヾ(≧▽≦*)o[/alert-success] [alert-note]这个算法还有优化的空间，不久后将升级，心急的可以看C链表重置版然后将其改成Java即可[/alert-note] "},{"title":"C 快速排序","date":"2018-11-27T03:24:10.000Z","url":"/c-quick-sort.html","tags":["Develop","算法","C/C++"],"categories":["折腾记录"],"content":" 开头和介绍都是不存在的（￣︶￣）↗ 这次是真修复了，坑爹呀，LintCode提交了好几次，终于AC了，应该是没问题了≧ ﹏ ≦，另外我这代码只能算还行只打败了51%的提交 （捂脸 "},{"title":"C 归并排序","date":"2018-11-20T06:10:13.000Z","url":"/c-merge-sort.html","tags":["Develop","算法","C/C++"],"categories":["折腾记录"],"content":" 懒得写开头，过几天应该会添加(￣▽￣)” [alert-warning]终于将排序算法修复完成啦！！！，目前已经不需要判断是否是奇数个了ヾ(≧▽≦*)o[/alert-warning] "},{"title":"C 插入排序","date":"2018-11-20T02:45:15.000Z","url":"/c-insert-sort.html","tags":["Develop","算法","C/C++"],"categories":["折腾记录"],"content":" 懒得写开头了(_ _)。゜zｚＺ，继续下一个排序算法 "},{"title":"C语言链表实现","date":"2018-11-12T12:51:26.000Z","url":"/c-linked-list-implementation.html","tags":["Develop","C/C++"],"categories":["折腾记录"],"content":" 先放代码，开一波坑，以后慢慢填ヾ(≧▽≦*)o 由于我在上传的时候未进行完整测试，导致排序部分有些问题，现已修改完成。 另外排序部分只弄了int型的排序 改指针相关的东西真头真疼，特别是链表，折腾了一个多小时。〒▽〒 [alert-success]重写升级完成，这个算法目前除了排序还有用其他就没有用了，可以点这里直接跳转到重制版[/alert-success] #include &lt;stdio.h&gt; #include &lt;malloc.h&gt;//链表结构typedef struct Test{ int data; struct Test next;}Test,pTest; //头插法-创建pTest Create_Head(int n/链表包含节点个数/){ int i,data; pTest list,node; //创建头节点 list = (pTest)malloc(sizeof(Test)); list-&gt;next = NULL; for(i=0;i&lt;n;i++) { //创建临时节点 node = (pTest)malloc(sizeof(Test)); //读入数据 printf(“请输入第%d个数据\\n”,i+1); scanf(“%d”,&amp;data); //将数据存入临时节点的数据域中 node-&gt;data = data; //将list头节点的next指针复制到node头节点的next指针 node-&gt;next = list-&gt;next; //将node链表指针结合到list头节点的next指针 list-&gt;next = node; } //初始化头节点数据 list-&gt;data = 0; return list;} //尾插法-创建pTest Create_End(int n/链表包含节点个数/){ int i,data; pTest list,node,p; //创建头节点 list = (pTest)malloc(sizeof(Test)); list-&gt;next = NULL; //将副本链表指向list用来间接为list指针域赋值 p = list; for(i=0;i&lt;n;i++) { //创建临时节点 node = (pTest)malloc(sizeof(Test)); //读入数据 printf(“请输入第%d个数据\\n”,i+1); scanf(“%d”,&amp;data); //将数据存入临时节点数据域 node-&gt;data = data; //将副本最后的指针域指向临时节点 p-&gt;next = node; //将临时节点的指针域置NULL node-&gt;next = NULL; //移动副本节点使最新的指针域成为副本链表的最后一个 while(p-&gt;next != NULL) { p = p-&gt;next; } } //初始化头节点数据 list-&gt;data = 0; return list;} //添加节点至指定位置pTest Insert_pos(int i/要添加到什么位置/,pTest list/要进行添加节点的链表/){ int data; pTest node,p,temp; //创建list链表的副本 p = list; //修改位置为实际位置 i = i - 1; //调整链表指针域位置,临时链表的头节点到达要添加的节点的上一个节点 for(int u = 0; u &lt; i; u++) { p = p-&gt;next; } //创建临时节点 node = (pTest)malloc(sizeof(Test)); temp = (pTest)malloc(sizeof(Test)); //读入数据 printf(“请输入第%d个数据\\n”,i+1); scanf(“%d”,&amp;data); //读入数据到临时节点的数据域 node-&gt;data = data; //将目前节点的next即下一个节点的地址临时存起来 temp-&gt;next = p-&gt;next; //把目前节点的next改为node节点，即进行插入 p-&gt;next = node; //将node的next改为之前没修改时的下一个节点地址 node-&gt;next = temp-&gt;next; //返回修改好的链表 return list;} //添加已经拥有数据的节点pTest Insert_pos_own(int i/要添加到什么位置/,pTest list/要进行添加节点的链表/,pTest node){ int data; pTest p,temp; //创建list链表的副本 p = list; //修改位置为实际位置 i = i - 1; //调整链表指针域位置,临时链表的头节点到达要添加的节点的上一个节点 for(int u = 0; u &lt; i; u++) { p = p-&gt;next; } //创建临时节点 temp = (pTest)malloc(sizeof(Test)); //将目前节点的next即下一个节点的地址临时存起来 temp-&gt;next = p-&gt;next; //把目前节点的next改为node节点，即进行插入 p-&gt;next = node; //将node的next改为之前没修改时的下一个节点地址 node-&gt;next = temp-&gt;next; //返回修改好的链表 return list;} //删除指定位置的节点pTest Delete_pos(int i/要删除第几个节点/,pTest list/要进行删除节点的链表/){ pTest p,temp; //创建临时节点 temp = (pTest)malloc(sizeof(Test)); p = list; //调整实际位置 i = i - 1; //调整链表指针域位置,临时链表的头节点到达要删除的节点的上一个节点 for(int u = 0; u &lt; i; u++) { p = p-&gt;next; } //将要删除的节点的下一个节点的地址存入temp的指针域 temp = p-&gt;next-&gt;next; //将temp的指针域赋给要删除节点的指针域 p-&gt;next = temp; //free(temp); //返回修改后的链表 return list;} //清空链表,保留头节点pTest Clear_List(pTest list){ pTest p = list-&gt;next; //移动到第一个结点 pTest q; while(p) { //printf(“%d\\t”, p-&gt;data); q = p; p = p-&gt;next; free(q); } list-&gt;next = NULL; return list;} //遍历链表pTest Print_List(pTest list){ pTest p; p = list-&gt;next; //移动到存放真实数据的第一个结点 while(p) { printf(“%d\\t”, p-&gt;data); p = p-&gt;next; } printf(“\\n”); return 0;} //链表逆置pTest Resever(pTest list){ pTest p, q, r; p = list;//P指向头结点 q = p-&gt;next; //q指向第一个结点 while(q-&gt;next) { r = q-&gt;next; q-&gt;next = p; p = q; q = r; } q-&gt;next = p; //连上最后一个结点 p = list-&gt;next; p-&gt;next = NULL; //收尾 list-&gt;next = q; //赋头 return list;} //链表排序-从小到大pTest Bubble_Sort(pTest list){ //定义排序个数和下标的变量 int n = 0, i, j, k; //定义判断链表个数的链表和用来判断大小的链表 pTest p = list, temp; //判断链表的个数 for(;p-&gt;next!=NULL;p = p-&gt;next) { n++; } //外层循环控制循环轮数 for(i = 0; i &lt; n; i++) { //内层循环控制每轮比较次数 for(j = 0; j &lt; n; j++) { //遍历比较相邻链表数据的大小 temp = list; //移动比较用的链表 for(k=0;k&lt;j;k++) { temp = temp-&gt;next; } if(temp-&gt;data &gt; temp-&gt;next-&gt;data) { //交换的方式是先删除大数据的节点，然后在添加回链表 //删除大数据的节点 list = Delete_pos(j,list); //将删除后的节点添加会链表的下一个节点 list = Insert_pos_own(j+1,list,temp); }; } } return list;} int main(){ pTest list = Create_End(5); list = Bubble_Sort(list); return 0;}"},{"title":"VSCode配置Java调试环境[Windows]","date":"2018-11-06T12:04:27.000Z","url":"/vscode-configuration-java-gdb-debugging-environment-windows.html","tags":["Develop","Java","VSCode"],"categories":["折腾记录"],"content":" 其实Java环境我很早就开始配置了，但是一直有问题，今天又手贱尝试了一下，没想到就成功了，即时更新博文是我的习惯 （防止被打死，赶紧逃(/ω＼) 环境准备JDK下载 JDK 并进行安装，我比较推荐安装Java SE8，另外下载时记得点上Accept License Agreement，否则点击不会反应 打开PowerShell或者CMD，输入 java -version 和 javac -version如果没提示错误信息就代表JDK配置成功 正常情况下JDK安装时是不会自动配置环境变量的，所以javac -version一般都会提示错误，这时只需将JDK目录下的bin目录添加到环境变量即可，具体操作请自行搜索或者查看VSCode配置C/C++ GDB调试环境[Windows] VSCode 按下 Shift+Ctrl+P进入命令面板 新版的 VSCode Java 插件已经可以直接创建项目，不再需要使用 Eclipse New Java Project 这个插件来创建项目了。 然后在src文件夹内创建一个 HelloWorld.java文件 然后点击F5，就会发现在父文件夹下多了一个.vscode文件夹，里面有一个launch.json文件，不进行配置的话也可以进行运行，但你是否发现没有出现界面，这时还需要修改一个值 这时再次点击F5就可以正常调试了 2019-06-29更新VSCode的Java插件包现在似乎添加了自动安装JDK的功能和一些常用函数的补全 相关文章"},{"title":"C 选择排序","date":"2018-10-27T15:11:28.000Z","url":"/c-select-sort.html","tags":["Develop","算法","C/C++"],"categories":["折腾记录"],"content":" 就按上一篇的格式写吧，其实还有很多C笔记可以水几篇文章，偷懒中。。 [alert-success]此算法已修复，放错了交换代码的位置，导致出现问题，我果然是菜鸡(￣▽￣)”[/alert-success] 思想和举例选择排序同样是通过遍历的方式进行比较排序的，只不过不再是通过不断交换相邻的两个数字，而是遍历搜索最大或最小值然后将最大值或最小值与最后方或者最前方的值进行交换，以此类推直到最后完成排序，具体排序的过程可以查看维基百科，偷懒。。 看什么呢，没有举例~(￣▽￣)~ 算法总结与实现不用介绍了直接上算法吧(￣▽￣)” #include &lt;stdio.h&gt; #define N 10 //定义要排序的数组长度 //选择排序控制Demo//选择排序结果和方式//结果：输出排序的数组//方式：遍历比较 //本例排序从低到高 int main(int argc, char const *argv[]){ int nums[N], temp, j, i; printf (“请输入要进行排序的数列：\\n”); for (int u = 0; u &lt; 10; u++) //循环输入数组 { scanf (“%d”, &amp;nums[u]); } } 对了，这次采用了循环输入，不用再写很长的输入了ヾ(≧▽≦*)o"},{"title":"C 冒泡排序","date":"2018-10-05T06:28:41.000Z","url":"/c-bubble-sort.html","tags":["Develop","算法","C/C++"],"categories":["折腾记录"],"content":" 冒泡排序，在学到循环和数组的时候肯定会接触到这个最基本的排序算法。为什么这种算法要叫做冒泡排序呢？是因为这个排序算法有点像水泡向上冒。在大学计算机的课程中一定会讲到的排序方法，博主我作为计科的一员也是要学习的，先行偷学ing （逃 思想与举例冒泡排序的基本思想就是不断比较相邻的两个数，让较大的元素不断地往后移。经过一轮比较，就选出最大的数；经过第2轮比较，就选出次大的数，以此类推。 下面以6 2 5 3进行举例说明 第一轮排序 6 2 5 3（初始） 2 6 5 3（2 6交换） 2 5 6 3（5 6交换） 2 5 3 6（3 6交换） 第二轮排序 2 5 3 6（初始） 2 5 3 6（2 5不变） 2 3 5 6（3 5交换） 至此由小到大的排序已经完成。 算法总结与实现首先创建数组nums[N]然后进行N-1轮的比较，然后在每轮中进行逐个比较，若不符合大小排序则进行交换，直到所有数符合大小排序 #include &lt;stdio.h&gt; //冒泡排序控制Demo//冒泡排序结果和方式//结果，使不按大小排序的数组，通过排序后按大小排列//方式，遍历比较 ////排序方式从高到低// int main(int argc, char const *argv[]){ int i,j,temp,n; int nums[10]; //要进行排序的数组 printf (“请输入10个数字\\n”) scanf (“%d %d %d %d %d %d %d %d %d %d”,&amp;nums[0],&amp;nums[1],&amp;nums[2],&amp;nums[3],&amp;nums[4],&amp;nums[5],&amp;nums[6],&amp;nums[7],&amp;nums[8],&amp;nums[9]); }"},{"title":"VSCode配置PHP调试环境[Windows]","date":"2018-09-06T17:20:06.000Z","url":"/vscode-configuration-php-gdb-debugging-environment-windows.html","tags":["Develop","PHP","VSCode","开发环境","断点调试"],"categories":["折腾记录"],"content":" 没有灵感,连续水一波 (逃 其实是我刚配好,比较健忘,以后重新配置的时候方便 环境准备XAMPP&amp;XDebug下载 XAMPP 并安装记好安装路径,后面会用到 打开XAMPP开启Apache,获取PHP info,进入PHP info页面后直接全选复制,全部复制到 XDebug 检测网址 中的输入框中,点击后网站会分析出你当前的 php 环境最适合的 xdebug 版本,并给出下载链接,下载完成后，将该文件复制到 php 的扩展目录中,即安装目录中的 ext 文件夹下 打开XAMPP,进行配置php.ini 编辑php.ini,在最下方添加以下代码,路径记得更改 VSCode 配置VSCode 找到XAMPP的网站文件夹,即htdocs文件夹,在htdocs下创建你的工作区(文件夹),然后在VSCode中打开此文件夹,然后创建一个测试用的PHP文件 接着照着以下操作配置 至此VSCode PHP调试环境就配置完成了,接下来就是重(坑)磅(逼)的断点调试技巧断点调试返回刚创建的php文件 开始愉快的调试吧 (逃"},{"title":"VSCode配置C/C++ GDB调试环境[Windows]","date":"2018-09-04T04:23:40.000Z","url":"/vscode-configuration-c-cpp-gdb-debugging-environment-windows.html","tags":["Develop","C/C++","VSCode","开发环境","断点调试"],"categories":["折腾记录"],"content":" 折腾了两个小时，终于把VSCode调试环境弄好了 （开心 环境准备VSCode安装C/C++ for Visual Studio Code 插件 按下 Ctrl+Shift+X 在搜索框中输入 C/C++ 安装第一个插件 至此VSCode环境部分配置完毕 GDB安装MinGW 下载 MinGW 点击Continue开始安装，安装过程需联网，若安装时提示error则需使用梯子进行安装 当Continue按钮恢复为可用状态，点击完成安装 GCC环境安装 打开MinGW 选中左栏的Basic Setup,然后选中mingw32-gcc-g++-bin,右键选择Mark for installation 选中All packages,找到mingw32-gdb-bin,mingw32-gdb-doc,mingw32-gdb-info,mingw32-gdb-lang,mingw32-gdb-lic,mingw32-gdb-man,右键选择Mark for installation 点击左上角的installation,然后点击Apply Changes 点击Apply,等待安装完成,点击close 至此GDB环境部分配置完成 MinGW配置较为繁琐，可以考虑使用MinGW64，MinGW64安装后就不需上方的配置，一路点击下一步即可。（但是还是要配置环境变量 添加环境变量 进入设置,点击系统,然后选择关于,然后点击右侧系统信息 在弹出的系统信息中,选中左栏高级系统设置,然后选中环境变量 在系统变量一栏中找到Path,双击,然后新建一个C:\\MinGW\\bin 的变量 一路确定,直到关闭所有选卡 重启电脑 配置VSCode新建一个cpp文件,写上以下测试代码 Ctrl+S保存,然后按F5,VSCode会在上方弹出选择环境,选择C++(GDB/LLDB),然后将以下代码覆盖至launch.json,注意miDebuggerPath路径要对应 回到新建的cpp中,按下F5,会显示找不到任务,点击配置任务,点击使用模板创建,然后点击带有Other的选项,用以下代码覆盖tasks.json Ctrl+S保存,然后回到新建的cpp,按下F5,程序就会被编译运行,至此GDB调试环境便配置完成. 对了,C/C++也是可以进行断点调试的,具体方法可以参考 VSCode配置PHP调试环境[Windows] 在使用过程中你可能会遇到输入或输出中文乱码的问题，此时只需要将文件改成 GB2312 编码即可"},{"title":"WordPress友情链接模板","date":"2018-08-28T05:28:51.000Z","url":"/wordpress-links-template.html","tags":["PHP","Wordpress","Mysql","Web"],"categories":["折腾记录"],"content":" 没错又是一篇水文 （逃 使用此模板需要安装Link Manager插件，模板文件已上传至Github，可以直接取用。 最终效果请自行查看本站友情链接页面代码部分&lt;?php/* * Template Name: 友情链接 */get_header(); ?&gt; &lt;?php if (have_posts()): ?&gt; &lt;?php while (have_posts()) : the_post(); ?&gt; &lt;?php the_title(); ?&gt; &lt;?php the_content(); ?&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; ?&gt; .clearfix { zoom:1; } .clearfix:after { content:”.”; display:block; visibility:hidden; height:0; clear:both; } .readers-list { list-style:none; } .readers-list *{ margin:0; padding:0; } .readers-list li{ position:relative; float:left; margin:6px 6px; height:205px;!important; } .readers-list li &gt; a { border: 1px solid #eee; display: block; width: 100%; height: 100%; text-align: center; transition:all .5s; -webkit-box-shadow: 0 2px 1px -1px rgba(0, 0, 0, .2), 0 1px 1px 0 rgba(0, 0, 0, .14), 0 1px 3px 0 rgba(0, 0, 0, .12); box-shadow: 0 2px 1px -1px rgba(0, 0, 0, .2), 0 1px 1px 0 rgba(0, 0, 0, .14), 0 1px 3px 0 rgba(0, 0, 0, .12); } .readers-list li&gt;a { -webkit-transition: -webkit-box-shadow .25s cubic-bezier(.4, 0, .2, 1); transition: -webkit-box-shadow .25s cubic-bezier(.4, 0, .2, 1); transition: box-shadow .25s cubic-bezier(.4, 0, .2, 1); transition: box-shadow .25s cubic-bezier(.4, 0, .2, 1), -webkit-box-shadow .25s cubic-bezier(.4, 0, .2, 1); will-change: box-shadow; } .readers-list li&gt;a:hover, .readers-list li&gt;a:focus { -webkit-box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12); box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12); } #links_info { position: absolute; bottom: 0px; padding-bottom: 10px; background: #000; width: 100%; height: 200px; -webkit-mask : -webkit-gradient(linear, center top, center bottom, from(rgba(0,0,0,0)), to(rgba(0,0,0,0.7))); } #links_icon { width: 70px; height: 70px; position: absolute; border-radius: 50%; top: 15px; right: 15px; } .readers-list em{ position: absolute; top: 110px; left: 15px; font-size: 25px; color: #fff; } .readers-list span { position: absolute; top:155px; font-size: 18px; left: 15px; width: auto; color: #fff; font-style: italic; } @media(min-width:750px){ .readers-list {margin: 0px auto;width:750px;} .readers-list li{width:355px;} } @media(max-width:749px){ .readers-list {margin: 0px auto;width:375px;} .readers-list li{width:355px;} } &lt;?php global $wpdb; $qlink=”select link_url,link_name,link_image,link_notes,link_description,link_rss from wp_links where link_visible=’Y’ order by link_id”; $links = $wpdb-&gt;get_results($qlink); if(empty($links)) { echo ‘暂无友链数据！‘; } foreach ($links as $comment){ $tmp = ““.$comment-&gt;link_name.”“.$comment-&gt;link_notes.”“; $output1 .= $tmp; } $output1 = ““.$output1.”“; echo $output1; ?&gt; 此页模板由Otstar-Lin于2018制作,源码已上传至Github &lt;?php get_footer(); ?&gt; 使用方法安装Link Manager插件并激活，在主题模板的文件夹新建一个PHP文件，将上面的代码复制进去并保存，或者去Github下载已经弄好的文件，并确定文件权限无误，进入WordPress后台，添加一个页面，选择友情链接模板进行创建，之后就可以在链接菜单进行添加了。 图像地址对应背景图 RSS地址对应友人头像 备注对应友链简介 保留the_content()函数，可以在编辑器中添加内容。"},{"title":"Intel Optane 傲腾内存体验","date":"2018-08-21T13:52:53.000Z","url":"/intel-optane-experience.html","categories":["折腾记录"],"content":" 前天我拿到了购买已久的神舟ZX6-CP5T（吐槽一下垃圾顺丰，陆运实在慢），这台笔电的存储方案是1T 5400转机械硬盘+16 G傲腾内存，别问我为什么不买SSD+机械，因为我没钱T_T。 Intel Optane 是什么3年前Intel与镁光合作开发3D XPoint，这种技术拥有DRAM的低延迟以及NAND的非易失，而Intel Optane是目前能以最低价买到的3D XPoint设备。 Optane内存的接口是NVMe M.2，但在神舟ZX6-CP5T中Optane内存并非插在NVMe M.2上，而是插在NGFF M.2上（推测并非准确，主板上只有一个插槽标明Optane可使用），Optane内存可以加速除本体外的本机硬盘（包括SSD，机械硬盘），加速效果很明显，但也有一堆缺点。 Optane的缺点 没错，先说缺点就是要打消你们剁手的念头(｢･ω･)｢ 装上后不能随意拔插（换插槽都不行） 首次安装需要重装系统 启用后随意进BIOS 在BIOS中取消加速并分离磁盘RAID很慢 目前只能在Windows下进行加速 只有7代或以上平台能使用 取消加速后会让你想砸掉电脑 随意拔插Optane内存或者被加速的存储设备会导致电脑无法引导启动，并且需要一进行一系列操作才能恢复，具体方法请在下方寻找 取消加速后开机时间3分钟以上（Win10系统） 启用加速后进入BIOS会导致不能加速，需要重新配置 Optane的优点最大的优点就是能让10年前的垃圾机械也能焕发新机，对Win10系统的加速效果非常明显，开机从3分钟提升至10秒，动画效果不再卡顿，应用开启速度也变快许多，然后没了(:з」∠)暂时只体验到这些 Optane部分问题修复拔插Optane导致无法引导进BIOS-&gt;第二页（Advanced）-&gt;第二个（Intel Rapid Storage Technology）-&gt;然后选择带有Intel Optane的选项-&gt;点击第一个（部分是Deconcatenate，反正点就是，不用管）-&gt;选择Are You Sure….那一行，切换至Yes-&gt;点击最后一行（部分是Start….，点就是，不用管），然后底下会出现一段Warning….，这时候BIOS会”卡”住，等待变化，跳出刚才的页面就可以退出BIOS了，然后还是不能引导，重启一下即可，之后耐心等待开机，开机后打开Optane管理软件，点击启用，重启2次，第三次就能恢复正常，10秒开机，秒响应。"},{"title":"Mysql双机热备实战","date":"2018-07-11T16:07:24.000Z","url":"/mysql-dual-hot-backup.html","tags":["Develop","Mysql","Web"],"categories":["折腾记录"],"content":" 由于跟 Tao.cat 的博主合租一台VPS，但由于Vultr还有余额并且以后会将博客迁出合租的服务器到时候迁移又很麻烦，所以便利用分区解析将国内的流量引到合租服务器，国外流量引到Vultr的服务器，但同步又是个大问题，冷备份会丢数据，所以经过一番思考决定采用热备份的方式同步数据。 [alert-success]由于缓存插件带来了一些大坑，技术欠佳，暂时无法填上，所以博客放弃双机集群[/alert-success] 准备工作 两台服务器，建议异地 尽量使用 相同版本 的Mysql 确保两台服务器能互相交流 确保Mysql端口（3306）是通的 尽量先在测试服务器配置成功后再进行业务服务器配置 主服务器Ａ配置第一步：停止所有业务，避免有新的数据库写入强烈建议停用所有业务 因为后面有一步会涉及到动态数据，我第一次配置就是因为数据变化导致启用失败。 停用方案比如 WHMCS 和 WordPress 的维护模式 第二步：导出数据库命令行或者phpmysql都可以 mysqldump -u 用户 -p 密码 数据库 &gt; backup.sql 以下是一个事例（假设用户是 root ，密码是 1234 ，需要备份的数据库是 wordpress ） mysqldump -uroot-p1234 wordpress &gt; backup.sql 第三步：修改主服务器 A 的 mysql 配置文件一般情况，配置 mysql 的位置文件在 /etc/my.cnf 在 [mysqld] 标签下增加以下内容 #一般配置文件已经有了，开启日志log-bin = mysql-bin #一般配置文件自带了binlog_format = mixed #随便写但 主从的数字不可相同server-id = 1 #备份的数据库名称binlog-do-db = wordpress #集群的服务器数量，看你一共想要多少台热备份auto-increment-increment = 2 #auto_increment_offset＝1设置步长,这里设置为1,这样Master的auto_increment字段产生的数值是:1, 3, 5, 7, …等奇数ID，不高于上面这个参数auto-increment-offset = 1 设置完后请重启 mysql 服务，以便设置生效 service mysql restart 第四步：在主服务器 A 连上 mysqlmysql -u 用户 -p 密码 mysql 的连接命令为 mysql -uroot -p1234 (这里假设用户是root,密码是1234)需要注意的是,u和用户,p和密码之间没有空格。 第五步：在主服务器 A 上创建用于备份的用户该命令需要在上步连接 mysql 后，运行于 mysql 的命令行模式 grant replication slave on . to ‘用户名‘@’从服务器B的IP’ identified by ‘用户密码’; 需要在把上面命令的用户名，密码和从服务器的IP换成你自己的。下面是一个例子： grant replication slave on . to ‘slave1‘@’192.168.1.1’ identified by ‘1234’; 该命令的意思就是：创建一个用于备份的用户，用户名是slave1，密码是1234，这个用户只允许从192.168.1.1这个IP的机子上登陆 第六步：取得主服务器 A 的 mysql 目前的状态show master status\\G 目的是使同步初始化，该从那行开始执行同步 请记下这个 File 和 Position 的内容！ 从服务器B配置一般情况，配置 mysql 的位置文件在 /etc/my.cnf 在 [mysqld] 标签下增加以下内容 #一般默认都有了，开启 loglog-bin = mysql-bin #一般默认都有了binlog_format = mixed #随便写但 主从的数字不可相同server-id = 2 #进行镜像处理的数据库replicate-do-db = wordpress #这行照抄relay_log = mysqld-relay-bin #用从属服务器上的日志功能log-slave-updates = ON 第三步：连接上从服务器B的mysql命令行模式mysql -u 用户 -p 密码 第四步：给从服务器B设置主服务器的相关信息在命令行模式下运行下列命令： CHANGE MASTER TO MASTER_HOST = ‘主服务器A的IP’, MASTER_USER = ‘备份的用户名’, MASTER_PASSWORD = ‘备份用户的密码’, MASTER_LOG_FILE=’填入上面获取File的内容’,MASTER_LOG_POS=同样填入Position内容; 下面是一个例子： CHANGE MASTER TO MASTER_HOST = ‘192.168.1.1’, MASTER_USER = ‘slave1’, MASTER_PASSWORD = ‘1234’, MASTER_LOG_FILE=’mysql-bin.000005’,MASTER_LOG_POS=327; 第五步：启动 slave在mysql的命令行模式下输入： start slave; 第六步：查看从服务器是否正常运行在 mysql 的命令行模式下，运行以下命令： show slave status\\G 请务必确保 Slave_IO_Running 和 Slave_SQL_Running 的值都是 yes ，就表示成功了，如果任何一个是 NO 那就说明没有成功。博主由于没有将WordPress进入维护模式，所以File和Position数值变化导致启动失败。 第七步：测试是否同步这步很简单，进入A服务器的phpmyadmin随便改一下数值然后进B服务器查看，若数值变为你更改的数值，即确保A和B处于备份状态。 第八步：双机互相同步就是将A服务器看作从服务器，B服务器看作是主服务器配置一遍就行。"},{"title":"为WordPress启用Service Worker","date":"2018-07-01T13:47:00.000Z","url":"/wordpress-enabled-service-worker.html","tags":["Develop","Wordpress","Web"],"categories":["折腾记录"],"content":" Service Worker是Google推出的一项技术。Service Worker是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。但是对于博客来说我们只需要用到Service Worker缓存功能，加速网站的二次访问。 从上面的加载情况看，除去Bing的每日一图，其他文件共15k，其中gif和png图都未配置Service Worker，实际请求会更小 注：Service Workers只有在HTTPS的前提下才能发挥作用 加入sw-toolbox核心至WordPress下载sw-toolbox.js并且放到根目录 创建缓存规则在根目录下创建serviceworker.js，并且写入下面内容（以下均为参考，具体配置请根据情况进行配置） 启用Service Workers打开主题文件所在目录，修改footer.php，在前加入以下代码 以上就是WordPress启用Service Worker的方法，由于WordPress是动态博客所以实现断网访问有些困难，博主我很菜，所以暂时无法实现断网访问（摊手"},{"title":"博客一年记录","date":"2018-07-01T09:39:15.000Z","url":"/one-year-record.html","tags":["博客记录"],"categories":["站长杂谈"],"content":"随着光阴荏苒，博客已经建立了1年了，在这一年中我从一个什么都不知的小白，逐渐提升到了略懂Web的小白（｡ò ∀ ó｡），也走完了高中最后的一学期，这一年来一切都有了新的变化，有很多收获，当然也有许多不足。博客从凌乱不堪逐渐的变为简洁明了，加载速度也从龟速提升至2s，抛弃了绚丽多彩的主题转向纯色的主题，现在博客挂在位于西雅图的Vultr节点，虽然速度不理想，但不再出现几天一崩的情况，我也结交了许多朋友\\^O^/，感谢各位友人与我一同探索互联网(๑&gt;؂&lt;๑）。 无论如何，感谢你能读到最后。让我们继续加油吧！"},{"title":"Bing每日一图API","date":"2018-06-27T13:50:36.000Z","url":"/bing-daily-picture-api.html","tags":["API","Lab","PHP"],"categories":["折腾记录"],"content":"什么是Bing每日一图相信大家在访问Bing搜索的时候都会看到非常漂亮的背景图，由于Bing的背景图每天都会变，于是称为Bing每日一图。 调用方法此API只支持https调用，国外地区访问使用CF节点。 所有参数均仅适用于以 GET 方式进行请求 可直接插入img标签中 请求地址： 调用参数：参数代码 参数含义 可用参数 rand 是否随机显示最近8天内的图片 true or Do not fill in day 显示指定的最近图片 -1，0，1，2，3，4，5，6，7(0为今天，-1为昨天) size 指定获取图片大小 详见下方可用分辨率 info 获取图片基础信息（json格式） true or Do not fill in 以上所有参数均非必要，默认参数为 rand=false，day=0，size=1920x1080，info=false 可用分辨率： 1920×1080 1366×768 1280×768 1024×768 800×600 800×480 768×1280 720×1280 640×480 480×800 400×240 320×240 240×320 注：中间的x为英文字母x 调用示例：默认调用： 不带任何参数调用 Info调用：（例） 调用链接： {title:”Concrete dinosaurs along Old Route 66 in Holbrook, Arizona (© Gary Warnimont/Alamy)”,url:”\\_EN-US9038296644\\_1920x1080.jpg&quot;,link:”:”20180627”，api author:”Otstar”,api author link:”;} 随机调用： 调用链接： Code&lt;?php//判断是否随机调用if ($_GET[‘rand’]===’true’) {$gettime = rand(-1,7);}else {//若不为随机调用则判断是否指定日期$gettimebase = $_GET[‘day’];if (empty($gettimebase)) {$gettime = 0;}else {$gettime = $gettimebase;}}//获取Bing Json信息$json_string = file_get_contents(‘;.$gettime.&#39;&amp;n=1&#39;);//转换为PHP数组$data = json_decode($json_string);//提取基础url$imgurlbase = “;.$data-&gt;{&quot;images&quot;}\\[0\\]-&gt;{&quot;urlbase&quot;};//判断是否指定图片大小$imgsizebase = $GET[‘size’];if (empty($imgsizebase)){ $imgsize = “1920x1080”;}else { $imgsize = $imgsizebase;}//建立完整url$imgurl = $imgurlbase.”“.$imgsize.”.jpg”;//获取其他信息$imgtime = $data-&gt;{“images”}[0]-&gt;{“startdate”};$imgtitle = $data-&gt;{“images”}[0]-&gt;{“copyright”};$imglink = $data-&gt;{“images”}[0]-&gt;{“copyrightlink”};//判断是否只获取图片信息if ($_GET[‘info’]===’true’) { echo “{title:”.$imgtitle.”,url:”.$imgurl.”,link:”.$imglink.”,time:”.$imgtime.”api author:Otstar,api author link:;}&quot;;}else {//若不是则跳转url header(“Location: $imgurl”);}"},{"title":"iframe延迟加载","date":"2018-06-16T12:24:49.000Z","url":"/iframe-lazy-loading.html","tags":["JavaScript","HTML/CSS"],"categories":["折腾记录"],"content":" 由于原本的个人主页太丑，于是换了新的，并且准备利用一款JS制作About页，为了能让主页拥有更快的访问速度，于是便分离Home页和About页，先前是等页面完成Load后加载iframe，但为了照顾流量党便采用点击后加载的方式。不懂JS于是踩了很多坑∑(￣□￣) 流程设计A标签点击 -&gt; 显示Loading.gif并将iframe标签插入指定div中 -&gt; iframe加载完成后跳转指定锚点，隐藏Loading.gif并触发更改A标签使A标签直接指向指定锚点，避免iframe重新加载 Code About //初始A标签触发的function function about() { //显示Loading动画 document.getElementById(\"about-load\").style.display = \"block\"; //将iframe插入id为about-div的div中，并加载iframe，完成后触发aboutload的function document.getElementById(\"about-div\").innerHTML = ''} //iframe加载完成后触发 function aboutload() { //隐藏Loading动画 document.getElementById(\"about-load\").style.display = \"none\"; //跳转about锚点 location.href = \"#about\"; //更换初始A标签，使其直接指向about锚点（突然发现A标签都可以直接跳转锚点，然而我还用js模拟href(=_=)） document.getElementById(\"about1\").innerHTML = 'About';} 至此，点击加载iframe已完成，不需要用到jQuery，省下了部分加载时间。为了弄这个我Google了好久( ＿ ＿)ノ，我果然还是菜鸡(￣▽￣～)"},{"title":"写在2018年高考前","date":"2018-06-05T15:10:15.000Z","url":"/written-before-the-2018-college-entrance-examination.html","categories":["站长杂谈"],"content":"即将高考了，要和苦逼的高中生活说再见了，博主是一只偏科严重的菜鸡(＠￣ー￣＠)，并且也在相对较好的数学和理综上也没有太多优势，目前已对本一不抱太大的希望了(´-ωก`)。 用心学习中怎么可能(ﾉ_ )ﾉ，即将高考，祝愿各位友人高考成功。(:з」∠)_ [alert-success]把一切都看做是生活的小事情，没什么大不了，沉静下来。[/alert-success] 下面有一些考试的建议没用的东西，可看可不看(〜￣▽￣)〜 1、反复检查试卷是否有漏做 2、正确填涂答案 3、你的闹钟要调好 4、也许你会紧张但一定要冷静 5、考试之前在座位上闭目养神 6、不要一直喝水 7、过了上午考完后睡个午觉 8、不要左顾右盼 9、如果有题目不会先跳过等最后做 10、玩笔能缓解考试中的压力 11、吃饭的时候少喝点水 12、鸡极听老师的安排 13、以上13条的第一个字连起来读，这就是给你的忠告 "},{"title":"Toastr.js For WordPress","date":"2018-04-28T05:57:13.000Z","url":"/toastr-js.html","tags":["Develop","Wordpress"],"categories":["折腾记录"],"content":" Toastr.js是一个Toast通知的JS，当初是站长我在Github上找到，为了能让通知简明快速地到达访客眼中，并且设置方便，于是经过几天折腾终于完成了Toastr.js For WordPress。(๑&gt;؂&lt;๑） 特性 WordPress后台设置页面。 能指定某些页面开启。 通知动画可更改。 还有。。还有。。好像没了～(￣▽￣～)~ 截图 Demo 项目地址Github 欢迎 star (^_^) 鸣谢Toastr.js ===2018-06-09更新=== 最近发现本插件在运行时报错，最近将会修复 "},{"title":"The Fox主题汉化分享","date":"2018-04-12T14:58:29.000Z","url":"/the-fox-theme-chinese-share.html","categories":["分享推荐"],"content":" 同Flow Theme，此主题是我之前从云核淘到的，由于设置是英文，不方便修改定制，所以机翻了后台设置部分，主题包含插件比较大所以就不发了，只发汉化的文件。 演示地址: 下载地址: 若链接失效请到云核搜索下载 汉化文件下载地址: 注:此文件请放到The Fox的admin文件夹内，机翻，翻译可能出错，莫怪。"},{"title":"Flow Theme分享","date":"2018-03-21T16:34:59.000Z","url":"/flow-theme-e5-88-86-e4-ba-ab.html","categories":["分享推荐"],"content":"由于我博客主题单调想更换主题，经寻找发现Flow主题功能强大并且较小，使用后发现是英文，于是翻译了后台设置方便设置（机翻，未修改） 演示地址: 下载地址:由于学校坑比的网速暂时没上传，需要的可以发邮件至otstar@syfxlin.win索要，这周六晚上上传。 [alert-note]由于主题加载调用问题导致加载会会很久，应该是ajax加载问题，主题文件非常零散，有能力的可以尝试修改。[/alert-note]"},{"title":"[青空之蓝-2017]-崭新","date":"2017-12-31T08:23:32.000Z","url":"/e9-9d-92-e7-a9-ba-e4-b9-8b-e8-93-9d-2017-e5-b4-ad-e6-96-b0.html","tags":["年度总结"],"categories":["站长杂谈"],"content":"[hermit autoplay=”false” mode=”circulation” preload=”auto”]netease_songlist#:721137[/hermit] 转眼就到了年末的最后一天，距建站之初已经有6个月了，回顾一下2017吧。。。 往事2017年的某天我的酷派大神F2被盗，无奈的我从手中购入大神Note3，由于WIFI实在辣鸡（蹭学校的WIFI，我是住宿生，买不起移动的坑比流量～(￣▽￣～)~）于是准备购入中继器，但由于中继器无法接入802.1x认证，所以经某人推荐购入香橙派，但作为好奇青年这派只能用来做私有云中继器实在暴殄天物，受[树莓香橙香蕉派]群友的影响，我知道了WordPress以及类似的博客系统 我还记得当初的我是多么激动的装上LAMP的，点开WordPress地址，寻找主题插件，但是那时只是局限于局域网，机缘巧合下我知道了虚拟主机，于是乎博客经一番折腾后被搬到了免费的虚拟主机上，那天正好是7月1日 时间过去11日免费虚拟主机供应商改版，我的虚拟主机被迫转移，经推荐我购入HostDare这个坑比的VPS，转移后博客稳定运行了1个多月，随后便是数据库崩溃，重装系统碰巧遇到钻石盘，联系客服后免费更换成更贵的KVM，当初我还吹了几天（因为价格。。。），之后才知道这是个坑，就在12月初博客又一次崩溃，无奈的我只能将博客转移至Virmach（12月购买用来翻墙） 站点站点经历的一些大事件上方已经说了，小事就在这里写吧(●—●) 7月建站 3次转移博客 博客被谷歌，必应，雅虎，神马收录，垃圾百度丝毫不理我（谷歌真的良心，提交sitemap后的3个小时就收录了） 使用麦客表单进行友链统计（主要防止站点崩溃带来的友链损失）方便整理 开启HTTPS，不使用HSTS的原因就不说了，换了宝塔的SSL证书（LE的证书配置太慢(ﾉ_ _)ﾉ） 昨天接入Cloudflare CDN，速度飞起 没有了。。。(●°u°●) 友人友链9个，突然发现一个友链不见了，等下赶紧补上(ŐдŐ๑)已补上 为何这么少呢?因为我懒。。。 首先感谢开发群的群友们，没有你们就没有这个博客(๑&gt;؂&lt;๑） 另外感谢9位博主，谢谢你们能与我共度在互联网的时光。。。 未来 我是一位高三学生，明年的6月就要参加高考了（neoFelhz与Nita同届，目前我就知道这两位是同届的）所以到高考完前就没有太多的时间打理博客，可能会吃灰半年～(￣▽￣～)~，虽说是福建考生但是一本基本无望，成绩实在苦逼 说下高考完的计划吧。。。 学习java，php，C++ 优化博客 没了。。。实在想不到其他(^_^) 尾声写了一个小时。。。 沉迷学习(:з」∠)无法自拔的我在18年可能会很少更新文章，这篇文章是对过去的总结和未来的期待，开站到现在也只有这一次这么用心写文章过。。。 无论如何，感谢你能读到最后。新的一年，让我们继续加油吧！ 另外祝愿与我同届的友人高考成功。。。 "},{"title":"调教火龙810-降低发热（已更）","date":"2017-12-23T15:08:27.000Z","url":"/e8-b0-83-e6-95-99-e7-81-ab-e9-be-99810-e9-99-8d-e4-bd-8e-e5-8f-91-e7-83-ad.html","tags":["Nubia Z9Max","骁龙810"],"categories":["折腾记录"],"content":" 上个星期由于我的小米4给了我老妈，经过“慎重”思考入手Nubia Z9Max，其实原本想入Z9的可惜Money不足，于是入手Z9Max（没有快充，不是无边框，但是支持SD卡槽，只有这个可以点赞） 进入正题基本参数Qualcomm MSM8994 Snapdragon 810 4x Quad-core 2.0 GHz ARM®Cortex™ A57 （big）@ 1.96GHz and 4x quad-core 1.5 GHz ARM®Cortex™ A53（LITTLE）@ 1.56GHz；Adreno 430 GPU；X10 LTE modem；20nm LMP 探索发热源头经过一星期的测试及日常使用，发现发热并没有想象中的严重，可能是天气太冷了吧，至少比我2年前的酷派8190Q(MTK6589)好很多 开启4小核锁住4大核，日常使用55℃ 开启4小核只开1大核，日常使用63℃ 开启4小核只开2大核，日常使用68℃ 超过2个大核长期在线的话温度直接上升20℃达到可怕的85℃ 高通吧吧主做过烤机测试，结果如下 单个 2GHz A57 核心，满载坚持 1 分多钟后达到 105℃ 左右，没有降频，但直接就重启了。两个 2GHz A57 核心，最多不到 5 秒钟就冲到 105℃ ，然后重启。A53 核心就好多了，1.56GHz 频率下单个满载不超过 50℃，双核大约 50℃ ，四核也才 61℃ ，都过得去。 所以发热的根源在于4个A57大核，但是如果4个A57都不在线，开启应用时及快速滑动列表时会出现严重掉帧现象，所以不能完全锁住4个A57 动手! 我个人不喜欢任何国产OS，所以扳掉Nubia UI刷入RR-OS及Mokee，以下的所有操作都是在RR和Mokee下操作的。 RR经过我使用发现一个问题就是关屏待机时A57会全部掉线，无法重新打开，必须重启，目前用以下方法应该可以解决（目前正在测试）经测试锁核问题是msm_thermal引起的，以下命令可成功解锁。 #执行以下命令chmod 666 /sys/devices/soc.0/qcom,bcl.61/modeecho -n disable &gt; /sys/devices/soc.0/qcom,bcl.61/modechmod 444 /sys/devices/soc.0/qcom,bcl.61/modechmod 666 /sys/module/msm_thermal/core_control/enabledecho 0 &gt; /sys/module/msm_thermal/core_control/enabledchmod 444 /sys/module/msm_thermal/core_control/enabled 另外使用高通锁核方案这个APP锁核后重新开核貌似也可以做到。 调教方案偶然在酷安看到有酷友分享的调度，经2星期测试，基本不存在卡顿，发热虽然还是严重但已经不再过热降频（注:此次更新写于4月中旬，坐标泉州 亚热带） 方案地址: "},{"title":"博客崩溃记录","date":"2017-12-16T13:22:20.000Z","url":"/e5-8d-9a-e5-ae-a2-e5-b4-a9-e6-ba-83-e8-ae-b0-e5-bd-95.html","categories":["站长杂谈"],"content":"就在今天我的博客莫名其妙地崩溃了，hostdare的vps实在坑，之前由于ovz超卖，导致钻石盘重装了好几次系统都没用，之后联系了支持人员，支持人员更换成kvm,时间过了几个月，今天又出现了莫名其妙的变成其他系统并且无法重装，目前我已经提交撤销申请，现在博客挂在virmachVultr，目前我的vps只是临时使用的，明年的3月1日到期，届时我会将vps升级，另外virmach的vps还不错。垃圾virmach，目前Vultr按时计费特舒服～(￣▽￣～)~"},{"title":"小米手机底部按键出错解决方法","date":"2017-10-26T04:45:18.000Z","url":"/e5-b0-8f-e7-b1-b3-e6-89-8b-e6-9c-ba-e5-ba-95-e9-83-a8-e6-8c-89-e9-94-ae-e5-87-ba-e9-94-99-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95.html","categories":["折腾记录"],"content":" 大家都知道小米的原装屏幕很贵，其实是因为触控芯片贵，所以有些商家就弄出了“非原装芯片”，也使小米手机用户不再心疼屏幕碎了，但是这也带来了一些问题，由于非原装芯片只对MIUI系统设计，所以刷第三方rom就会遇到按键出错的问题。 由于我前一部手机z90疯狂闪退，入手二手小米4，刷入第三方rom后发现按键出错，经过不懈搜索我终于找到可以改键的xposed模块（其实我早就在使用(:з」∠)） 教程开始下载xposed框架安装，激活xposed edge pro模块，重启 进入xposed edge软件，勾选按键 点击按键，进入按键设置菜单，我的是小米4，底部最近任务键被映射到菜单键，主页键被映射到跳转顶部键，一波调教后按键恢复正常 这种方法支持所有手机，前提是要能激活xposed并正常使用，另外Android8.0还没有框架，所以要想改键的话还是放弃8.0吧 [button-blue url=”; target=”_blank” position=”central”]xposed edge下载[/button-blue]密码:0000"},{"title":"Hermit X播放器","date":"2017-10-04T15:21:44.000Z","url":"/hermit-x-e6-92-ad-e6-94-be-e5-99-a8.html","categories":["分享推荐"],"content":" Hermit X，使用 APlayer 前端播放器，Meting Framework &amp; LWL API 后端支持的全新 WordPress 播放器，支持网易云音乐https。 特性：支持直接调用网易云音乐、虾米音乐、QQ音乐、酷狗音乐、百度音乐的单曲/专辑/歌单 以及本地音乐（且即将支持 ） WordPress深度整合，最低三键即可调用 与 APlayer 保持同步更新，兼容 APlayer 所有功能 音乐 API 更新迅速，始终保持高可用性 支持自动歌词获取（网易云音乐&amp;虾米音乐支持歌词翻译！） 网易云音乐、虾米音乐支持 HTTPS 调用 项目地址： 转载于:"},{"title":"小米4 RR-OS评测","date":"2017-10-01T17:16:29.000Z","url":"/e5-b0-8f-e7-b1-b34-rr-os-e8-af-84-e6-b5-8b.html","tags":["RR-OS","小米4"],"categories":["折腾记录"],"content":" 由于我之前用的垃圾z90不常用软件不闪退，常用的软件用没一分钟就闪退，实在是特别不爽，坑比的大神note3又因为wifi信号问题不能胜任常用机，好在同学收购了我的大神note3，使得我有钱可以购入二手的小米4(๑&gt;؂&lt;๑），另外我特别不喜欢使用MIUI系统，所以刷入RR-OS（原本我是打算刷win10 mobile，但考虑到软件硬伤所以还是原因安卓，等有了新的主力机后会刷入win10） 刷机手机经过漫长的等待，其实就两天(｢･ω･)｢，终于到了我的手上，经过一番验机，确认是正品，从MIUI论坛搞到rec，经过不久的刷开发板，刷rec，刷RR-OS后手机终于是进入了全新的世界 问题解决刷入RR-OS后有发现一个问题任务键和主页键被映射到其他按键上，由于是二手机，我并不知道手机是否换过屏幕所以无法知道是否是硬件问题，但是7.1已经有了xposed，既然有了xposed那还怕什么，改改改。。。 使用xposed edge插件成功改键 使用体验系统没有什么大毛病，就是发热严重，另外cpu调度有点坑，没开游戏系统动态开核，一开游戏立马锁两核→_→，不知是ppsspp的问题还是系统问题（我只测试过ppsspp，之后会测试一些耗性能的游戏） 待机无敌，经过两天的测试待机基本不会掉电，使用时掉电也不快，连续重度使用两小时掉35%电量 充电方面没有测试，因为我没有6pin数据线，没法测试9v快充性能，但是5v 2a充电速度还不错，20分钟冲20%电 总结如果是想要稳定使用的话还是MIUI9会比较好用，但是如果你是一个像我一样没有xposed，没有原生系统，不能个性定义系统就不能好好使用手机的人，那么RR-OS非常适合你，RR有非常多的自定义选项可以自己打造系统界面，优化使用体验。"},{"title":"私有云搭建小记","date":"2017-09-09T16:45:09.000Z","url":"/e7-a7-81-e6-9c-89-e4-ba-91-e6-90-ad-e5-bb-ba-e5-b0-8f-e8-ae-b0.html","tags":["Aria2","frp","NAS","Nextcloud","Orange Pi"],"categories":["折腾记录"],"content":" 之前我写了家用NAS的搭建教程，但这只是最基本的NAS，只是拥有远程下载的ftp服务器而已，这篇文章会教大家搭建完全的私有云，解决方案为Nextcloud+Aria2+frp穿透+远程ssh 如果还没配置好环境的请先照着OrangePi搭建NAS系列完成环境搭建。Nextcloud搭建更新 apt updateapt upgrade 安装LAMP环境 sudo apt-get install apache2 apache2-utilssudo apt-get install libapache2-mod-php5 php5 php-pear php5-xcache php5-mysql php5-curl php5-gdsudo apt-get install mysql-serversudo apt-get install phpmyadmin 安装Nextcloud cd /var/www/htmlwget  nextcloud-12.0.2.zip 浏览器访问 然后填入相关参数使用mysql数据库，等待片刻浏览器会自动跳转，跳转成功后就完成nextcloud的安装。 aria2请参照OrangePi搭建NAS进行安装 frp内网穿透 由于现在的ISP基本都是网中网，只是用DDNS根本无法正常从外网访问，所以就需要内网穿透，因为ngrok搭建相对麻烦所以我选择frp。 首先你需要一个外网的服务器 SSH连接上外网主机后，使用wget指令下载frp。 wget \\_0.13.0\\_linux_amd64.tar.gz 使用tar指令解压tar.gz文件 tar -zxvf frp_0.13.0_linux_amd64.tar.gz 使用cd指令进入解压出来的文件夹 cd frp_0.13.0_linux_amd64.tar.gz 外网主机作为服务端，可以删掉不必要的客户端文件，使用rm指令删除文件。 rm -f frpcrm -f frpc.ini 接下来要修改服务器配置文件，即frps.ini文件。使用nano指令对目标文件进行编辑。 vi frps.ini 打开frps.ini后可以看到默认已经有很多详细的配置和示范样例，该文章仅以达到内网穿透为目的，所以这里选择删掉或注释掉里面的所有内容，然后根据使用的情况，按照官方的中文文档添加以下配置。 [common]bind_port = 7000vhost_http_port = 8080 [common]部分是必须有的配置，其中bind_port是自己设定的frp服务端端口，vhost_http_port是自己设定的http访问端口。 保存上面的配置后，使用以下指令启动frp服务端。（如果需要在后台运行，请往下翻阅关于后台运行的部分。） ./frps -c ./frps.ini 服务端的工作就到此结束了。 客户端 客户端前面的操作和服务端是一模一样的，这里不一一解释。 wget \\_0.13.0\\_linux_386.tar.gztar -zxvf frp_0.13.0_linux_386.tar.gzcd frp_0.13.0_linux_386rm -f frpsrm -f frps.ininano frpc.ini 客户端的配置如下 [common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[web]type = httplocal_port = 80custom_domains = web.syfxlin.win[aria2]type = httplocal_port = 6800custom_domains = aria2.syfxlin.win 上面的配置和服务端是对应的。 [common]中的server_addr填frp服务端的ip（也就是外网主机的IP），server_port填frp服务端的bind_prot。 保存配置，输入以下指令运行frp客户端。（同样如果需要在后台运行，请往下翻阅关于后台运行的部分。） ./frpc -c ./frpc.ini 此时在服务端会看到”start proxy sucess”字样，即连接成功。 现在可以用SSH通过外网主机IP:6000建立SSH连接。通过浏览器访问8080端口访问web网站 让frp在后台运行 虽然现在frp运作起来了，内网穿透也实现了，但这还是不够的。此时如果断开与服务端或者客户端的SSH连接（比如关掉了Xshell）也就中止了frp的运行。 保持frp运行是关键是让服务端的frp和客户端的frp在后台运行，使用screen让frp在后台运行 首先使用screen指令创建一个会话。 screen -dmS frp 然后进入这个会话。 screen -r frp 最后使用运行frp的指令(如果之前断开了SSH连接，记得用cd指令进入frp的目录先。) ./frps -c ./frps.ini 这样就让frp在后台运行了。 [alert-warning]其实已经更完了，假装未完成(๑&gt;؂&lt;๑）[/alert-warning]"},{"title":"文末版权声明插件","date":"2017-09-08T16:18:46.000Z","url":"/e6-96-87-e6-9c-ab-e7-89-88-e6-9d-83-e5-a3-b0-e6-98-8e-e6-8f-92-e4-bb-b6.html","tags":["Wordpress"],"categories":["分享推荐","新奇趣闻"],"content":"嗯，很“泛滥”的一个小功能，原本想直接弄代码，但是考虑到wordpress主题升级会将写入的代码覆盖，所以直接弄成插件，既方便又安全。 [su_button url=”; style=”ghost” color=”#2D89EF” size=”9” radius=”5” text_shadow=”0px 0px 0px #000000”]下载[/su_button]"},{"title":"更新说明","date":"2017-09-07T05:15:24.000Z","url":"/e6-9b-b4-e6-96-b0-e8-af-b4-e6-98-8e.html","categories":["站长杂谈"],"content":"本站站将于近期进入慢更时期，预计一年后重新进入正常状态。 博主现已无心打理(放屁╮(￣▽￣)╭)因为进入了高三，我不是特长生，而且也不是所谓的学霸，为了明年6月的高考，我不得不学习，我有空的话会更新一到两篇博文，再见各位朋友。。 站点一星期一到两更，繁重的学习没办法，而且这次月考史上最差才374(｡•́︿•̀｡) ===2018-06-08更新=== 以上都是废话了，解放了，苦逼的高中生活再不见。～(￣▽￣～)~"},{"title":"dietpi系统使用小记","date":"2017-09-02T06:33:38.000Z","url":"/dietpi-e7-b3-bb-e7-bb-9f-e4-bd-bf-e7-94-a8-e5-b0-8f-e8-ae-b0.html","tags":["dietpi"],"categories":["折腾记录"],"content":" dietpi系统作为树莓派，香橙派等开发板的系统，有着许多优点，但也有缺点，今天就我来为大家评测下，由于装载dietpi的orange pi pc2没有电源线（因为我的电源线用在lite上了）所以没截图，之后我会补图的，见谅。 dietpi系统十分轻量化，基于广受好评的armbian构建工具构建的系统，进行优化，dietpi有其特殊的应用商店和一系列工具使安装配置环境或软件非常简单，十分懒的人可以选择入手dietpi系统。 优点系统开启速度比armbian快许多，DietPi针对最小的CPU和RAM资源使用进行高度优化，确保开发板能始终运行在最好的情况。DietPi程序使用轻量级Whiptail菜单。你会花更少的时间盯着命令行，更多的时间享受DietPi。 dietpi-software这里我用dietpi的一大原因，能快速，轻松地安装“准备运行”并针对您的系统进行优化的流行软件。像OMV NAS环境，Wemim环境，LAMP，LEMP，Nextcloud，Wordpress等都可以快速搭建。 dietpi-backup快速备份系统，防止配置错误后的折腾，省去用电脑读取img镜像的时间。 缺点其中最强大也是最危险的缺点莫过于开机有几率丢失Dietpi文件夹，这个文件夹丢失可以说是对dietpi的一个重大打击，丢失后所有从dietpi-software安装的软件都无法运行，因为这些软件启动是通过dietpi文件夹里的一个脚本启动的，我两度遇上这个问题，一旦开机电流不够遇上这个问题的几率就非常大，修复方法我没试过，遇上这个问题的可以试试。方法如下 注:没有备份系统的以下方法无用。 由于Dietpi文件夹丢失dietpi-backup就启动不了所以抓取dietpi-backup脚本 wget  -O /root/dietpi-backupchmod +x /root/dietpi-backup 运行脚本，进行恢复 /root/dietpi-backup 以上方法不一定能成功 ===2018-05-31更新=== Dietpi系统已不在提供OrangePi的完整镜像，需要从Armbian构建，通过Dietpi官方脚本构建，目前尚未测试，预计在7月会测试。 ===2018-06-08更新=== 我的Orange Pi PC2已摔，所以测试是不存在的了。"},{"title":"Orange Pi搭建NAS(7)-Aria2远程下载","date":"2017-07-23T04:57:36.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas7-aria2-e8-bf-9c-e7-a8-8b-e4-b8-8b-e8-bd-bd.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":"Aria2是一个轻量级命令行下载工具，支持HTTP / HTTPS，FTP，SFTP，BitTorrent和Metalink下载，但是不支持ed2k，支持JSON-RPC和XML-RPC调用，可以远程控制。 一、安装Aria2安装命令 apt-get install aria2 创建 aria2 配置文件 “/home/用户名/.aria2/aria2.conf” 和 “/home/用户名/.aria2/aria2.session”这个文件。 mkdir /home/用户名/.aria2 touch /home/用户名/.aria2/aria2.session nano /home/用户名/.aria2/aria2.conf 配置文件内容如下 # 基本配置 # 下载目录 dir=/home/用户名/nas-data/aria2 # 下载从这个文件中找到的urls, 需自己建立这个文件 # touch /home/用户名/.aria2/aria2.session input-file=/home/用户名/.aria2/aria2.session # 最大同时下载任务数，默认 5 #max-concurrent-downloads=5 # 断点续传，只适用于 HTTP(S)/FTP continue=true # HTTP/FTP 配置 # 关闭连接如果下载速度等于或低于这个值，默认 0 #lowest-speed-limit=0 # 对于每个下载在同一个服务器上的连接数，默认 1 max-connection-per-server=5 # 每个文件最小分片大小，例如文件 20M，设置 size 为 10M, 则用2个连接下载，默认 20M #min-split-size=10M # 下载一个文件的连接数，默认 5 #split=5 # BT 特殊配置 # 启用本地节点查找，默认 false bt-enable-lpd=true # 指定最大文件数对于每个 bt 下载，默认 100 #bt-max-open-files=100 # 单种子最大连接数，默认 55 #bt-max-peers=55 # 设置最低的加密级别，可选全连接加密 arc4，默认是头加密 plain #bt-min-crypto-level=plain # 总是使用 obfuscation handshake，防迅雷必备，默认 false bt-require-crypto=true # 如果下载的是种子文件则自动解析并下载，默认 true #follow-torrent=true # 为 BT 下载设置 TCP 端口号，确保开放这些端口，默认 6881-6999 listen-port=65298 #Set UDP listening port used by DHT(IPv4, IPv6) and UDP tracker dht-listen-port=65298 # 整体上传速度限制，0 表示不限制，默认 0 #max-overall-upload-limit=0 # 每个下载上传速度限制，默认 0 #max-upload-limit=0 # 种子分享率大于1, 则停止做种，默认 1.0 #seed-ratio=1 # 做种时间大于2小时，则停止做种 seed-time=120 # RPC 配置 # 开启 JSON-RPC/XML-RPC 服务，默认 false enable-rpc=true # 允许所有来源，web 界面跨域权限需要，默认 false rpc-allow-origin-all=true # 允许外部访问，默认 false rpc-listen-all=true # rpc 端口，默认 6800 rpc-listen-port=6800 # 设置最大的 JSON-RPC/XML-RPC 请求大小，默认 2M #rpc-max-request-size=2M # rpc 密码，可不设置 #rpc-passwd=raspberry # rpc 用户名，可不设置 #rpc-user=aria2pi # 高级配置 # This is useful if you have to use broken DNS and # want to avoid terribly slow AAAA record lookup. # 默认 false disable-ipv6=true # 指定文件分配方法，预分配能有效降低文件碎片，提高磁盘性能，缺点是预分配时间稍长 # 如果使用新的文件系统，例如 ext4 (with extents support), btrfs, xfs or NTFS(MinGW build only), falloc 是最好的选择 # 如果设置为 none，那么不预先分配文件空间，默认 prealloc file-allocation=falloc # 整体下载速度限制，默认 0 #max-overall-download-limit=0 # 每个下载下载速度限制，默认 0 #max-download-limit=0 # 保存错误或者未完成的下载到这个文件 # 和基本配置中的 input-file 一起使用，那么重启后仍可继续下载 save-session=/home/pi/.aria2/aria2.session # 每5分钟自动保存错误或未完成的下载，如果为 0, 只有 aria2 正常退出才回保存，默认 0 save-session-interval=300 # 若要用于 PT 下载，需另外的配置，这里没写 RPC调用加入验证（外网调用最好加上验证），可以使用token验证 # token验证 rpc-secret=secret 运行 aria2, 测试配置是否有错误，如果没有提示任何错误信息，那就按Ctrl+C停止。 aria2c –enable-rpc –rpc-listen-all=true –rpc-allow-origin-all -c 如果执行上述命令正常后加-D参数让其正常工作。 aria2c –enable-rpc –rpc-listen-all=true –rpc-allow-origin-all -c -D 二、安装Aria2网页端安装配置LAMP为了方便使用网页端，以及后续的nextcloud需要安装Apache+MySQL+PHP 安装Apache sudo apt-get install apache2 安装mysql sudo apt-get install mysql-serversudo apt-get install php5 sudo apt-get install php5-mysql 注:Ubuntu内核的只有php7.0 AriaNg的安装下载源码包，直接丢进lamp的目录即/var/www/html中即可 "},{"title":"Orange Pi搭建NAS(6)-文件共享","date":"2017-07-17T04:23:41.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas6-e6-96-87-e4-bb-b6-e5-85-b1-e4-ba-ab.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":"为了方便访问树莓派的存储设备，有必要为其添加文件共享，下面为给出三种文件访问方法：samba，ftp。我不太推荐samba虽然它在电脑上不需要客户端但对于小白来说配置samba就是个噩梦，下文我也会给出samba的安装方法。 FTP安装vsftp，开源的轻量级的常用ftp服务器 sudo apt-get install vsftpd 先备份，然后编辑配置文件 sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.origsudo nano /etc/vsftpd.conf vsftp的配置文件，它允许你设置所有类型的限制和策略，目前没有深入研究，修改如下 # 不允许匿名访问anonymous_enable=NO# 设定可以进行写操作write_enable=YES# 设定本地用户可以访问local_enable=YES 为了root账户也能访问FTP需要修改/etc/ftpusers sudo nano /etc/ftpusers 把root那行注释掉 …… #root …… 重启vsftpd sudo service vsftpd restart 通过ftp连接树莓派系统，以用户名登录，密码是用户的密码。ftp的根目录是/home/用户名，即用户的HOME目录，可上传或下载文件了。 Samba安装samba所需软件 sudo apt-get install samba samba-common-bin 先备份，然后编辑/etc/samba/smb.conf文件 sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak sudo nano /etc/samba/smb.conf 创建shares文件夹 mkdir /home/用户名/nas-data/DLNA/shares 需要修改添加的内容如下， [global]security = userencrypt passwords = trueguest account = nobodymap to guest = bad user #======================= Share Definitions ======================= [share]comment = Guest access sharespath = /home/用户名/nas-data/sharesbrowseable = yeswritable = yes #read only = yesguest ok = yespublic = yes [NAS-Data]comment = Nas data folderpath = /home/用户名/nas-data/browseable = yeswritable = yesvalid users = root 你的用户名 share共享目录访问不需要密码，而NAS-Data访问需要验证，用户为root和你的用户名。 最后重启samba服务。然后同一局域网的其他设备就可以访问RPi的共享目录 sudo service samba restart Android可以使用ES File Explorer，IOS可以使用FileExplorer, FileBrowser, Documents和Remote File Free，或其他支持访问共享的文件管理器。"},{"title":"Orange Pi搭建NAS(5)-UPNP/DLNA多媒体","date":"2017-07-16T05:11:17.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas5-upnpdlna-e5-a4-9a-e5-aa-92-e4-bd-93.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":"安装miniDLNAsudo apt-get install miniDLNA 上面安装的miniDLNA默认是不支持rmvb格式的视频，所以我们最好自己下载源代码，只需要做很少改动就可以支持rmvb，然后编译安装。 编译安装比较麻烦，我也没成功，想支持rmvb，参考  先备份然后编辑配置文件 sudo cp /etc/minidlna.conf /etc/minidlna.conf.origsudo vim /etc/minidlna.conf 修改如下设置 media_dir=/home/用户名/nas-data/DLNAdb_dir=/home/用户名/nas-data/DLNA/dblog_dir=/home/用户名/nas-data/DLNA/logfriendly_name=OPi DLNA 创建文件夹 mkdir /home/用户名/nas-data/DLNAmkdir /home/用户名/nas-data/DLNA/{Music,Pictures,Videos,db,log} 最后重启miniDLNA服务 sudo service minidlna restart 打开计算机网络，可以看到OPi DLNA媒体设备 解决mp3中文乱码用Windows Media Player(后面用WMP替代)查看minidlna多媒体服务器文件，有些中文文件名显示乱码，有些就正常。目前Linux中流行的很多播放器经常不能正确显示如歌曲名、专辑名等MP3 tag信息，经过有些工具转换后，标签又不能被Windows识别。MP3的歌曲名、艺术家、专辑名等信息都以一定的编码格式存储在MP3标签中。简单地说，乱码出现的原因就是播放器未能准确识别出MP3标签的中文编码格式。 具体的说，现在MP3文件的标签主要有几种标准：ID3v1、ID3v2（现在常见的又分为2.3和2.4）、APEv2。可以从两个角度解决这个问题。一是转换已有MP3文件的标签编码，二是使用支持GBK编码的播放软件,这种方案我没试过。 mp3tagiconv是一款可用于解决MP3乱码问题的软件。它可以自动探测MP3标签的编码，并以合理的方式重新写入，经过其处理的编码可被Linux、Windows（包括Windows Media Player）和各种移动设备正确识别。 mp3tagiconv 需要 mutagen 的支持，确保之前已经安装。 sudo apt-get install python-mutagengit clone  以上就是miniDLNA的安装"},{"title":"Orange Pi搭建NAS(4)-存储设备","date":"2017-07-16T04:49:58.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas3-e5-ad-98-e5-82-a8-e8-ae-be-e5-a4-87.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":"准备一块硬盘，以及一个移动硬盘盒（支持2.5/3.5寸的硬盘，以及外接供电）把硬盘分区，并格式化为ext4 格式，这样性能更好，寿命应该更长(待考证)。 由于OPi的USB口供电能力有限，所以移动硬盘需要外部供电，所以根据上面的分析对于想外接移动硬盘的人来说，有以下两种解决方案： 用带电源的USB集线器，USB集线器接上电源，然后连接上RPi的USB口，移动电源接到USB集线器上。如此一来就可以连接多个移动硬盘，比如接两个移动硬盘，其中一个用来做数据备份。 使用易驱线，这个只能用一个硬盘，但是不再需要移动硬盘盒。 注：不建议直接用OPi为硬盘供电 由于我暂时没有硬盘。所以我用U盘进行测试，如果是移动硬盘建议格式化为ext4，U盘因为存储空间小建议格式化为FAT32这样各种设备都可读取，但由于只支持4G以下的文件，所以如果U盘只是用来作为NAS存储盘建议也格式化为ext4，由于我U盘有其他用途，我就不格式化为ext4。但建议大家可以弄个专用的移动硬盘，然后格式化为ext4格式，这样好折腾。 教程开始关机，断电，插上USB移动硬盘和U盘，上电启动。然后登录SSH，查看磁盘信息， sudo fdisk –l，如果没有问题的话，会显示以下字符 … … Disk /dev/sda: 62.9 GB, 62914560000 bytes … … Device Boot Start End Blocks Id System /dev/sda1 2048 122879999 61438976 83 Linux 可以看到，/dev/sda为64G U盘，只有一个分区/dev/sda1 成功识别到硬盘后，可以查询文件系统类型、LABEL、UUID等信息 sudo blkid Armbian应该不支持exFAT，需要安装exfat-fuse sudo apt-get install exfat-fuse -y 再就是设置自动挂载，需要编辑/etc/fstab，先备份 sudo cp /etc/fstab /etc/fstab.origsudo vim /etc/fstab 在文件最后加上下面几行内容 /dev/sda1 /home/你第一次开机设置的非root账户名/nas-data 如果出现中文乱码，需要加参数utf8=1，保存，最后重启。关于/etc/fstab，可以参考 创建挂载目录 mkdir /home/用户名/nas-data 重启 sudo reboot 重新登录SSH，查看挂载信息 sudo mount -l 会显示 ……/dev/sda1 on /home/用户名/nas-data type ext4 (……) 表示全部挂载成功 本文参考: "},{"title":"Orange Pi搭建NAS(3)-系统安装","date":"2017-07-13T16:12:40.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas3-e7-b3-bb-e7-bb-9f-e5-ae-89-e8-a3-85.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":"安装操作系统Orange Pi支持的系统很多，可以从官方下载也可以下载其他的系统 OrangePi one系统 推荐armbian 链接 本教程以armbian系统为例 下载Armbian操作系统，下载完成后解压缩得到镜像文件(.img)，然后我们需要一个工具把镜像文件烧录到SD卡上， 我知道有两款工具，Win32DiskImager，USB Image Tool，另外这两款工具还可以备份整个SD卡为一个镜像文件。下面以Win32DiskImager为例说明如何烧录 把micro SD card插入读卡器中，连接上电脑. 等电脑识别后会分配一个盘符(例如G:) 下载 Win32DiskImager安装 下载SD Formatter 安装 安装完成后以系统管理员权限运行 选择之前解压缩得到的镜像文件，选择SD卡所在盘符 点击Write按钮开始写入镜像文件，然后就是等待，完成后会弹出提示框 注:Armbian的boot文件夹在windows不可见 登录SSH把micro SD card 插入Orange Pi，插上网线，连到路由器，然后上电。由于我们没有键盘和显示器，所以需要用SSH登录，默认登陆用户名/密码：root / 1234。 但是不知道IP地址怎么办？其实我们可以从路由器设置里面得到IP地址。下面以TP-LINK为例，其他路由器类似。 进入路由器设置—&gt;DHCP服务器—&gt;客户端列表，就可以得到OPi的IP地址。 接下来用SSH客户端(Puty, SecureCRT, XShell等) 登录 系统配置Armbian开机会提示你输入账户和密码输入后会提示更改密码，更改密码先输入原始1234密码，后输入自己设置的密码(输入两遍)，之后提示创建一个非root账户，按提示来就行。 接下来就是更新源sudo apt-get updatesudo apt-get upgrade注：如果你想用mt7601又不想编译驱动请不要输入第二行代码 汉化更新完成输入 apt-get install ttf-wqy-microhei 命令来获取字体包并安装 安装完毕输入 aptitude install localesdpkg-reconfigure locales 命令来设置系统的字体，跳出一个文字选择界面，上下翻页、空格键选择以下编码 en_US.UTF-8zh_CN.GBKzh_CN.GB2312zh_CN.UTF-8 然后回车确认将默认字体设置为zh_CN.UTF-8 编辑 locale 文件，输入 nano /etc/default/locale 进入编辑界面，把里面写着en_US.UTF-8的全部改为zh_CN.UTF-8了 然后保存重启就汉化完成了。 网卡配置Armbian采用网络管理器，有GUI，输入nmtui即可开启网络管理器的GUI界面 —–至此系统已简单安装完毕"},{"title":"Orange Pi搭建NAS(2)-硬件选择与组装","date":"2017-07-11T15:09:01.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas2-e7-a1-ac-e4-bb-b6-e9-80-89-e6-8b-a9-e4-b8-8e-e7-bb-84-e8-a3-85.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":"所需硬件下面列出所需硬件，注意有的是可选 Orange Pi One(建议)，降低延迟选择有网口的，我因为要中继选择Lite 散热片（两片）+外壳(带风扇)，一天24小时开机，这个还是有必要。 5V 2A电源，官方店铺有，也可以自己买DC-0.4mm(这种口径很少见，建议直接买官方的) 8 G micro SD card(class 10+)，至少class10，不然后面没得玩。 移动硬盘或者U盘(如果选择硬盘要有易驱线，以及硬盘电源)[可选] USB Wifi(RTL8188eu，MT7601需要编译)[可选] 各型号的资源详情: 安装步骤很简单 拿起香橙派板子，看清楚各种插槽接口，搞清楚是干嘛的，小心插坏了~ 给cpu贴上散热片，要买那种自带粘胶的，手不要抖哦，小心贴歪了。 把风扇的电源插头接到电源引脚上，然后接上电源看风扇转不。香橙派40pin接口板上有个小三角标注一号针，正极接2号针，负极接任何的GND针 没什么问题就装上外壳。 "},{"title":"Orange Pi搭建NAS(1)-开坑","date":"2017-07-11T14:50:28.000Z","url":"/orange-pi-e6-90-ad-e5-bb-banas1-e5-bc-80-e5-9d-91.html","tags":["Orange Pi"],"categories":["折腾记录"],"content":" 入手香橙派也差不多两个月了，其实最初就是想弄一台中继，因为学校网络太坑，最开始是准备买一台T-Link 703N刷openwrt，最后发现还不如香橙派划算，于是入手香橙派。配置还行，可玩性比较高，目前这台迷你中继已经陪伴我1个月了，为什么只有一个月呢，因为各种原因(￣▽￣) 这个系列教程是由我网路搜寻整理而来。主要面向跟我一样没有什么Linux基础的初级入门用户，让大家少走弯路，来自己搭建一个低成本家庭NAS多媒体服务中心，它主要包含samba(文件共享), ftp, upnp/dlna, 远程下载等功能。 本系列主要分为以下几部分： Orange Pi搭建NAS(1)-开坑 Orange Pi搭建NAS(2)-硬件选择与组装 Orange Pi搭建NAS(3)-系统安装 Orange Pi搭建NAS(4)-存储设备 Orange Pi搭建NAS(5)-UPNP/DLNA流媒体 Orange Pi搭建NAS(6)-文件共享 Orange Pi搭建NAS(7)-Aria2远程下载 Orange Pi搭建NAS(8)-外网连接香橙派 "},{"title":"香橙派快速开启AP","date":"2017-07-04T15:50:15.000Z","url":"/e9-a6-99-e6-a9-99-e6-b4-be-e5-bf-ab-e9-80-9f-e5-bc-80-e5-90-afap.html","tags":["Orange Pi","debian，香橙派，ap"],"categories":["折腾记录"],"content":"由于学校网络太渣，手机wifi信号不好于是我入手香橙派lite，但想要在香橙派，树莓派的Linux系统上开启ap，由于香橙派树莓派开启ap步骤繁琐，于是便请求google，发现了create_ap这个好软件。 一、安装依赖注:由于各种系统软件不一，如果提示安装问题去掉即可，debian没有问题 二、安装create_ap 注:如果提示未找到git命令请安装git 三、开启wifi 没有加密的ap 开启wpa wpa2加密的ap 其他 "},{"title":"本博客评论规则","date":"2017-07-01T16:00:06.000Z","url":"/blog-comment-rules.html","categories":["未分类"],"content":"基础规则可评论的内容 关于博客文章的内容，包括提问，建议等。 类似博客文章的内容，包括链接。 博客文章提到的内容的延伸。 关于技术类的内容。 正常交谈的内容，如 问好 等。 日常串门等。 不允许评论的内容 任何广告，与博客文章无关或非技术类的内容。(SPAM) 不适合在工作时间或公共场合查看的内容。(NSFW) 任何关于恐怖主义等极端内容，脱离社会道德的内容 任何含有侮辱他人倾向的内容。 若评论者使用我个人判定为垃圾评论的昵称或不合理的链接（指向不良网站，广告站等），那就抱歉了，小黑屋见。 留言板规则留言板评论自由，但不允许上方不可评论内容的出现。 其他规则由于网络问题，提交后会有一段等待时间，评论者不妨等待一下，若多次提交，即多次提交的内容相近或相同时，博主会视情况保留最长的评论或保留最新的评论，并删除其他多次提交的评论，敬请谅解。 若是技术问题，建议您在发出提问前先看提问的智慧，提出一个好问题是解决问题的必要要素之一。 有关文章的问题尽量在评论区提问，这样也能使更多的人看到。 有关项目的问题或者功能请求请前往Github提交issue。若问题判断为过于简单，或者没有回答的意义，我可能会忽略你的提问（视心情），不管通过任何方式联系我请一次性把问题说完整。 规则可能会更改，视评论情况而定。 Otstar Lin有权在不通知评论者的情况下修改或删除评论者的评论。 Otstar Lin有权在不通知评论者的情况下将评论者送进小黑屋。 一旦评论同时符合可接受和不可接受，Otstar Lin将视情况修改或删除评论。 评论自动回复的邮箱是常用邮箱，请不要将评论的回复通过邮件回复我。 一切无关博客文章的内容请尽量到留言板评论。 访客在本博客评论即说明已经同意以上评论规则，若您不同意以上规则请不要留下评论。 "},{"title":"世界，您好！","date":"2017-06-30T16:40:48.000Z","url":"/hello-world-2-2.html","categories":["未分类"],"content":"留存此篇文章不是因为懒，这篇文章见证了我博客搭建成功的时间(≧▽≦)"}]